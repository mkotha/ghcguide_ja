--- 7.4.2-original/using.xml	2012-06-07 02:10:25.000000000 +0900
+++ original/using.xml	2012-09-05 02:10:15.000000000 +0900
@@ -31,7 +31,8 @@
     <para>To compile the program, use GHC like this:</para>
 
 <screen>
-$ ghc hello.hs</screen>
+$ ghc hello.hs
+</screen>
 
      <para>(where <literal>$</literal> represents the prompt: don't
        type it).  GHC will compile the source
@@ -58,7 +59,8 @@
 
 <screen>
 $ ./hello
-Hello World!</screen>
+Hello World!
+</screen>
 
     <para>
       If your program contains multiple modules, then you only need to
@@ -725,7 +727,8 @@
       <para>Thus, a common invocation would be: </para>
 
 <screen>
-ghc -c Foo.hs</screen>
+ghc -c Foo.hs
+</screen>
 
       <para>to compile the Haskell source file
       <filename>Foo.hs</filename> to an object file
@@ -874,19 +877,25 @@
 
 	  <para>For example:</para>
 
-<screen>test.hs:3:6: parse error on input `where'</screen>
+<screen>
+test.hs:3:6: parse error on input `where'
+</screen>
 
 	  <para>becomes:</para>
 
-<screen>test296.hs:3:6-10: parse error on input `where'</screen>
+<screen>
+test296.hs:3:6-10: parse error on input `where'
+</screen>
 
 	  <para>And multi-line spans are possible too:</para>
 
-<screen>test.hs:(5,4)-(6,7):
+<screen>
+test.hs:(5,4)-(6,7):
     Conflicting definitions for `a'
     Bound at: test.hs:5:4
               test.hs:6:7
-    In the binding group for: a, b, a</screen>
+    In the binding group for: a, b, a
+</screen>
 
 	  <para>Note that line numbers start counting at one, but
 	  column numbers start at zero.  This choice was made to
@@ -945,7 +954,8 @@
     <option>-fwarn-missing-fields</option>,
     <option>-fwarn-missing-methods</option>,
     <option>-fwarn-lazy-unlifted-bindings</option>,
-    <option>-fwarn-wrong-do-bind</option>, and
+    <option>-fwarn-wrong-do-bind</option>,
+    <option>-fwarn-unsupported-calling-conventions</option>, and
     <option>-fwarn-dodgy-foreign-imports</option>.  The following
     flags are
     simple ways to select standard &ldquo;packages&rdquo; of warnings:
@@ -1023,6 +1033,32 @@
     <variablelist>
 
       <varlistentry>
+        <term><option>-fdefer-type-errors</option>:</term>
+        <listitem>
+          <indexterm><primary><option>-fdefer-type-errors</option></primary>
+          </indexterm>
+          <indexterm><primary>warnings</primary></indexterm>
+            <para>Defer as many type errors as possible until runtime.  
+            At compile time you get a warning (instead of an error).  At 
+            runtime, if you use a value that depends on a type error, you 
+            get a runtime error; but you can run any type-correct parts of your code 
+            just fine.  See <xref linkend="defer-type-errors"/></para>
+        </listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term><option>-fhelpful-errors</option>:</term>
+        <listitem>
+          <indexterm><primary><option>-fhelpful-errors</option></primary>
+          </indexterm>
+          <indexterm><primary>warnings</primary></indexterm>
+            <para>When a name or package is not found in scope, make
+            suggestions for the name or package you might have meant instead.</para>
+          <para>This option is on by default.</para>
+        </listitem>
+      </varlistentry>
+
+      <varlistentry>
 	<term><option>-fwarn-unrecognised-pragmas</option>:</term>
 	<listitem>
 	  <indexterm><primary><option>-fwarn-unrecognised-pragmas</option></primary>
@@ -1069,19 +1105,36 @@
       </varlistentry>
 
       <varlistentry>
+        <term><option>-fwarn-unsupported-calling-conventions</option>:</term>
+        <listitem>
+          <indexterm><primary><option>-fwarn-unsupported-calling-conventions</option></primary>
+          </indexterm>
+          <para>Causes a warning to be emitted for foreign declarations
+          that use unsupported calling conventions. In particular,
+          if the <literal>stdcall</literal> calling convention is used
+          on an architecture other than i386 then it will be treated
+          as <literal>ccall</literal>.</para>
+        </listitem>
+      </varlistentry>
+
+      <varlistentry>
 	<term><option>-fwarn-dodgy-foreign-imports</option>:</term>
 	<listitem>
 	  <indexterm><primary><option>-fwarn-dodgy-foreign-imports</option></primary>
 	  </indexterm>
 	  <para>Causes a warning to be emitted for foreign imports of
 	  the following form:</para>
+
 <programlisting>
 foreign import "f" f :: FunPtr t
 </programlisting>
+
           <para>on the grounds that it probably should be</para>
+
 <programlisting>
 foreign import "&amp;f" f :: FunPtr t
 </programlisting>
+
           <para>The first form declares that `f` is a (pure) C
           function that takes no arguments and returns a pointer to a
           C function with type `t`, whereas the second form declares
@@ -1221,9 +1274,11 @@
           non-empty lists, so the compiler will emit a warning about
           this when <option>-fwarn-incomplete-patterns</option> is
           enabled.
+
 <programlisting>
 g [] = 2
 </programlisting>
+
 	  This option isn't enabled by default because it can be
           a bit noisy, and it doesn't always indicate a bug in the
           program.  However, it's generally considered good practice
@@ -1234,10 +1289,12 @@
           similar, except that it
           applies only to lambda-expressions and pattern bindings, constructs
 	  that only allow a single pattern:
+
 <programlisting>
 h = \[] -> 2
 Just k = f y
 </programlisting>
+
           </para>
 	</listitem>
       </varlistentry>
@@ -1300,6 +1357,7 @@
 	    that does not explicitly list the entities brought into scope. For
 	    example
       </para>
+
 <programlisting>
 module M where
   import X( f )
@@ -1307,6 +1365,7 @@
   import qualified Z
   p x = f x x
 </programlisting>
+
         <para>
           The <option>-fwarn-import-lists</option> flag will warn about the import
 	  of <literal>Y</literal> but not <literal>X</literal>
@@ -1394,13 +1453,14 @@
       </varlistentry>
 
       <varlistentry>
-	<term><option>-fwarn-orphans</option>:</term>
+        <term><option>-fwarn-orphans, -fwarn-auto-orphans</option>:</term>
 	<listitem>
 	  <indexterm><primary><option>-fwarn-orphans</option></primary></indexterm>
+          <indexterm><primary><option>-fwarn-auto-orphans</option></primary></indexterm>
 	  <indexterm><primary>orphan instances, warning</primary></indexterm>
 	  <indexterm><primary>orphan rules, warning</primary></indexterm>
 
-	  <para>This option causes a warning to be emitted whenever the
+          <para>These flags cause a warning to be emitted whenever the
 	    module contains an "orphan" instance declaration or rewrite rule.
 	    An instance declaration is an orphan if it appears in a module in
 	    which neither the class nor the type being instanced are declared
@@ -1412,6 +1472,11 @@
 	    play a role, whether or not the module's interface would otherwise
 	    be of any use.  See <xref linkend="orphan-modules"/> for details.
             </para>
+           <para>The flag <option>-fwarn-orphans</option> warns about user-written
+            orphan rules or instances.  The flag <option>-fwarn-auto-orphans</option>
+            warns about automatically-generated orphan rules, notably as a result of
+            specialising functions, for type classes (<literal>Specialise</literal>)
+            or argument values (<literal>SpecConstr</literal>).</para>
 	</listitem>
       </varlistentry>
 
@@ -1720,122 +1785,291 @@
       They are normally set via the <option>-O</option> options
       described above, and as such, you shouldn't need to set any of
       them explicitly (indeed, doing so could lead to unexpected
-      results).  However, there are one or two that may be of
-      interest:</para>
+      results).  A flag <option>-fwombat</option> can be negated by 
+      saying <option>-fno-wombat</option>.  The flags below are off
+      by default, except where noted below.
+     </para>
 
       <variablelist>
 	<varlistentry>
-	  <term><option>-fexcess-precision</option>:</term>
+          <term>
+            <option>-fcse</option>
+            <indexterm><primary><option>-fcse</option></primary></indexterm>
+          </term>
 	  <listitem>
-	    <indexterm><primary><option>-fexcess-precision</option></primary></indexterm>
-	    <para>When this option is given, intermediate floating
-	    point values can have a <emphasis>greater</emphasis>
-	    precision/range than the final type.  Generally this is a
-	    good thing, but some programs may rely on the exact
-	    precision/range of
-	    <literal>Float</literal>/<literal>Double</literal> values
-	    and should not use this option for their compilation.</para>
+            <para><emphasis>On by default.</emphasis>.  Enables the common-sub-expression 
+            elimination optimisation.
+            Switching this off can be useful if you have some <literal>unsafePerformIO</literal>
+            expressions that you don't want commoned-up.</para>
 	  </listitem>
 	</varlistentry>
 
 	<varlistentry>
-	  <term><option>-fignore-asserts</option>:</term>
+          <term>
+            <option>-fstrictness</option>
+            <indexterm><primary><option></option></primary></indexterm>
+          </term>
 	  <listitem>
-	    <indexterm><primary><option>-fignore-asserts</option></primary></indexterm>
-	    <para>Causes GHC to ignore uses of the function
-	    <literal>Exception.assert</literal> in source code (in
-	    other words, rewriting <literal>Exception.assert p
-	    e</literal> to <literal>e</literal> (see <xref
-	    linkend="assertions"/>).  This flag is turned on by
-	    <option>-O</option>.
+            <para> <emphasis>On by default.</emphasis>.  
+            Switch on the strictness analyser. There is a very old paper about GHC's 
+            strictness analyser, <ulink url="http://research.microsoft.com/en-us/um/people/simonpj/papers/simple-strictnes-analyser.ps.gz">
+              Measuring the effectiveness of a simple strictness analyser</ulink>,
+            but the current one is quite a bit different.
+            </para>
+
+            <para>The strictness analyser figures out when arguments and
+            variables in a function can be treated 'strictly' (that is they
+            are always evaluated in the function at some point). This allow
+            GHC to apply certain optimisations such as unboxing that
+            otherwise don't apply as they change the semantics of the program
+            when applied to lazy arguments.
 	    </para>
 	  </listitem>
 	</varlistentry>
 
 	<varlistentry>
 	  <term>
-            <option>-fignore-interface-pragmas</option>
-	    <indexterm><primary><option>-fignore-interface-pragmas</option></primary></indexterm>
+            <option>-funbox-strict-fields</option>:
+            <indexterm><primary><option>-funbox-strict-fields</option></primary></indexterm>
+            <indexterm><primary>strict constructor fields</primary></indexterm>
+            <indexterm><primary>constructor fields, strict</primary></indexterm>
           </term>
 	  <listitem>
-	    <para>Tells GHC to ignore all inessential information when reading interface files.
-	    That is, even if <filename>M.hi</filename> contains unfolding or strictness information
-	    for a function, GHC will ignore that information.</para>
+            <para>This option causes all constructor fields which are marked
+            strict (i.e. &ldquo;!&rdquo;) to be unpacked if possible. It is
+            equivalent to adding an <literal>UNPACK</literal> pragma to every
+            strict constructor field (see <xref linkend="unpack-pragma"/>).
+            </para>
+
+            <para>This option is a bit of a sledgehammer: it might sometimes
+            make things worse. Selectively unboxing fields by using
+            <literal>UNPACK</literal> pragmas might be better. An alternative
+            is to use <option>-funbox-strict-fields</option> to turn on
+            unboxing by default but disable it for certain constructor
+            fields using the <literal>NOUNPACK</literal> pragma (see
+            <xref linkend="nounpack-pragma"/>).</para>
 	  </listitem>
 	</varlistentry>
 
 	<varlistentry>
 	  <term>
-            <option>-fliberate-case</option>
-            <indexterm><primary><option>-fliberate-case</option></primary></indexterm>
+            <option>-fspec-constr</option>
+            <indexterm><primary><option>-fspec-constr</option></primary></indexterm>
           </term>
 	  <listitem>
-	    <para>Turn on the liberate-case transformation.</para>
+            <para><emphasis>Off by default, but enabled by -O2.</emphasis>
+            Turn on call-pattern specialisation; see
+            <ulink url="http://research.microsoft.com/en-us/um/people/simonpj/papers/spec-constr/index.htm">
+              Call-pattern specialisation for Haskell programs</ulink>.
+            </para>
+
+            <para>This optimisation specializes recursive functions according to
+            their argument "shapes". This is best explained by example so
+            consider:
+<programlisting>
+last :: [a] -> a
+last [] = error "last"
+last (x : []) = x
+last (x : xs) = last xs
+</programlisting>
+            In this code, once we pass the initial check for an empty list we
+            know that in the recursive case this pattern match is redundant. As
+            such <option>-fspec-constr</option> will transform the above code
+            to:
+<programlisting>
+last :: [a] -> a
+last []       = error "last"
+last (x : xs) = last' x xs
+    where
+      last' x []       = x
+      last' x (y : ys) = last' y ys
+</programlisting>
+            </para>
+
+            <para>As well avoid unnecessary pattern matching it also helps avoid
+            unnecessary allocation. This applies when a argument is strict in
+            the recursive call to itself but not on the initial entry. As
+            strict recursive branch of the function is created similar to the
+            above example.
+            </para>
 	  </listitem>
 	</varlistentry>
 
 	<varlistentry>
 	  <term>
-            <option>-fno-cse</option>
-            <indexterm><primary><option>-fno-cse</option></primary></indexterm>
+            <option>-fspecialise</option>
+            <indexterm><primary><option>-fspecialise</option></primary></indexterm>
           </term>
 	  <listitem>
-	    <para>Turns off the common-sub-expression elimination optimisation.
-	      Can be useful if you have some <literal>unsafePerformIO</literal>
-	    expressions that you don't want commoned-up.</para>
+            <para><emphasis>On by default.</emphasis>
+            Specialise each type-class-overloaded function defined in this
+            module for the types at which it is called in this module.  Also
+            specialise imported functions that have an INLINABLE pragma
+            (<xref linkend="inlinable-pragma"/>) for the types at which they
+            are called in this module.
+            </para>
 	  </listitem>
 	</varlistentry>
 
 	<varlistentry>
 	  <term>
-            <option>-fno-strictness</option>
-            <indexterm><primary><option>-fno-strictness</option></primary></indexterm>
+            <option>-fstatic-argument-transformation</option>
+            <indexterm><primary><option>-fstatic-argument-transformation</option></primary></indexterm>
           </term>
 	  <listitem>
-	    <para>Turns off the strictness analyser; sometimes it eats
-	    too many cycles.</para>
+            <para>Turn on the static argument transformation, which turns a
+            recursive function into a non-recursive one with a local
+            recursive loop. See Chapter 7 of
+            <ulink url="http://research.microsoft.com/en-us/um/people/simonpj/papers/santos-thesis.ps.gz">
+              Andre Santos's PhD thesis</ulink>
+            </para>
 	  </listitem>
 	</varlistentry>
 
 	<varlistentry>
 	  <term>
-            <option>-fno-full-laziness</option>
-            <indexterm><primary><option>-fno-full-laziness</option></primary></indexterm>
+            <option>-ffloat-in</option>
+            <indexterm><primary><option></option></primary></indexterm>
           </term>
 	  <listitem>
-	    <para>Turns off the full laziness optimisation (also known as
-	      let-floating).  Full laziness increases sharing, which can lead
-	      to increased memory residency.</para>
+            <para><emphasis>On by default.</emphasis>
+            Float let-bindings inwards, nearer their binding site.  See
+            <ulink url="http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz">
+              Let-floating: moving bindings to give faster programs (ICFP'96)</ulink>.
+            </para>
+
+            <para>This optimisation moves let bindings closer to their use
+            site. The benefit here is that this may avoid unnecessary
+            allocation if the branch the let is now on is never executed. It
+            also enables other optimisation passes to work more effectively
+            as they have more information locally.
+            </para>
+
+            <para>This optimisation isn't always beneficial though (so GHC
+            applies some heuristics to decide when to apply it). The details
+            get complicated but a simple example is that it is often beneficial
+            to move let bindings outwards so that multiple let bindings can be
+            grouped into a larger single let binding, effectively batching
+            their allocation and helping the garbage collector and allocator.
+            </para>
+          </listitem>
+        </varlistentry>
+
+        <varlistentry>
+          <term>
+            <option>-ffull-laziness</option>
+            <indexterm><primary><option>-ffull-laziness</option></primary></indexterm>
+          </term>
+          <listitem>
+            <para><emphasis>On by default.</emphasis>
+            Run the full laziness optimisation (also known as let-floating),
+            which floats let-bindings outside enclosing lambdas, in the hope
+            they will be thereby be computed less often.  See
+            <ulink url="http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz">Let-floating:
+              moving bindings to give faster programs (ICFP'96)</ulink>.
+            Full laziness increases sharing, which can lead to increased memory
+            residency.
+            </para>
 
             <para>NOTE: GHC doesn't implement complete full-laziness.
-            When optimisation in on, and
-            <option>-fno-full-laziness</option> is not given, some
-            transformations that increase sharing are performed, such
-            as extracting repeated computations from a loop.  These
-            are the same transformations that a fully lazy
-            implementation would do, the difference is that GHC
-            doesn't consistently apply full-laziness, so don't rely on
-            it.</para>
+            When optimisation in on, and <option>-fno-full-laziness</option>
+            is not given, some transformations that increase sharing are
+            performed, such as extracting repeated computations from a loop.
+            These are the same transformations that a fully lazy
+            implementation would do, the difference is that GHC doesn't
+            consistently apply full-laziness, so don't rely on it.
+            </para>
 	  </listitem>
 	</varlistentry>
 
 	<varlistentry>
 	  <term>
-            <option>-fno-float-in</option>
-            <indexterm><primary><option>-fno-float-in</option></primary></indexterm>
+            <option>-fdo-lambda-eta-expansion</option>
+            <indexterm><primary><option></option></primary></indexterm>
           </term>
 	  <listitem>
-	    <para>Turns off the float-in transformation.</para>
+            <para><emphasis>On by default.</emphasis>
+            Eta-expand let-bindings to increase their arity.
+            </para>
 	  </listitem>
 	</varlistentry>
 
 	<varlistentry>
 	  <term>
-            <option>-fno-specialise</option>
-            <indexterm><primary><option>-fno-specialise</option></primary></indexterm>
+            <option>-fdo-eta-reduction</option>
+            <indexterm><primary><option></option></primary></indexterm>
           </term>
 	  <listitem>
-	    <para>Turns off the automatic specialisation of overloaded functions.</para>
+            <para><emphasis>On by default.</emphasis>
+            Eta-reduce lambda expressions, if doing so gets rid of a whole
+            group of lambdas.
+            </para>
+          </listitem>
+        </varlistentry>
+
+        <varlistentry>
+          <term>
+            <option>-fcase-merge</option>
+            <indexterm><primary><option></option></primary></indexterm>
+          </term>
+          <listitem>
+            <para><emphasis>On by default.</emphasis> 
+            Merge immediately-nested case expressions that scrutinse the same variable. Example
+<programlisting>
+  case x of
+     Red -> e1
+     _   -> case x of 
+              Blue -> e2
+              Green -> e3
+==>
+  case x of
+     Red -> e1
+     Blue -> e2
+     Green -> e2
+</programlisting>
+            </para>
+          </listitem>
+        </varlistentry>
+
+        <varlistentry>
+          <term>
+            <option>-fliberate-case</option>
+            <indexterm><primary><option>-fliberate-case</option></primary></indexterm>
+          </term>
+          <listitem>
+            <para><emphasis>Off by default, but enabled by -O2.</emphasis> 
+            Turn on the liberate-case transformation.  This unrolls recursive
+            function once in its own RHS, to avoid repeated case analysis of
+            free variables.  It's a bit like the call-pattern specialiser
+            (<option>-fspec-constr</option>) but for free variables rather than
+            arguments.
+            </para>
+          </listitem>
+        </varlistentry>
+
+        <varlistentry>
+          <term>
+            <option>-fdicts-cheap</option>
+            <indexterm><primary><option></option></primary></indexterm>
+          </term>
+          <listitem>
+            <para>A very experimental flag that makes dictionary-valued
+            expressions seem cheap to the optimiser.
+            </para>
+          </listitem>
+        </varlistentry>
+
+        <varlistentry>
+          <term>
+            <option>-feager-blackholing</option>
+            <indexterm><primary><option></option></primary></indexterm>
+          </term>
+          <listitem>
+            <para>Usually GHC black-holes a thunk only when it switches
+            threads. This flag makes it do so as soon as the thunk is
+            entered. See <ulink url="http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/">
+              Haskell on a shared-memory multiprocessor</ulink>.
+            </para>
 	  </listitem>
 	</varlistentry>
 
@@ -1849,7 +2083,8 @@
 	      <literal>State#</literal> token as argument is considered to be
 	      single-entry, hence it is considered OK to inline things inside
 	      it.  This can improve performance of IO and ST monad code, but it
-	    runs the risk of reducing sharing.</para>
+            runs the risk of reducing sharing.
+            </para>
 	  </listitem>
 	</varlistentry>
 
@@ -1863,139 +2098,231 @@
                      <option>-fno-state-hack</option>). In particular, stop GHC 
                      eta-expanding through a case expression, which is good for
 		     performance, but bad if you are using <literal>seq</literal> on
-                     partial applications.</para>
+            partial applications.
+            </para>
 	  </listitem>
 	</varlistentry>
 
 	<varlistentry>
 	  <term>
-            <option>-fomit-interface-pragmas</option>
-	    <indexterm><primary><option>-fomit-interface-pragmas</option></primary></indexterm>
+            <option>-fsimpl-tick-factor=<replaceable>n</replaceable></option>
+            <indexterm><primary><option>-fsimpl-tick-factor</option></primary></indexterm>
           </term>
 	  <listitem>
-	    <para>Tells GHC to omit all inessential information from the interface file
-	      generated for the module being compiled (say M).  This means that a module
-	      importing M will see only the <emphasis>types</emphasis> of the functions that M exports, but not
-	      their unfoldings, strictness info, etc.  Hence, for example,
-	      no function exported by M will be inlined
-	      into an importing module.  The benefit is that modules that import M will
-	      need to be recompiled less often (only when M's exports change their type,
-	      not when they change their implementation).
+            <para>GHC's optimiser can diverge if you write rewrite rules (
+              <xref linkend="rewrite-rules"/>) that don't terminate, or (less
+            satisfactorily) if you code up recursion through data types
+            (<xref linkend="bugs-ghc"/>).  To avoid making the compiler fall
+            into an infinite loop, the optimiser carries a "tick count" and
+            stops inlining and applying rewrite rules when this count is
+            exceeded.  The limit is set as a multiple of the program size, so
+            bigger programs get more ticks. The
+            <option>-fsimpl-tick-factor</option> flag lets you change the
+            multiplier. The default is 100; numbers larger than 100 give more
+            ticks, and numbers smaller than 100 give fewer.
+            </para>
+
+            <para>If the tick-count expires, GHC summarises what simplifier
+            steps it has done; you can use
+            <option>-fddump-simpl-stats</option> to generate a much more
+            detailed list.  Usually that identifies the loop quite
+            accurately, because some numbers are very large.
 	      </para>
 	  </listitem>
 	</varlistentry>
 
 	<varlistentry>
 	  <term>
-            <option>-fsimpl-tick-factor=<replaceable>n</replaceable></option>
-            <indexterm><primary><option>-fsimpl-tick-factor</option></primary></indexterm>
+            <option>-funfolding-creation-threshold=<replaceable>n</replaceable></option>:
+            <indexterm><primary><option>-funfolding-creation-threshold</option></primary></indexterm>
+            <indexterm><primary>inlining, controlling</primary></indexterm>
+            <indexterm><primary>unfolding, controlling</primary></indexterm>
           </term>
 	  <listitem>
-	    <para>GHC's optimiser can diverge if you write rewrite rules (<xref linkend="rewrite-rules"/>) 
-              that don't terminate, or (less satisfactorily) if you
-              code up recursion through data types
-              (<xref linkend="bugs-ghc"/>).  To avoid making the compiler fall into an infinite
-	      loop, the optimiser carries a "tick count" and stops inlining and applying rewrite rules
-              when this count is exceeded.  The limit is set as a multiple of the program size, so 
-              bigger programs get more ticks. The <option>-fsimpl-tick-factor</option> flag lets
-              you change the multiplier. The default is 100; numbers larger than 100 give more ticks,
-              and numbers smaller than 100 give fewer.</para>
-            <para>If the tick-count expires, GHC summarises what simplifier steps it has done; 
-            you can use <option>-fddump-simpl-stats</option> to generate a much more detailed list.
-            Usually that identifies the loop quite accurately, because some numbers are very large.
+            <para>(Default: 45) Governs the maximum size that GHC will allow a
+            function unfolding to be. (An unfolding has a &ldquo;size&rdquo;
+            that reflects the cost in terms of &ldquo;code bloat&rdquo; of
+            expanding (aka inlining) that unfolding at a call site. A bigger
+            function would be assigned a bigger cost.)
+            </para>
+
+            <para>Consequences: (a) nothing larger than this will be inlined
+            (unless it has an INLINE pragma); (b) nothing larger than this
+            will be spewed into an interface file.
+            </para>
+
+            <para>Increasing this figure is more likely to result in longer
+            compile times than faster code. The
+            <option>-funfolding-use-threshold</option> is more useful.
 	      </para>
 	  </listitem>
 	</varlistentry>
 
 	<varlistentry>
 	  <term>
-            <option>-fstatic-argument-transformation</option>
-            <indexterm><primary><option>-fstatic-argument-transformation</option></primary></indexterm>
+            <option>-funfolding-use-threshold=<replaceable>n</replaceable></option>
+            <indexterm><primary><option>-funfolding-use-threshold</option></primary></indexterm>
+            <indexterm><primary>inlining, controlling</primary></indexterm>
+            <indexterm><primary>unfolding, controlling</primary></indexterm>
           </term>
 	  <listitem>
-	    <para>Turn on the static argument transformation.</para>
+            <para>(Default: 8) This is the magic cut-off figure for unfolding
+            (aka inlining): below this size, a function definition will be
+            unfolded at the call-site, any bigger and it won't. The size
+            computed for a function depends on two things: the actual size of
+            the expression minus any discounts that
+            apply (see <option>-funfolding-con-discount</option>).
+            </para>
+
+            <para>The difference between this and
+            <option>-funfolding-creation-threshold</option> is that this one
+            determines if a function definition will be inlined <emphasis>at
+              a call site</emphasis>. The other option determines if a
+            function definition will be kept around at all for potential
+            inlining.
+            </para>
 	  </listitem>
 	</varlistentry>
 
 	<varlistentry>
 	  <term>
-            <option>-fspec-constr</option>
-            <indexterm><primary><option>-fspec-constr</option></primary></indexterm>
+            <option>-fexpose-all-unfoldings</option>
+            <indexterm><primary><option></option></primary></indexterm>
           </term>
 	  <listitem>
-	    <para>Turn on call-pattern specialisation.</para>
+            <para>An experimental flag to expose all unfoldings, even for very
+            large or recursive functions. This allows for all functions to be
+            inlined while usually GHC would avoid inlining larger functions.
+            </para>
 	  </listitem>
 	</varlistentry>
 
 	<varlistentry>
 	  <term>
-            <option>-funbox-strict-fields</option>:
-	    <indexterm><primary><option>-funbox-strict-fields</option></primary></indexterm>
-	    <indexterm><primary>strict constructor fields</primary></indexterm>
-	    <indexterm><primary>constructor fields, strict</primary></indexterm>
+            <option>-fvectorise</option>
+            <indexterm><primary><option></option></primary></indexterm>
           </term>
 	  <listitem>
-	    <para>This option causes all constructor fields which are
-            marked strict (i.e. &ldquo;!&rdquo;) to be unboxed or
-            unpacked if possible.  It is equivalent to adding an
-            <literal>UNPACK</literal> pragma to every strict
-            constructor field (see <xref
-            linkend="unpack-pragma"/>).</para>
+            <para>Data Parallel Haskell.
+            </para>
+            TODO: Document optimisation
+          </listitem>
+        </varlistentry>
 
-	    <para>This option is a bit of a sledgehammer: it might
-	    sometimes make things worse.  Selectively unboxing fields
-	    by using <literal>UNPACK</literal> pragmas might be
-	    better. An alternative is to use
-        <option>-funbox-strict-fields</option> to turn on
-        unboxing by default but disable it for certain constructor
-        fields using the <literal>NOUNPACK</literal> pragma
-        (see <xref linkend="nounpack-pragma"/>).
+        <varlistentry>
+          <term>
+            <option>-favoid-vect</option>
+            <indexterm><primary><option></option></primary></indexterm>
+          </term>
+          <listitem>
+            <para>Data Parallel Haskell.
         </para>
+            TODO: Document optimisation
 	  </listitem>
 	</varlistentry>
 
 	<varlistentry>
 	  <term>
-            <option>-funfolding-creation-threshold=<replaceable>n</replaceable></option>:
-	    <indexterm><primary><option>-funfolding-creation-threshold</option></primary></indexterm>
-	    <indexterm><primary>inlining, controlling</primary></indexterm>
-	    <indexterm><primary>unfolding, controlling</primary></indexterm>
+            <option>-fregs-graph</option>
+            <indexterm><primary><option></option></primary></indexterm>
           </term>
 	  <listitem>
-	    <para>(Default: 45) Governs the maximum size that GHC will
-            allow a function unfolding to be.   (An unfolding has a
-            &ldquo;size&rdquo; that reflects the cost in terms of
-            &ldquo;code bloat&rdquo; of expanding that unfolding
-            at a call site. A bigger function would be assigned a
-            bigger cost.) </para>
+            <para><emphasis>Off by default, but enabled by -O2. Only applies in
+              combination with the native code generator.</emphasis>
+            Use the graph colouring register allocator for register allocation
+            in the native code generator. By default, GHC uses a simpler,
+            faster linear register allocator. The downside being that the
+            linear register allocator usually generates worse code.
+            </para>
+          </listitem>
+        </varlistentry>
 
-	    <para> Consequences: (a) nothing larger than this will be
-	    inlined (unless it has an INLINE pragma); (b) nothing
-	    larger than this will be spewed into an interface
-	    file. </para>
+        <varlistentry>
+          <term>
+            <option>-fregs-iterative</option>
+            <indexterm><primary><option></option></primary></indexterm>
+          </term>
+          <listitem>
+            <para><emphasis>Off by default, only applies in combination with
+              the native code generator.</emphasis>
+            Use the iterative coalescing graph colouring register allocator for
+            register allocation in the native code generator. This is the same
+            register allocator as the <option>-freg-graph</option> one but also
+            enables iterative coalescing during register allocation.
+            </para>
+          </listitem>
+        </varlistentry>
 
+        <varlistentry>
+          <term>
+            <option>-fexcess-precision</option>
+            <indexterm><primary><option>-fexcess-precision</option></primary></indexterm>
+          </term>
+          <listitem>
+            <para>When this option is given, intermediate floating
+            point values can have a <emphasis>greater</emphasis>
+            precision/range than the final type.  Generally this is a
+            good thing, but some programs may rely on the exact
+            precision/range of
+            <literal>Float</literal>/<literal>Double</literal> values
+            and should not use this option for their compilation.</para>
 
-            <para> Increasing this figure is more likely to result in longer
-            compile times than faster code.  The next option is more
-            useful:</para>
+            <para>
+              Note that the 32-bit x86 native code generator only
+              supports excess-precision mode, so neither
+              <option>-fexcess-precision</option> nor
+              <option>-fno-excess-precision</option> has any effect.
+              This is a known bug, see <xref linkend="bugs-ghc" />.
+            </para>
 	  </listitem>
 	</varlistentry>
 
 	<varlistentry>
-	  <term><option>-funfolding-use-threshold=<replaceable>n</replaceable></option></term>
+          <term>
+            <option>-fignore-asserts</option>
+            <indexterm><primary><option>-fignore-asserts</option></primary></indexterm>
+          </term>
 	  <listitem>
-	    <indexterm><primary><option>-funfolding-use-threshold</option></primary></indexterm>
-	    <indexterm><primary>inlining, controlling</primary></indexterm>
-	    <indexterm><primary>unfolding, controlling</primary></indexterm>
+            <para>Causes GHC to ignore uses of the function
+            <literal>Exception.assert</literal> in source code (in
+            other words, rewriting <literal>Exception.assert p
+            e</literal> to <literal>e</literal> (see <xref
+            linkend="assertions"/>).  This flag is turned on by
+            <option>-O</option>.
+            </para>
+          </listitem>
+        </varlistentry>
 
-	    <para>(Default: 8) This is the magic cut-off figure for
-            unfolding: below this size, a function definition will be
-            unfolded at the call-site, any bigger and it won't.  The
-            size computed for a function depends on two things: the
-            actual size of the expression minus any discounts that
-            apply (see <option>-funfolding-con-discount</option>).</para>
+        <varlistentry>
+          <term>
+            <option>-fignore-interface-pragmas</option>
+            <indexterm><primary><option>-fignore-interface-pragmas</option></primary></indexterm>
+          </term>
+          <listitem>
+            <para>Tells GHC to ignore all inessential information when reading interface files.
+            That is, even if <filename>M.hi</filename> contains unfolding or strictness information
+            for a function, GHC will ignore that information.</para>
+          </listitem>
+        </varlistentry>
+
+        <varlistentry>
+          <term>
+            <option>-fomit-interface-pragmas</option>
+            <indexterm><primary><option>-fomit-interface-pragmas</option></primary></indexterm>
+          </term>
+          <listitem>
+            <para>Tells GHC to omit all inessential information from the
+            interface file generated for the module being compiled (say M).
+            This means that a module importing M will see only the
+            <emphasis>types</emphasis> of the functions that M exports, but
+            not their unfoldings, strictness info, etc.  Hence, for example,
+            no function exported by M will be inlined into an importing module.
+            The benefit is that modules that import M will need to be
+            recompiled less often (only when M's exports change their type, not
+            when they change their implementation).</para>
 	  </listitem>
 	</varlistentry>
+
       </variablelist>
 
     </sect2>
@@ -2144,7 +2471,7 @@
 
       <para>There are two ways to run a program on multiple
         processors:
-        call <literal>GHC.Conc.setNumCapabilities</literal> from your
+        call <literal>Control.Concurrent.setNumCapabilities</literal> from your
         program, or use the RTS <option>-N</option> option.</para>
 
       <variablelist>
@@ -2177,13 +2504,9 @@
 
             <para>The current value of the <option>-N</option> option
               is available to the Haskell program
-              via <literal>GHC.Conc.getNumCapabilities</literal>, and
+              via <literal>Control.Concurrent.getNumCapabilities</literal>, and
               it may be changed while the program is running by
-              calling <literal>GHC.Conc.setNumCapabilities</literal>.
-              Note: in the current implementation,
-              the <option>-N</option> value may only
-              be <emphasis>increased</emphasis>, not decreased, by
-              calling <literal>GHC.Conc.setNumCapabilities</literal>.</para>
+              calling <literal>Control.Concurrent.setNumCapabilities</literal>.</para>
 	  </listitem>
 	</varlistentry>
       </variablelist>
@@ -2219,7 +2542,7 @@
             <para>
               This option is probably only of use for concurrent
               programs that explicitly schedule threads onto CPUs
-              with <literal>GHC.Conc.forkOnIO</literal>.
+              with <literal>Control.Concurrent.forkOn</literal>.
             </para>
           </listitem>
         </varlistentry>
