diff -urd 7.6.3-original/ug-book.xml original/ug-book.xml
--- 7.6.3-original/ug-book.xml	2014-06-27 09:19:05.733250365 +0900
+++ original/ug-book.xml	2014-06-27 09:31:23.084721605 +0900
@@ -1,9 +1,9 @@
 <?xml version="1.0" encoding="iso-8859-1"?>
 <bookinfo>
-<title>The Glorious Glasgow Haskell Compilation System User's Guide, Version 7.6.2</title>
+<title>The Glorious Glasgow Haskell Compilation System User's Guide, Version 7.8.2</title>
 <author><othername>The GHC Team</othername></author>
 <address>
-<email>glasgow-haskell-&lcub;bugs,users&rcub;-request@haskell.org</email>
+<email>glasgow-haskell-users-request@haskell.org</email>
 </address>
 </bookinfo>
 
diff -urd 7.6.3-original/ug-book.xml.in original/ug-book.xml.in
--- 7.6.3-original/ug-book.xml.in	2014-06-27 09:19:06.090240903 +0900
+++ original/ug-book.xml.in	2014-04-08 03:26:08.000000000 +0900
@@ -3,7 +3,7 @@
 <title>@ProjectName@ User's Guide, Version @ProjectVersion@</title>
 <author><othername>The GHC Team</othername></author>
 <address>
-<email>glasgow-haskell-&lcub;bugs,users&rcub;-request@haskell.org</email>
+<email>glasgow-haskell-users-request@haskell.org</email>
 </address>
 </bookinfo>
 
Only in 7.6.3-original: users_guide
diff -urd 7.6.3-original/using.xml original/using.xml
--- 7.6.3-original/using.xml	2014-06-27 09:19:05.746250021 +0900
+++ original/using.xml	2014-04-08 03:26:08.000000000 +0900
@@ -308,6 +308,7 @@
 
   <sect1 id="modes">
     <title>Modes of operation</title>
+    <indexterm><primary>help options</primary></indexterm>
 
     <para>
       GHC's behaviour is firstly controlled by a mode flag.  Only one
@@ -473,9 +474,21 @@
       <varlistentry>
         <term>
           <cmdsynopsis>
+            <command>ghc --show-options</command>
+          </cmdsynopsis>
+          <indexterm><primary><option>--show-options</option></primary></indexterm>
+        </term>
+        <listitem>
+          <para>Print the supported command line options. This flag can be used for autocompletion in a shell.</para>
+        </listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term>
+          <cmdsynopsis>
             <command>ghc --info</command>
           </cmdsynopsis>
@@ -584,11 +597,16 @@
           invoked, so the dependencies never get out of sync with the
           source.</para>
         </listitem>
+        <listitem>
+          <para>Using the <literal>-j</literal> flag, you can compile
+          modules in parallel. Specify <literal>-jN</literal> to
+          compile <replaceable>N</replaceable> jobs in parallel.</para>
+        </listitem>
       </itemizedlist>
 
       <para>Any of the command-line options described in the rest of
@@ -774,9 +792,8 @@
   </sect1>
 
   <sect1 id="options-help">
-    <title>Help and verbosity options</title>
+    <title>Verbosity options</title>
 
-    <indexterm><primary>help options</primary></indexterm>
     <indexterm><primary>verbosity options</primary></indexterm>
 
     <para>See also the <option>--help</option>, <option>--version</option>, <option>--numeric-version</option>,
@@ -864,6 +881,43 @@
         </listitem>
       </varlistentry>
 
+
+      <varlistentry>
+        <term><option>--fprint-explicit-foralls, -fprint-explicit-kinds</option>
+          <indexterm><primary><option>-fprint-explicit-foralls</option></primary></indexterm>
+          <indexterm><primary><option>-fprint-explicit-kinds</option></primary></indexterm>
+        </term>
+        <listitem>
+          <para>These two flags control the way in which GHC displays types, in error messages and in GHCi.
+          Using <option>-fprint-explicit-foralls</option> makes GHC print explicit <literal>forall</literal>
+          quantification at the top level of a type; normally this is suppressed.  For example, in GHCi:
+<screen>
+ghci> let f x = x
+ghci> :t f
+f :: a -> a
+ghci> :set -fprint-explicit-foralls
+ghci> :t f
+f :: forall a. a -> a
+</screen>
+         Using <option>-fprint-explicit-kinds</option> makes GHC print kind-foralls and kind applications
+         in types, which are normally suppressed.  This can be important when you are using kind polymorphism.
+         For example:
+<screen>
+ghci> :set -XPolyKinds
+ghci> data T a = MkT
+ghci> :t MkT
+MkT :: T b
+ghci> :set -fprint-explicit-foralls
+ghci> :t MkT
+MkT :: forall (b::k). T b
+ghci> :set -fprint-explicit-kinds
+ghci> :t MkT
+MkT :: forall (k::BOX) (b:k). T b
+</screen>
+         </para>
+        </listitem>
+      </varlistentry>
+
       <varlistentry>
         <term><option>-ferror-spans</option>
           <indexterm><primary><option>-ferror-spans</option></primary>
@@ -949,16 +1003,23 @@
     program.  These are:
     <option>-fwarn-overlapping-patterns</option>,
     <option>-fwarn-warnings-deprecations</option>,
+    <option>-fwarn-amp</option>,
     <option>-fwarn-deprecated-flags</option>,
+    <option>-fwarn-unrecognised-pragmas</option>,
+    <option>-fwarn-pointless-pragmas</option>,
+    <option>-fwarn-duplicate-constraints</option>,
     <option>-fwarn-duplicate-exports</option>,
+    <option>-fwarn-overflowed-literals</option>,
+    <option>-fwarn-empty-enumerations</option>,
     <option>-fwarn-missing-fields</option>,
     <option>-fwarn-missing-methods</option>,
-    <option>-fwarn-lazy-unlifted-bindings</option>,
     <option>-fwarn-wrong-do-bind</option>,
-    <option>-fwarn-unsupported-calling-conventions</option>, and
-    <option>-fwarn-dodgy-foreign-imports</option>.  The following
-    flags are
-    simple ways to select standard &ldquo;packages&rdquo; of warnings:
+    <option>-fwarn-unsupported-calling-conventions</option>,
+    <option>-fwarn-dodgy-foreign-imports</option>,
+    <option>-fwarn-inline-rule-shadowing</option>, and
+    <option>-fwarn-unsupported-llvm-version</option>.
+    The following flags are simple ways to select standard
+    &ldquo;packages&rdquo; of warnings:
     </para>
 
     <variablelist>
@@ -1033,6 +1094,26 @@
     <variablelist>
 
       <varlistentry>
+        <term><option>-fwarn-typed-holes</option>:</term>
+        <listitem>
+          <indexterm><primary><option>-fwarn-typed-holes</option></primary>
+          </indexterm>
+          <indexterm><primary>warnings</primary></indexterm>
+            <para>When the compiler encounters an unbound local
+            variable prefixed with <literal>_</literal>, or encounters
+            the literal <literal>_</literal> on the right-hand side of
+            an expression, the error message for the unbound term
+            includes the type it needs to type check. It works
+            particularly well with <link
+            linkend="defer-type-errors">deferred type errors</link>.
+            See <xref linkend="typed-holes"/></para>
+
+            <para>This warning is on by default.</para>
+        </listitem>
+      </varlistentry>
+
+
+      <varlistentry>
         <term><option>-fdefer-type-errors</option>:</term>
         <listitem>
           <indexterm><primary><option>-fdefer-type-errors</option></primary>
@@ -1076,6 +1157,20 @@
       </varlistentry>
 
       <varlistentry>
+        <term><option>-fwarn-pointless-pragmas</option>:</term>
+        <listitem>
+          <indexterm><primary><option>-fwarn-pointless-pragmas</option></primary>
+          </indexterm>
+          <indexterm><primary>warnings</primary></indexterm>
+          <indexterm><primary>pragmas</primary></indexterm>
+          <para>Causes a warning to be emitted when GHC detects that a
+          module contains a pragma that has no effect.</para>
+
+          <para>This option is on by default.</para>
+        </listitem>
+      </varlistentry>
+
+      <varlistentry>
         <term><option>-fwarn-warnings-deprecations</option>:</term>
         <listitem>
           <indexterm><primary><option>-fwarn-warnings-deprecations</option></primary>
@@ -1092,6 +1187,24 @@
       </varlistentry>
 
       <varlistentry>
+        <term><option>-fwarn-amp</option>:</term>
+        <listitem>
+          <indexterm><primary><option>-fwarn-amp</option></primary>
+          </indexterm>
+          <indexterm><primary>amp</primary></indexterm>
+          <indexterm><primary>applicative-monad proposal</primary></indexterm>
+          <para>Causes a warning to be emitted when a definition
+          is in conflict with the AMP (Applicative-Monad proosal),
+          namely:
+          1. Instance of Monad without Applicative;
+          2. Instance of MonadPlus without Alternative;
+          3. Custom definitions of join/pure/&lt;*&gt;</para>
+
+          <para>This option is on by default.</para>
+        </listitem>
+      </varlistentry>
+
+      <varlistentry>
         <term><option>-fwarn-deprecated-flags</option>:</term>
         <listitem>
           <indexterm><primary><option>-fwarn-deprecated-flags</option></primary>
@@ -1164,10 +1277,43 @@
         <listitem>
           <indexterm><primary><option>-fwarn-dodgy-imports</option></primary>
           </indexterm>
-          <para>Causes a warning to be emitted when a datatype
-      <literal>T</literal> is imported
-      with all constructors, i.e. <literal>T(..)</literal>, but has been
-      exported abstractly, i.e. <literal>T</literal>.</para>
+          <para>Causes a warning to be emitted in the following cases:</para>
+          <itemizedlist>
+            <listitem>
+              <para>When a datatype <literal>T</literal> is imported with all
+                constructors, i.e. <literal>T(..)</literal>, but has been
+                exported abstractly, i.e. <literal>T</literal>.
+              </para>
+            </listitem>
+            <listitem>
+              <para>When an <literal>import</literal> statement hides an
+                entity that is not exported.</para>
+            </listitem>
+          </itemizedlist>
+        </listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term><option>-fwarn-overflowed-literals</option>:</term>
+        <listitem>
+          <indexterm><primary><option>-fwarn-overflowed-literals</option></primary>
+          </indexterm>
+          <para>
+              Causes a warning to be emitted if a literal will overflow,
+              e.g. <literal>300 :: Word8</literal>.
+          </para>
+        </listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term><option>-fwarn-empty-enumerations</option>:</term>
+        <listitem>
+          <indexterm><primary><option>-fwarn-empty-enumerations</option></primary>
+          </indexterm>
+          <para>
+              Causes a warning to be emitted if an enumeration is
+              empty, e.g. <literal>[5 .. 3]</literal>.
+          </para>
         </listitem>
       </varlistentry>
 
@@ -1176,12 +1322,25 @@
         <listitem>
           <indexterm><primary><option>-fwarn-lazy-unlifted-bindings</option></primary>
           </indexterm>
-          <para>Causes a warning to be emitted when an unlifted type
-      is bound in a way that looks lazy, e.g.
-      <literal>where (I# x) = ...</literal>. Use
-      <literal>where !(I# x) = ...</literal> instead. This will be an
-      error, rather than a warning, in GHC 7.2.
-      </para>
+          <para>This flag is a no-op, and will be removed in GHC 7.10.</para>
+        </listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term><option>-fwarn-duplicate-constraints</option>:</term>
+        <listitem>
+          <indexterm><primary><option>-fwarn-duplicate-constraints</option></primary></indexterm>
+          <indexterm><primary>duplicate constraints, warning</primary></indexterm>
+
+          <para>Have the compiler warn about duplicate constraints in a type signature. For
+          example
+          <programlisting>
+             f :: (Eq a, Show a, Eq a) => a -> a
+          </programlisting>
+          The warning will indicate the duplicated <literal>Eq a</literal> constraint.
+          </para>
+
+          <para>This option is on by default.</para>
         </listitem>
       </varlistentry>
 
@@ -1401,6 +1560,7 @@
             never <literal>_simpleFn</literal>; and (b)
             instance declarations can define either <literal>complexFn</literal> or <literal>_simpleFn</literal>.
             </para>
+          <para>The MINIMAL pragma can be used to change which combination of methods will be required for instances of a particular class. See <xref linkend="minimal-pragma"/>.</para>
         </listitem>
       </varlistentry>
 
@@ -1476,7 +1636,7 @@
             orphan rules or instances.  The flag <option>-fwarn-auto-orphans</option>
             warns about automatically-generated orphan rules, notably as a result of
             specialising functions, for type classes (<literal>Specialise</literal>)
-            or argument values (<literal>SpecConstr</literal>).</para>
+            or argument values (<literal>-fspec-constr</literal>).</para>
         </listitem>
       </varlistentry>
 
@@ -1787,12 +1947,59 @@
       them explicitly (indeed, doing so could lead to unexpected
       results).  A flag <option>-fwombat</option> can be negated by 
       saying <option>-fno-wombat</option>.  The flags below are off
-      by default, except where noted below.
+      by default, except where noted below.  See <xref linkend="options-f-compact"/> 
+      for a compact list.
      </para>
 
       <variablelist>
         <varlistentry>
           <term>
+            <option>-favoid-vect</option>
+            <indexterm><primary><option></option></primary></indexterm>
+          </term>
+          <listitem>
+            <para>Part of <link linkend="dph">Data Parallel Haskell
+            (DPH)</link>.</para>
+
+            <para><emphasis>Off by default.</emphasis> Enable the
+            <emphasis>vectorisation</emphasis> avoidance optimisation. This
+            optimisation only works when used in combination with the
+            <option>-fvectorise</option> transformation.</para>
+
+            <para>While vectorisation of code using DPH is often a big win, it
+            can also produce worse results for some kinds of code. This
+            optimisation modifies the vectorisation transformation to try to
+            determine if a function would be better of unvectorised and if
+            so, do just that.</para>
+          </listitem>
+        </varlistentry>
+
+        <varlistentry>
+          <term>
+            <option>-fcase-merge</option>
+            <indexterm><primary><option></option></primary></indexterm>
+          </term>
+          <listitem>
+            <para><emphasis>On by default.</emphasis> 
+            Merge immediately-nested case expressions that scrutinse the same variable. Example
+<programlisting>
+  case x of
+     Red -> e1
+     _   -> case x of 
+              Blue -> e2
+              Green -> e3
+==>
+  case x of
+     Red -> e1
+     Blue -> e2
+     Green -> e2
+</programlisting>
+            </para>
+          </listitem>
+        </varlistentry>
+
+        <varlistentry>
+          <term>
             <option>-fcse</option>
             <indexterm><primary><option>-fcse</option></primary></indexterm>
           </term>
@@ -1806,122 +2013,88 @@
 
         <varlistentry>
           <term>
-            <option>-fstrictness</option>
+            <option>-fdicts-cheap</option>
             <indexterm><primary><option></option></primary></indexterm>
           </term>
           <listitem>
-            <para> <emphasis>On by default.</emphasis>.  
-            Switch on the strictness analyser. There is a very old paper about GHC's 
-            strictness analyser, <ulink url="http://research.microsoft.com/en-us/um/people/simonpj/papers/simple-strictnes-analyser.ps.gz">
-              Measuring the effectiveness of a simple strictness analyser</ulink>,
-            but the current one is quite a bit different.
-            </para>
-
-            <para>The strictness analyser figures out when arguments and
-            variables in a function can be treated 'strictly' (that is they
-            are always evaluated in the function at some point). This allow
-            GHC to apply certain optimisations such as unboxing that
-            otherwise don't apply as they change the semantics of the program
-            when applied to lazy arguments.
+            <para>A very experimental flag that makes dictionary-valued
+            expressions seem cheap to the optimiser.
             </para>
           </listitem>
         </varlistentry>
 
         <varlistentry>
           <term>
-            <option>-funbox-strict-fields</option>:
-            <indexterm><primary><option>-funbox-strict-fields</option></primary></indexterm>
-            <indexterm><primary>strict constructor fields</primary></indexterm>
-            <indexterm><primary>constructor fields, strict</primary></indexterm>
+            <option>-fdo-lambda-eta-expansion</option>
+            <indexterm><primary><option></option></primary></indexterm>
           </term>
           <listitem>
-            <para>This option causes all constructor fields which are marked
-            strict (i.e. &ldquo;!&rdquo;) to be unpacked if possible. It is
-            equivalent to adding an <literal>UNPACK</literal> pragma to every
-            strict constructor field (see <xref linkend="unpack-pragma"/>).
+            <para><emphasis>On by default.</emphasis>
+            Eta-expand let-bindings to increase their arity.
             </para>
-
-            <para>This option is a bit of a sledgehammer: it might sometimes
-            make things worse. Selectively unboxing fields by using
-            <literal>UNPACK</literal> pragmas might be better. An alternative
-            is to use <option>-funbox-strict-fields</option> to turn on
-            unboxing by default but disable it for certain constructor
-            fields using the <literal>NOUNPACK</literal> pragma (see
-            <xref linkend="nounpack-pragma"/>).</para>
           </listitem>
         </varlistentry>
 
         <varlistentry>
           <term>
-            <option>-fspec-constr</option>
-            <indexterm><primary><option>-fspec-constr</option></primary></indexterm>
+            <option>-fdo-eta-reduction</option>
+            <indexterm><primary><option></option></primary></indexterm>
           </term>
           <listitem>
-            <para><emphasis>Off by default, but enabled by -O2.</emphasis>
-            Turn on call-pattern specialisation; see
-            <ulink url="http://research.microsoft.com/en-us/um/people/simonpj/papers/spec-constr/index.htm">
-              Call-pattern specialisation for Haskell programs</ulink>.
-            </para>
-
-            <para>This optimisation specializes recursive functions according to
-            their argument "shapes". This is best explained by example so
-            consider:
-<programlisting>
-last :: [a] -> a
-last [] = error "last"
-last (x : []) = x
-last (x : xs) = last xs
-</programlisting>
-            In this code, once we pass the initial check for an empty list we
-            know that in the recursive case this pattern match is redundant. As
-            such <option>-fspec-constr</option> will transform the above code
-            to:
-<programlisting>
-last :: [a] -> a
-last []       = error "last"
-last (x : xs) = last' x xs
-    where
-      last' x []       = x
-      last' x (y : ys) = last' y ys
-</programlisting>
+            <para><emphasis>On by default.</emphasis>
+            Eta-reduce lambda expressions, if doing so gets rid of a whole
+            group of lambdas.
             </para>
+          </listitem>
+        </varlistentry>
 
-            <para>As well avoid unnecessary pattern matching it also helps avoid
-            unnecessary allocation. This applies when a argument is strict in
-            the recursive call to itself but not on the initial entry. As
-            strict recursive branch of the function is created similar to the
-            above example.
+        <varlistentry>
+          <term>
+            <option>-feager-blackholing</option>
+            <indexterm><primary><option></option></primary></indexterm>
+          </term>
+          <listitem>
+            <para>Usually GHC black-holes a thunk only when it switches
+            threads. This flag makes it do so as soon as the thunk is
+            entered. See <ulink url="http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/">
+              Haskell on a shared-memory multiprocessor</ulink>.
             </para>
           </listitem>
         </varlistentry>
 
         <varlistentry>
           <term>
-            <option>-fspecialise</option>
-            <indexterm><primary><option>-fspecialise</option></primary></indexterm>
+            <option>-fexcess-precision</option>
+            <indexterm><primary><option>-fexcess-precision</option></primary></indexterm>
           </term>
           <listitem>
-            <para><emphasis>On by default.</emphasis>
-            Specialise each type-class-overloaded function defined in this
-            module for the types at which it is called in this module.  Also
-            specialise imported functions that have an INLINABLE pragma
-            (<xref linkend="inlinable-pragma"/>) for the types at which they
-            are called in this module.
+            <para>When this option is given, intermediate floating
+            point values can have a <emphasis>greater</emphasis>
+            precision/range than the final type.  Generally this is a
+            good thing, but some programs may rely on the exact
+            precision/range of
+            <literal>Float</literal>/<literal>Double</literal> values
+            and should not use this option for their compilation.</para>
+
+            <para>
+              Note that the 32-bit x86 native code generator only
+              supports excess-precision mode, so neither
+              <option>-fexcess-precision</option> nor
+              <option>-fno-excess-precision</option> has any effect.
+              This is a known bug, see <xref linkend="bugs-ghc" />.
             </para>
           </listitem>
         </varlistentry>
 
         <varlistentry>
           <term>
-            <option>-fstatic-argument-transformation</option>
-            <indexterm><primary><option>-fstatic-argument-transformation</option></primary></indexterm>
+            <option>-fexpose-all-unfoldings</option>
+            <indexterm><primary><option></option></primary></indexterm>
           </term>
           <listitem>
-            <para>Turn on the static argument transformation, which turns a
-            recursive function into a non-recursive one with a local
-            recursive loop. See Chapter 7 of
-            <ulink url="http://research.microsoft.com/en-us/um/people/simonpj/papers/santos-thesis.ps.gz">
-              Andre Santos's PhD thesis</ulink>
+            <para>An experimental flag to expose all unfoldings, even for very
+            large or recursive functions. This allows for all functions to be
+            inlined while usually GHC would avoid inlining larger functions.
             </para>
           </listitem>
         </varlistentry>
@@ -1984,55 +2157,65 @@
 
         <varlistentry>
           <term>
-            <option>-fdo-lambda-eta-expansion</option>
-            <indexterm><primary><option></option></primary></indexterm>
+            <option>-ffun-to-thunk</option>
+            <indexterm><primary><option>-ffun-to-thunk</option></primary></indexterm>
           </term>
           <listitem>
-            <para><emphasis>On by default.</emphasis>
-            Eta-expand let-bindings to increase their arity.
+            <para>Worker-wrapper removes unused arguments, but usually we do
+            not remove them all, lest it turn a function closure into a thunk,
+            thereby perhaps creating a space leak and/or disrupting inlining.
+            This flag allows worker/wrapper to remove <emphasis>all</emphasis>
+            value lambdas.  Off by default.
             </para>
           </listitem>
         </varlistentry>
 
         <varlistentry>
           <term>
-            <option>-fdo-eta-reduction</option>
-            <indexterm><primary><option></option></primary></indexterm>
+            <option>-fignore-asserts</option>
+            <indexterm><primary><option>-fignore-asserts</option></primary></indexterm>
           </term>
           <listitem>
-            <para><emphasis>On by default.</emphasis>
-            Eta-reduce lambda expressions, if doing so gets rid of a whole
-            group of lambdas.
+            <para>Causes GHC to ignore uses of the function
+            <literal>Exception.assert</literal> in source code (in
+            other words, rewriting <literal>Exception.assert p
+            e</literal> to <literal>e</literal> (see <xref
+            linkend="assertions"/>).  This flag is turned on by
+            <option>-O</option>.
             </para>
           </listitem>
         </varlistentry>
 
         <varlistentry>
           <term>
-            <option>-fcase-merge</option>
-            <indexterm><primary><option></option></primary></indexterm>
+            <option>-fignore-interface-pragmas</option>
+            <indexterm><primary><option>-fignore-interface-pragmas</option></primary></indexterm>
           </term>
           <listitem>
-            <para><emphasis>On by default.</emphasis> 
-            Merge immediately-nested case expressions that scrutinse the same variable. Example
-<programlisting>
-  case x of
-     Red -> e1
-     _   -> case x of 
-              Blue -> e2
-              Green -> e3
-==>
-  case x of
-     Red -> e1
-     Blue -> e2
-     Green -> e2
-</programlisting>
-            </para>
+            <para>Tells GHC to ignore all inessential information when reading interface files.
+            That is, even if <filename>M.hi</filename> contains unfolding or strictness information
+            for a function, GHC will ignore that information.</para>
           </listitem>
         </varlistentry>
 
         <varlistentry>
           <term>
+            <option>-flate-dmd-anal</option>
+            <indexterm><primary><option>-flate-dmd-anal</option></primary></indexterm>
+          </term>
+          <listitem>
+            <para><emphasis>Off by default.</emphasis>Run demand analysis
+            again, at the end of the simplification pipeline.  We found some opportunities
+            for discovering strictness that were not visible earlier; and optimisations like
+            <literal>-fspec-constr</literal> can create functions with unused arguments which
+            are eliminated by late demand analysis.  Improvements are modest, but so is the
+            cost.  See notes on the <ulink href="http://ghc.haskell.org/trac/ghc/wiki/LateDmd">Trac wiki page</ulink>.
+            </para>
+            </listitem>
+        </varlistentry>
+
+        <varlistentry>
+          <term>
             <option>-fliberate-case</option>
             <indexterm><primary><option>-fliberate-case</option></primary></indexterm>
           </term>
@@ -2049,26 +2232,27 @@
 
         <varlistentry>
           <term>
-            <option>-fdicts-cheap</option>
-            <indexterm><primary><option></option></primary></indexterm>
+            <option>-fliberate-case-threshold=N</option>
+            <indexterm><primary><option>-fliberate-case-threshold</option></primary></indexterm>
           </term>
           <listitem>
-            <para>A very experimental flag that makes dictionary-valued
-            expressions seem cheap to the optimiser.
+            <para>Set the size threshold for the liberate-case transformation.
             </para>
           </listitem>
         </varlistentry>
 
         <varlistentry>
           <term>
-            <option>-feager-blackholing</option>
-            <indexterm><primary><option></option></primary></indexterm>
+            <option>-fmax-relevant-bindings=N</option>
+            <indexterm><primary><option>-fmax-relevant-bindings</option></primary></indexterm>
           </term>
           <listitem>
-            <para>Usually GHC black-holes a thunk only when it switches
-            threads. This flag makes it do so as soon as the thunk is
-            entered. See <ulink url="http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/">
-              Haskell on a shared-memory multiprocessor</ulink>.
+            <para>The type checker sometimes displays a fragment of the type environment
+                  in error messages, but only up to some maximum number, set by this flag.
+                  The default is 6.  Turning it off with <option>-fno-max-relevant-bindings</option> 
+                   gives an unlimited number. Syntactically top-level bindings are also 
+                   usually excluded (since they may be numerous), but 
+                   <option>-fno-max-relevant-bindings</option> includes them too.
             </para>
           </listitem>
         </varlistentry>
@@ -2090,6 +2274,42 @@
 
         <varlistentry>
           <term>
+            <option>-fomit-interface-pragmas</option>
+            <indexterm><primary><option>-fomit-interface-pragmas</option></primary></indexterm>
+          </term>
+          <listitem>
+            <para>Tells GHC to omit all inessential information from the
+            interface file generated for the module being compiled (say M).
+            This means that a module importing M will see only the
+            <emphasis>types</emphasis> of the functions that M exports, but
+            not their unfoldings, strictness info, etc.  Hence, for example,
+            no function exported by M will be inlined into an importing module.
+            The benefit is that modules that import M will need to be
+            recompiled less often (only when M's exports change their type, not
+            when they change their implementation).</para>
+          </listitem>
+        </varlistentry>
+
+        <varlistentry>
+          <term>
+            <option>-fomit-yields</option>
+            <indexterm><primary><option>-fomit-yields</option></primary></indexterm>
+          </term>
+          <listitem>
+              <para><emphasis>On by default.</emphasis>  Tells GHC to omit
+            heap checks when no allocation is being performed.  While this improves
+            binary sizes by about 5%, it also means that threads run in
+            tight non-allocating loops will not get preempted in a timely
+            fashion.  If it is important to always be able to interrupt such
+            threads, you should turn this optimization off.  Consider also
+            recompiling all libraries with this optimization turned off, if you
+            need to guarantee interruptibility.
+            </para>
+          </listitem>
+        </varlistentry>
+
+        <varlistentry>
+          <term>
             <option>-fpedantic-bottoms</option>
             <indexterm><primary><option>-fpedantic-bottoms</option></primary></indexterm>
           </term>
@@ -2105,6 +2325,38 @@
 
         <varlistentry>
           <term>
+            <option>-fregs-graph</option>
+            <indexterm><primary><option></option></primary></indexterm>
+          </term>
+          <listitem>
+            <para><emphasis>Off by default, but enabled by -O2. Only applies in
+              combination with the native code generator.</emphasis>
+            Use the graph colouring register allocator for register allocation
+            in the native code generator. By default, GHC uses a simpler,
+            faster linear register allocator. The downside being that the
+            linear register allocator usually generates worse code.
+            </para>
+          </listitem>
+        </varlistentry>
+
+        <varlistentry>
+          <term>
+            <option>-fregs-iterative</option>
+            <indexterm><primary><option></option></primary></indexterm>
+          </term>
+          <listitem>
+            <para><emphasis>Off by default, only applies in combination with
+              the native code generator.</emphasis>
+            Use the iterative coalescing graph colouring register allocator for
+            register allocation in the native code generator. This is the same
+            register allocator as the <option>-freg-graph</option> one but also
+            enables iterative coalescing during register allocation.
+            </para>
+          </listitem>
+        </varlistentry>
+
+        <varlistentry>
+          <term>
             <option>-fsimpl-tick-factor=<replaceable>n</replaceable></option>
             <indexterm><primary><option>-fsimpl-tick-factor</option></primary></indexterm>
           </term>
@@ -2186,140 +2438,227 @@
 
         <varlistentry>
           <term>
-            <option>-fexpose-all-unfoldings</option>
+            <option>-fvectorise</option>
             <indexterm><primary><option></option></primary></indexterm>
           </term>
           <listitem>
-            <para>An experimental flag to expose all unfoldings, even for very
-            large or recursive functions. This allows for all functions to be
-            inlined while usually GHC would avoid inlining larger functions.
-            </para>
+            <para>Part of <link linkend="dph">Data Parallel Haskell
+            (DPH)</link>.</para>
+
+            <para><emphasis>Off by default.</emphasis> Enable the
+            <emphasis>vectorisation</emphasis> optimisation transformation. This
+            optimisation transforms the nested data parallelism code of programs
+            using DPH into flat data parallelism. Flat data parallel programs
+            should have better load balancing, enable SIMD parallelism and
+            friendlier cache behaviour.</para>
           </listitem>
         </varlistentry>
 
         <varlistentry>
           <term>
-            <option>-fvectorise</option>
-            <indexterm><primary><option></option></primary></indexterm>
+            <option>-fspec-constr</option>
+            <indexterm><primary><option>-fspec-constr</option></primary></indexterm>
           </term>
           <listitem>
-            <para>Data Parallel Haskell.
+            <para><emphasis>Off by default, but enabled by -O2.</emphasis>
+            Turn on call-pattern specialisation; see
+            <ulink url="http://research.microsoft.com/en-us/um/people/simonpj/papers/spec-constr/index.htm">
+              Call-pattern specialisation for Haskell programs</ulink>.
             </para>
-            TODO: Document optimisation
-          </listitem>
-        </varlistentry>
 
-        <varlistentry>
-          <term>
-            <option>-favoid-vect</option>
-            <indexterm><primary><option></option></primary></indexterm>
-          </term>
-          <listitem>
-            <para>Data Parallel Haskell.
+            <para>This optimisation specializes recursive functions according to
+            their argument "shapes". This is best explained by example so
+            consider:
+<programlisting>
+last :: [a] -> a
+last [] = error "last"
+last (x : []) = x
+last (x : xs) = last xs
+</programlisting>
+            In this code, once we pass the initial check for an empty list we
+            know that in the recursive case this pattern match is redundant. As
+            such <option>-fspec-constr</option> will transform the above code
+            to:
+<programlisting>
+last :: [a] -> a
+last []       = error "last"
+last (x : xs) = last' x xs
+    where
+      last' x []       = x
+      last' x (y : ys) = last' y ys
+</programlisting>
             </para>
-            TODO: Document optimisation
+
+            <para>As well avoid unnecessary pattern matching it also helps avoid
+            unnecessary allocation. This applies when a argument is strict in
+            the recursive call to itself but not on the initial entry. As
+            strict recursive branch of the function is created similar to the
+            above example.
+            </para>
+
+            <para>It is also possible for library writers to instruct
+            GHC to perform call-pattern specialisation extremely
+            aggressively. This is necessary for some highly optimized
+            libraries, where we may want to specialize regardless of
+            the number of specialisations, or the size of the code. As
+            an example, consider a simplified use-case from the
+            <literal>vector</literal> library:</para>
+<programlisting>
+import GHC.Types (SPEC(..))
+
+foldl :: (a -> b -> a) -> a -> Stream b -> a
+{-# INLINE foldl #-}
+foldl f z (Stream step s _) = foldl_loop SPEC z s
+  where
+    foldl_loop !sPEC z s = case step s of
+                            Yield x s' -> foldl_loop sPEC (f z x) s'
+                            Skip       -> foldl_loop sPEC z s'
+                            Done       -> z
+</programlisting>
+
+            <para>Here, after GHC inlines the body of
+            <literal>foldl</literal> to a call site, it will perform
+            call-pattern specialization very aggressively on
+            <literal>foldl_loop</literal> due to the use of
+            <literal>SPEC</literal> in the argument of the loop
+            body. <literal>SPEC</literal> from
+            <literal>GHC.Types</literal> is specifically recognized by
+            the compiler.</para>
+
+            <para>(NB: it is extremely important you use
+            <literal>seq</literal> or a bang pattern on the
+            <literal>SPEC</literal> argument!)</para>
+
+            <para>In particular, after inlining this will
+            expose <literal>f</literal> to the loop body directly,
+            allowing heavy specialisation over the recursive
+            cases.</para>
           </listitem>
         </varlistentry>
 
         <varlistentry>
           <term>
-            <option>-fregs-graph</option>
-            <indexterm><primary><option></option></primary></indexterm>
+            <option>-fspecialise</option>
+            <indexterm><primary><option>-fspecialise</option></primary></indexterm>
           </term>
           <listitem>
-            <para><emphasis>Off by default, but enabled by -O2. Only applies in
-              combination with the native code generator.</emphasis>
-            Use the graph colouring register allocator for register allocation
-            in the native code generator. By default, GHC uses a simpler,
-            faster linear register allocator. The downside being that the
-            linear register allocator usually generates worse code.
+            <para><emphasis>On by default.</emphasis>
+            Specialise each type-class-overloaded function defined in this
+            module for the types at which it is called in this module.  Also
+            specialise imported functions that have an INLINABLE pragma
+            (<xref linkend="inlinable-pragma"/>) for the types at which they
+            are called in this module.
             </para>
           </listitem>
         </varlistentry>
 
         <varlistentry>
           <term>
-            <option>-fregs-iterative</option>
-            <indexterm><primary><option></option></primary></indexterm>
+            <option>-fstatic-argument-transformation</option>
+            <indexterm><primary><option>-fstatic-argument-transformation</option></primary></indexterm>
           </term>
           <listitem>
-            <para><emphasis>Off by default, only applies in combination with
-              the native code generator.</emphasis>
-            Use the iterative coalescing graph colouring register allocator for
-            register allocation in the native code generator. This is the same
-            register allocator as the <option>-freg-graph</option> one but also
-            enables iterative coalescing during register allocation.
+            <para>Turn on the static argument transformation, which turns a
+            recursive function into a non-recursive one with a local
+            recursive loop. See Chapter 7 of
+            <ulink url="http://research.microsoft.com/en-us/um/people/simonpj/papers/santos-thesis.ps.gz">
+              Andre Santos's PhD thesis</ulink>
             </para>
           </listitem>
         </varlistentry>
 
         <varlistentry>
           <term>
-            <option>-fexcess-precision</option>
-            <indexterm><primary><option>-fexcess-precision</option></primary></indexterm>
+            <option>-fstrictness</option>
+            <indexterm><primary><option></option></primary></indexterm>
           </term>
           <listitem>
-            <para>When this option is given, intermediate floating
-            point values can have a <emphasis>greater</emphasis>
-            precision/range than the final type.  Generally this is a
-            good thing, but some programs may rely on the exact
-            precision/range of
-            <literal>Float</literal>/<literal>Double</literal> values
-            and should not use this option for their compilation.</para>
+            <para> <emphasis>On by default.</emphasis>.  
+            Switch on the strictness analyser. There is a very old paper about GHC's 
+            strictness analyser, <ulink url="http://research.microsoft.com/en-us/um/people/simonpj/papers/simple-strictnes-analyser.ps.gz">
+              Measuring the effectiveness of a simple strictness analyser</ulink>,
+            but the current one is quite a bit different.
+            </para>
 
-            <para>
-              Note that the 32-bit x86 native code generator only
-              supports excess-precision mode, so neither
-              <option>-fexcess-precision</option> nor
-              <option>-fno-excess-precision</option> has any effect.
-              This is a known bug, see <xref linkend="bugs-ghc" />.
+            <para>The strictness analyser figures out when arguments and
+            variables in a function can be treated 'strictly' (that is they
+            are always evaluated in the function at some point). This allow
+            GHC to apply certain optimisations such as unboxing that
+            otherwise don't apply as they change the semantics of the program
+            when applied to lazy arguments.
             </para>
           </listitem>
         </varlistentry>
 
         <varlistentry>
           <term>
-            <option>-fignore-asserts</option>
-            <indexterm><primary><option>-fignore-asserts</option></primary></indexterm>
+            <option>-funbox-strict-fields</option>:
+            <indexterm><primary><option>-funbox-strict-fields</option></primary></indexterm>
+            <indexterm><primary>strict constructor fields</primary></indexterm>
+            <indexterm><primary>constructor fields, strict</primary></indexterm>
           </term>
           <listitem>
-            <para>Causes GHC to ignore uses of the function
-            <literal>Exception.assert</literal> in source code (in
-            other words, rewriting <literal>Exception.assert p
-            e</literal> to <literal>e</literal> (see <xref
-            linkend="assertions"/>).  This flag is turned on by
-            <option>-O</option>.
+            <para>This option causes all constructor fields which are marked
+            strict (i.e. &ldquo;!&rdquo;) to be unpacked if possible. It is
+            equivalent to adding an <literal>UNPACK</literal> pragma to every
+            strict constructor field (see <xref linkend="unpack-pragma"/>).
             </para>
-          </listitem>
-        </varlistentry>
 
-        <varlistentry>
-          <term>
-            <option>-fignore-interface-pragmas</option>
-            <indexterm><primary><option>-fignore-interface-pragmas</option></primary></indexterm>
-          </term>
-          <listitem>
-            <para>Tells GHC to ignore all inessential information when reading interface files.
-            That is, even if <filename>M.hi</filename> contains unfolding or strictness information
-            for a function, GHC will ignore that information.</para>
+            <para>This option is a bit of a sledgehammer: it might sometimes
+            make things worse. Selectively unboxing fields by using
+            <literal>UNPACK</literal> pragmas might be better. An alternative
+            is to use <option>-funbox-strict-fields</option> to turn on
+            unboxing by default but disable it for certain constructor
+            fields using the <literal>NOUNPACK</literal> pragma (see
+            <xref linkend="nounpack-pragma"/>).</para>
           </listitem>
         </varlistentry>
 
         <varlistentry>
           <term>
-            <option>-fomit-interface-pragmas</option>
-            <indexterm><primary><option>-fomit-interface-pragmas</option></primary></indexterm>
+            <option>-funbox-small-strict-fields</option>:
+            <indexterm><primary><option>-funbox-small-strict-fields</option></primary></indexterm>
+            <indexterm><primary>strict constructor fields</primary></indexterm>
+            <indexterm><primary>constructor fields, strict</primary></indexterm>
           </term>
           <listitem>
-            <para>Tells GHC to omit all inessential information from the
-            interface file generated for the module being compiled (say M).
-            This means that a module importing M will see only the
-            <emphasis>types</emphasis> of the functions that M exports, but
-            not their unfoldings, strictness info, etc.  Hence, for example,
-            no function exported by M will be inlined into an importing module.
-            The benefit is that modules that import M will need to be
-            recompiled less often (only when M's exports change their type, not
-            when they change their implementation).</para>
+            <para><emphasis>On by default.</emphasis>. This option
+            causes all constructor fields which are marked strict
+            (i.e. &ldquo;!&rdquo;) and which representation is smaller
+            or equal to the size of a pointer to be unpacked, if
+            possible. It is equivalent to adding an
+            <literal>UNPACK</literal> pragma (see <xref
+            linkend="unpack-pragma"/>) to every strict constructor
+            field that fulfils the size restriction.
+            </para>
+
+            <para>For example, the constructor fields in the following
+            data types
+<programlisting>
+data A = A !Int
+data B = B !A
+newtype C = C B
+data D = D !C
+</programlisting>
+            would all be represented by a single
+            <literal>Int#</literal> (see <xref linkend="primitives"/>)
+            value with
+            <option>-funbox-small-strict-fields</option> enabled.
+            </para>
+
+            <para>This option is less of a sledgehammer than
+            <option>-funbox-strict-fields</option>: it should rarely make things
+            worse. If you use <option>-funbox-small-strict-fields</option>
+            to turn on unboxing by default you can disable it for certain
+            constructor fields using the <literal>NOUNPACK</literal> pragma (see
+            <xref linkend="nounpack-pragma"/>).</para>
+
+            <para>
+            Note that for consistency <literal>Double</literal>,
+            <literal>Word64</literal>, and <literal>Int64</literal> constructor
+            fields are unpacked on 32-bit platforms, even though they are
+            technically larger than a pointer on those platforms.
+            </para>
           </listitem>
         </varlistentry>
 
diff -urd 7.6.3-original/what_glasgow_exts_does.gen.xml original/what_glasgow_exts_does.gen.xml
--- 7.6.3-original/what_glasgow_exts_does.gen.xml	2014-06-27 09:19:05.984243713 +0900
+++ original/what_glasgow_exts_does.gen.xml	2014-06-27 09:59:33.682802308 +0900
@@ -16,7 +16,6 @@
 <option>-XMultiParamTypeClasses</option>,
 <option>-XFunctionalDependencies</option>,
 <option>-XMagicHash</option>,
-<option>-XPolymorphicComponents</option>,
 <option>-XExistentialQuantification</option>,
 <option>-XUnicodeSyntax</option>,
 <option>-XPostfixOperators</option>,
