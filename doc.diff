diff -urd 7.2.2-original/separate_compilation.xml original/separate_compilation.xml
--- 7.2.2-original/separate_compilation.xml	2011-11-10 02:10:39.000000000 +0800
+++ original/separate_compilation.xml	2012-02-02 02:10:32.000000000 +0800
@@ -374,6 +374,19 @@
 	  </listitem>
 	</varlistentry>
 
+	<varlistentry>
+	  <term>
+            <option>-dumpdir</option>  <replaceable>dir</replaceable>
+            <indexterm><primary><option>-dumpdir</option></primary></indexterm>
+          </term>
+	  <listitem>
+	    <para>Redirects all dump files into
+	    <replaceable>dir</replaceable>.  Dump files are generated when
+	    <literal>-ddump-to-file</literal> is used with other
+	    <literal>-ddump-*</literal> flags.</para>
+	  </listitem>
+	</varlistentry>
+
         <varlistentry>
           <term>
             <option>-outputdir</option> <replaceable>dir</replaceable>
@@ -383,7 +396,7 @@
             <para>The <option>-outputdir</option> option is shorthand for
               the combination
               of <option>-odir</option>, <option>-hidir</option>,
-              and <option>-stubdir</option>.
+              <option>-stubdir</option> and <option>-dumpdir</option>.
             </para>
           </listitem>
         </varlistentry>
@@ -460,8 +473,9 @@
 	  <listitem>
 	    <para>Keep intermediate <literal>.hc</literal> files when
 	    doing <literal>.hs</literal>-to-<literal>.o</literal>
-	    compilations via C (NOTE: <literal>.hc</literal> files
-	    are only generated by unregisterised compilers).</para>
+      compilations via <link linkend="c-code-gen">C</link> (NOTE:
+      <literal>.hc</literal> files are only generated by
+      <link linkend="unreg">unregisterised</link> compilers).</para>
 	  </listitem>
 	</varlistentry>
 
@@ -475,10 +489,10 @@
 	  <listitem>
 	    <para>Keep intermediate <literal>.ll</literal> files when
 	    doing <literal>.hs</literal>-to-<literal>.o</literal>
-	    compilations via LLVM (NOTE: <literal>.ll</literal> files
-	    aren't generated when using the native code generator, you
-	    may need to use <option>-fllvm</option> to force them
-	    to be produced).</para>
+      compilations via <link linkend="llvm-code-gen">LLVM</link>
+      (NOTE: <literal>.ll</literal> files aren't generated when using the
+      native code generator, you may need to use <option>-fllvm</option> to
+      force them to be produced).</para>
 	  </listitem>
 	</varlistentry>
 
diff -urd 7.2.2-original/sooner.xml original/sooner.xml
--- 7.2.2-original/sooner.xml	2011-11-10 02:10:39.000000000 +0800
+++ original/sooner.xml	2012-02-02 02:10:32.000000000 +0800
@@ -154,11 +154,15 @@
       <varlistentry>
 	<term>Compile via LLVM:</term>
 	<listitem>
-		<para>The LLVM code generator can sometimes do a far better job
-			    at producing fast code then either the native code generator
-					or the C code generator. This is not universal and depends
-					on the code. Numeric heavy code seems to show the best
-					improvement when compiled via LLVM.</para>
+		<para>The <link linkend="llvm-code-gen">LLVM code generator</link> can
+			sometimes do a far better job at producing fast code than the <link
+				linkend="native-code-gen">native code generator</link>. This is not
+			universal and depends on the code. Numeric heavy code seems to show
+			the best improvement when compiled via LLVM. You can also experiment
+			with passing specific flags to LLVM with the <option>-optlo</option>
+			and <option>-optlc</option> flags.  Be careful though as setting these
+			flags stops GHC from setting its usual flags for the LLVM optimiser
+			and compiler.</para>
 	</listitem>
       </varlistentry>
 
diff -urd 7.2.2-original/ug-book.xml original/ug-book.xml
--- 7.2.2-original/ug-book.xml	2011-11-29 17:45:28.000000000 +0800
+++ original/ug-book.xml	2012-02-03 18:09:44.000000000 +0800
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="iso-8859-1"?>
 <bookinfo>
-<title>The Glorious Glasgow Haskell Compilation System User's Guide, Version 7.2.2</title>
+<title>The Glorious Glasgow Haskell Compilation System User's Guide, Version 7.4.1</title>
 <author><othername>The GHC Team</othername></author>
 <address>
 <email>glasgow-haskell-&lcub;bugs,users&rcub;-request@haskell.org</email>
diff -urd 7.2.2-original/ug-ent.xml original/ug-ent.xml
--- 7.2.2-original/ug-ent.xml	2011-11-29 17:45:28.000000000 +0800
+++ original/ug-ent.xml	2012-02-03 18:09:44.000000000 +0800
@@ -25,6 +27,6 @@
 <!ENTITY ffi-chap       SYSTEM "ffi-chap.xml">
 <!ENTITY shared_libs    SYSTEM "shared_libs.xml">
 <!ENTITY what_glasgow_exts_does SYSTEM "what_glasgow_exts_does.gen.xml">
-<!ENTITY libraryBaseLocation    "../libraries/base-4.4.1.0">
-<!ENTITY libraryCabalLocation   "../libraries/Cabal-1.12.0">
+<!ENTITY libraryBaseLocation    "../libraries/base-4.5.0.0">
+<!ENTITY libraryCabalLocation   "../libraries/Cabal-1.14.0">
 <!ENTITY libraryGhcPrimLocation "../libraries/ghc-prim-0.2.0.0">
diff -urd 7.2.2-original/ug-ent.xml.in original/ug-ent.xml.in
--- 7.2.2-original/ug-ent.xml.in	2011-11-10 02:10:39.000000000 +0800
+++ original/ug-ent.xml.in	2012-02-02 02:10:32.000000000 +0800
@@ -3,9 +3,11 @@
 <!ENTITY flags          SYSTEM "flags.xml">
 <!ENTITY license        SYSTEM "license.xml">
 <!ENTITY intro          SYSTEM "intro.xml" >
-<!ENTITY relnotes1      SYSTEM "7.2.1-notes.xml" >
-<!ENTITY relnotes2      SYSTEM "7.2.2-notes.xml" >
+<!ENTITY oldrelnotes1   SYSTEM "7.2.1-notes.xml" >
+<!ENTITY oldrelnotes2   SYSTEM "7.2.2-notes.xml" >
+<!ENTITY relnotes1      SYSTEM "7.4.1-notes.xml" >
 <!ENTITY using          SYSTEM "using.xml" >
+<!ENTITY code-gens      SYSTEM "codegens.xml" >
 <!ENTITY runtime        SYSTEM "runtime_control.xml" >
 <!ENTITY prof           SYSTEM "profiling.xml" >
 <!ENTITY debug          SYSTEM "debugging.xml" >
diff -urd 7.2.2-original/using.xml original/using.xml
--- 7.2.2-original/using.xml	2011-11-10 02:10:39.000000000 +0800
+++ original/using.xml	2012-02-02 02:10:32.000000000 +0800
@@ -731,11 +731,9 @@
       <filename>Foo.hs</filename> to an object file
       <filename>Foo.o</filename>.</para>
 
-      <para>Note: What the Haskell compiler proper produces depends on
-      whether a native-code generator<indexterm><primary>native-code
-      generator</primary></indexterm> is used (producing assembly
-      language) or not (producing C).  See <xref
-      linkend="options-codegen"/> for more details.</para>
+      <para>Note: What the Haskell compiler proper produces depends on what
+      backend code generator is used. See <xref linkend="code-generators"/>
+      for more details.</para>
 
       <para>Note: C pre-processing is optional, the
       <option>-cpp</option><indexterm><primary><option>-cpp</option></primary></indexterm>
@@ -1755,6 +1753,28 @@
 
 	<varlistentry>
 	  <term>
+            <option>-fignore-interface-pragmas</option>
+	    <indexterm><primary><option>-fignore-interface-pragmas</option></primary></indexterm>
+          </term>
+	  <listitem>
+	    <para>Tells GHC to ignore all inessential information when reading interface files.
+	    That is, even if <filename>M.hi</filename> contains unfolding or strictness information
+	    for a function, GHC will ignore that information.</para>
+	  </listitem>
+	</varlistentry>
+
+	<varlistentry>
+	  <term>
+            <option>-fliberate-case</option>
+            <indexterm><primary><option>-fliberate-case</option></primary></indexterm>
+          </term>
+	  <listitem>
+	    <para>Turn on the liberate-case transformation.</para>
+	  </listitem>
+	</varlistentry>
+
+	<varlistentry>
+	  <term>
             <option>-fno-cse</option>
             <indexterm><primary><option>-fno-cse</option></primary></indexterm>
           </term>
@@ -1820,75 +1840,89 @@
 
 	<varlistentry>
 	  <term>
-            <option>-fspec-constr</option>
-            <indexterm><primary><option>-fspec-constr</option></primary></indexterm>
+            <option>-fno-state-hack</option>
+            <indexterm><primary><option>-fno-state-hack</option></primary></indexterm>
           </term>
 	  <listitem>
-	    <para>Turn on call-pattern specialisation.</para>
+	    <para>Turn off the "state hack" whereby any lambda with a
+	      <literal>State#</literal> token as argument is considered to be
+	      single-entry, hence it is considered OK to inline things inside
+	      it.  This can improve performance of IO and ST monad code, but it
+	    runs the risk of reducing sharing.</para>
 	  </listitem>
 	</varlistentry>
 
 	<varlistentry>
 	  <term>
-            <option>-fliberate-case</option>
-            <indexterm><primary><option>-fliberate-case</option></primary></indexterm>
+            <option>-fpedantic-bottoms</option>
+            <indexterm><primary><option>-fpedantic-bottoms</option></primary></indexterm>
           </term>
 	  <listitem>
-	    <para>Turn on the liberate-case transformation.</para>
+	    <para>Make GHC be more precise about its treatment of bottom (but see also
+                     <option>-fno-state-hack</option>). In particular, stop GHC 
+                     eta-expanding through a case expression, which is good for
+		     performance, but bad if you are using <literal>seq</literal> on
+                     partial applications.</para>
 	  </listitem>
 	</varlistentry>
 
 	<varlistentry>
 	  <term>
-            <option>-fstatic-argument-transformation</option>
-            <indexterm><primary><option>-fstatic-argument-transformation</option></primary></indexterm>
+            <option>-fomit-interface-pragmas</option>
+	    <indexterm><primary><option>-fomit-interface-pragmas</option></primary></indexterm>
           </term>
 	  <listitem>
-	    <para>Turn on the static argument transformation.</para>
+	    <para>Tells GHC to omit all inessential information from the interface file
+	      generated for the module being compiled (say M).  This means that a module
+	      importing M will see only the <emphasis>types</emphasis> of the functions that M exports, but not
+	      their unfoldings, strictness info, etc.  Hence, for example,
+	      no function exported by M will be inlined
+	      into an importing module.  The benefit is that modules that import M will
+	      need to be recompiled less often (only when M's exports change their type,
+	      not when they change their implementation).
+	      </para>
 	  </listitem>
 	</varlistentry>
 
 	<varlistentry>
 	  <term>
-            <option>-fno-state-hack</option>
-            <indexterm><primary><option>-fno-state-hack</option></primary></indexterm>
+            <option>-fsimpl-tick-factor=<replaceable>n</replaceable></option>
+            <indexterm><primary><option>-fsimpl-tick-factor</option></primary></indexterm>
           </term>
 	  <listitem>
-	    <para>Turn off the "state hack" whereby any lambda with a
-	      <literal>State#</literal> token as argument is considered to be
-	      single-entry, hence it is considered OK to inline things inside
-	      it.  This can improve performance of IO and ST monad code, but it
-	    runs the risk of reducing sharing.</para>
+	    <para>GHC's optimiser can diverge if you write rewrite rules (<xref linkend="rewrite-rules"/>) 
+              that don't terminate, or (less satisfactorily) if you
+              code up recursion through data types
+              (<xref linkend="bugs-ghc"/>).  To avoid making the compiler fall into an infinite
+	      loop, the optimiser carries a "tick count" and stops inlining and applying rewrite rules
+              when this count is exceeded.  The limit is set as a multiple of the program size, so 
+              bigger programs get more ticks. The <option>-fsimpl-tick-factor</option> flag lets
+              you change the multiplier. The default is 100; numbers larger than 100 give more ticks,
+              and numbers smaller than 100 give fewer.</para>
+            <para>If the tick-count expires, GHC summarises what simplifier steps it has done; 
+            you can use <option>-fddump-simpl-stats</option> to generate a much more detailed list.
+            Usually that identifies the loop quite accurately, because some numbers are very large.
+	      </para>
 	  </listitem>
 	</varlistentry>
 
 	<varlistentry>
 	  <term>
-            <option>-fomit-interface-pragmas</option>
-	    <indexterm><primary><option>-fomit-interface-pragmas</option></primary></indexterm>
+            <option>-fstatic-argument-transformation</option>
+            <indexterm><primary><option>-fstatic-argument-transformation</option></primary></indexterm>
           </term>
 	  <listitem>
-	    <para>Tells GHC to omit all inessential information from the interface file
-	      generated for the module being compiled (say M).  This means that a module
-	      importing M will see only the <emphasis>types</emphasis> of the functions that M exports, but not
-	      their unfoldings, strictness info, etc.  Hence, for example,
-	      no function exported by M will be inlined
-	      into an importing module.  The benefit is that modules that import M will
-	      need to be recompiled less often (only when M's exports change their type,
-	      not when they change their implementation).
-	      </para>
+	    <para>Turn on the static argument transformation.</para>
 	  </listitem>
 	</varlistentry>
 
 	<varlistentry>
 	  <term>
-            <option>-fignore-interface-pragmas</option>
-	    <indexterm><primary><option>-fignore-interface-pragmas</option></primary></indexterm>
+            <option>-fspec-constr</option>
+            <indexterm><primary><option>-fspec-constr</option></primary></indexterm>
           </term>
 	  <listitem>
-	    <para>Tells GHC to ignore all inessential information when reading interface files.
-	    That is, even if <filename>M.hi</filename> contains unfolding or strictness information
-	    for a function, GHC will ignore that information.</para>
+	    <para>Turn on call-pattern specialisation.</para>
 	  </listitem>
 	</varlistentry>
 
@@ -1910,7 +1944,12 @@
 	    <para>This option is a bit of a sledgehammer: it might
 	    sometimes make things worse.  Selectively unboxing fields
 	    by using <literal>UNPACK</literal> pragmas might be
-	    better.</para>
+	    better. An alternative is to use
+        <option>-funbox-strict-fields</option> to turn on
+        unboxing by default but disable it for certain constructor
+        fields using the <literal>NOUNPACK</literal> pragma
+        (see <xref linkend="nounpack-pragma"/>).
+        </para>
 	  </listitem>
 	</varlistentry>
 
@@ -1962,6 +2001,8 @@
 
   </sect1>
 
   &code-gens;
 
   &phases;
 
   &shared_libs;
@@ -2071,8 +2112,10 @@
     <sect2 id="parallel-options">
       <title>RTS options for SMP parallelism</title>
 
-      <para>To run a program on multiple CPUs, use the
-	RTS <option>-N</option> option:</para>
+      <para>There are two ways to run a program on multiple
+        processors:
+        call <literal>GHC.Conc.setNumCapabilities</literal> from your
+        program, or use the RTS <option>-N</option> option.</para>
 
       <variablelist>
 	<varlistentry>
@@ -2107,7 +2150,13 @@
 
             <para>The current value of the <option>-N</option> option
               is available to the Haskell program
-              via <literal>GHC.Conc.numCapabilities</literal>.</para>
+              via <literal>GHC.Conc.getNumCapabilities</literal>, and
+              it may be changed while the program is running by
+              calling <literal>GHC.Conc.setNumCapabilities</literal>.
+              Note: in the current implementation,
+              the <option>-N</option> value may only
+              be <emphasis>increased</emphasis>, not decreased, by
+              calling <literal>GHC.Conc.setNumCapabilities</literal>.</para>
 	  </listitem>
 	</varlistentry>
       </variablelist>
@@ -2191,19 +2240,38 @@
 	<term><option>-msse2</option>:</term>
 	<listitem>
           <para>
-            (x86 only, added in GHC 7.0.1) Use the SSE2 registers and
-            instruction set to implement floating point operations
-            when using the native code generator.  This gives a
-            substantial performance improvement for floating point,
-            but the resulting compiled code will only run on
-            processors that support SSE2 (Intel Pentium 4 and later,
-            or AMD Athlon 64 and later).
+				(x86 only, added in GHC 7.0.1) Use the SSE2 registers and
+				instruction set to implement floating point operations when using
+				the <link linkend="native-code-gen">native code generator</link>.
+				This gives a substantial performance improvement for floating
+				point, but the resulting compiled code
+				will only run on processors that support SSE2 (Intel Pentium 4 and
+				later, or AMD Athlon 64 and later). The
+				<link linkend="llvm-code-gen">LLVM backend</link> will also use SSE2
+				if your processor supports it but detects this automatically so no
+				flag is required.
           </para>
           <para>
             SSE2 is unconditionally used on x86-64 platforms.
           </para>
         </listitem>
       </varlistentry>
+
+      <varlistentry>
+	<term><option>-msse4.2</option>:</term>
+	<listitem>
+          <para>
+				(x86 only, added in GHC 7.4.1) Use the SSE4.2 instruction set to
+				implement some floating point and bit operations when using the
+				<link linkend="native-code-gen">native code generator</link>. The
+				resulting compiled code will only run on processors that
+				support SSE4.2 (Intel Core i7 and later). The
+				<link linkend="llvm-code-gen">LLVM backend</link> will also use
+				SSE4.2 if your processor supports it but detects this automatically
+				so no flag is required.
+          </para>
+        </listitem>
+      </varlistentry>
 
     </variablelist>
 
