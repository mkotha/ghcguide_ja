<?xml version="1.0" encoding="UTF-8"?>
  <sect1 id="packages">
 <title>
パッケージ
 </title>
  <indexterm><primary>packages</primary></indexterm>
 
  <para>パッケージとは、Haskellモジュールから成るライブラリで、コンパイラが把握している。GHCにはいくつかのパッケージが付属している。同梱の<ulink url="../libraries/index.html">ライブラリ説明書</ulink>(訳注: 未訳。<ulink url="http://www.haskell.org/ghc/docs/latest/html/libraries/index.html">web上の最新版</ulink>)を見よ。また、<ulink url="http://hackage.haskell.org/packages/hackage.html">HackageDB</ulink>から別のライブラリを入手してインストールすることができる。</para>

  <para>パッケージを使う手順はこの上なく単純である。<option>--make</option>やGHCiを使っているなら、インストール済みパッケージの大部分を余分なオプションなしでプログラムから使うことができる。例外は下記<xref linkend="using-packages"/>で説明されている。</para>

  <para>自分のパッケージをビルドするのもとても簡単な作業である。我々が提供する<ulink url="http://www.haskell.org/cabal">Cabal</ulink>インフラストラクチャがパッケージの設定、ビルド、インストール及び配布を自動化する。必要なのは、単純な設定ファイルを書き、いくつかのファイルを正しい場所に置くことだけである。詳細は<ulink url="../Cabal/index.html">Cabal説明書</ulink>(訳注: 未訳。<ulink url="http://www.haskell.org/ghc/docs/latest/html/Cabal/index.html">web上の最新版</ulink>)およびCabalライブラリ(例えば<ulink url="&libraryCabalLocation;/Distribution-Simple.html">Distribution.Simple</ulink>)を見よ。</para>

  <sect2 id="using-packages">
  <title>パッケージを使う
  </title>
    <indexterm><primary>packages</primary>
      <secondary>using</secondary></indexterm>
 
    <para>GHCは、<emphasis>インストール済み</emphasis>のパッケージしか関知しない。どんなパッケージがインストールされているか見るためには、<literal>ghc-pkg list</literal>コマンドを使えば良い。</para>

<screen>
$ ghc-pkg list
/usr/lib/ghc-6.12.1/package.conf.d:
    Cabal-1.7.4
    array-0.2.0.1
    base-3.0.3.0
    base-4.2.0.0
    bin-package-db-0.0.0.0
    binary-0.5.0.1
    bytestring-0.9.1.4
    containers-0.2.0.1
    directory-1.0.0.2
    (dph-base-0.4.0)
    (dph-par-0.4.0)
    (dph-prim-interface-0.4.0)
    (dph-prim-par-0.4.0)
    (dph-prim-seq-0.4.0)
    (dph-seq-0.4.0)
    extensible-exceptions-0.1.1.0
    ffi-1.0
    filepath-1.1.0.1
    (ghc-6.12.1)
    ghc-prim-0.1.0.0
    haskeline-0.6.2
    haskell98-1.0.1.0
    hpc-0.5.0.2
    integer-gmp-0.1.0.0
    mtl-1.1.0.2
    old-locale-1.0.0.1
    old-time-1.0.0.1
    pretty-1.0.1.0
    process-1.0.1.1
    random-1.0.0.1
    rts-1.0
    syb-0.1.0.0
    template-haskell-2.4.0.0
    terminfo-0.3.1
    time-1.1.4
    unix-2.3.1.0
    utf8-string-0.3.4
</screen>
    <para>インストールされているパッケージは、デフォルトで露出されているか隠されているかのいずれかである。デフォルトで隠されているパッケージは、<literal>ghc-pkg list</literal>の出力の中に括弧付きで(<literal>(lang-1.0)</literal>のように)現れるか、ターミナルが色付けに対応しているなら青で表示される。下記のコマンド行フラグを使えば、隠しパッケージを露出したり露出パッケージを隠したりできる。あなたのHaskellコードからインポートできるのは露出されているパッケージのモジュールだけである。隠しパッケージのモジュールをインポートしようとすると、GHCはエラーメッセージを出力する。</para>

    <para>参考: Cabalを使っているなら、パッケージが露出されているか隠されているかという区別は関係しない。どのパッケージが利用可能かは<literal>.cabal</literal>の指定に列挙されている依存関係から決定される。露出されているか隠されているかの区別は<literal>ghc</literal>や<literal>ghci</literal>を直接使うときのみ影響する。</para>

    <para>パッケージが隠されているかの状態と似たものに、パッケージが信用されているかどうかの区別がある。この性質は、<option>-fpackage-trust</option>フラグを有効にし、GHCのSafe Haskell機能(<xref linkend="safe-haskell"/>を見よ)を使ってコードをコンパイルする場合にのみ意味を持つ。</para>

    <para>あるパッケージがどんなモジュールを公開しているかを見るには、<literal>ghc-pkg</literal>コマンドを使う。(<xref linkend="package-management"/>を見よ)</para>
    
<screen>
$ ghc-pkg field network exposed-modules
exposed-modules: Network.BSD,
                 Network.CGI,
                 Network.Socket,
                 Network.URI,
                 Network
</screen>

    <para>パッケージ制御のためのコマンド行引数は以下の通りである。</para>

    <variablelist>
      <varlistentry>
        <term>
          <option>-package <replaceable>P</replaceable></option>
          <indexterm><primary><option>-package</option></primary></indexterm>
        </term>
        <listitem>
          <para>このオプションを与えると、インストール済みパッケージ<replaceable>P</replaceable>が露出される。パッケージ<replaceable>P</replaceable>はバージョン番号付きで完全な形で指定しても良いし(たとえば、<literal>network-1.0</literal>)、単一のバージョンしかインストールされていないならバージョン番号は省略しても良い。<replaceable>P</replaceable>の複数のバージョンがインストールされているなら、指定されたもの以外の全てのバージョンは隠される。</para>

          <para>さらに、<option>-package <replaceable>P</replaceable></option>オプションはパッケージ<replaceable>P</replaceable>が生成される実行ファイルや共有オブジェクトにリンクされるようにする。パッケージのライブラリが静的にリンクされるか動的にリンクされるかは<option>-static</option>/<option>-dynamic</option>の二つのフラグによって制御される。</para>

          <para><option>--make</option>モードと<option>--interactive</option>モード(<xref linkend="modes" />を見よ)では、通常、コンパイラはどのパッケージが現在のHaskellモジュール群から必要とされているかを判断し、それらだけをリンクする。一方、一括処理モードでは、依存性情報が利用できず、リンク時に<option>-package</option>を明示的に与えなければならない。他に<option>-package</option>を使ってパッケージのリンクを強制しなければならないのは、そのパッケージがHaskellモジュールを一つも含んでいない(たとえばCライブラリのみとか)場合である。その場合、GHCがそのパッケージへの依存を発見することはないので、明示的に言及する必要がある。</para>

          <para>例えば、<filename>Foo.o</filename>と<filename>Main.o</filename>の二つのオブジェクトから成るプログラムをリンクするとき、<literal>network</literal>パッケージを使っているなら、GHCに次のように<literal>-package</literal>フラグを渡す必要がある。

<screen>$ ghc -o myprog Foo.o Main.o -package network</screen>

            仮にソースからコンパイルしているとしても、同じフラグが必要である。これは、GHCが自分自身が一括処理モードで動いていると考えているからである。

<screen>$ ghc -o myprog Foo.hs Main.hs -package network</screen></para>
        </listitem>
      </varlistentry>
 
      <varlistentry>
        <term>
          <option>-package-id <replaceable>P</replaceable></option>
          <indexterm><primary><option>-package-id</option></primary></indexterm>
        </term>
        <listitem>
          <para><option>-package</option>のようにパッケージを露出するが、パッケージは名前ではなくIDで示される。これはパッケージを示す方法としてより頑健であり、通常なら(訳注: 同名パッケージに)覆い隠されてしまうパッケージを選択するのに用いることもできる。Cabalは<option>-package-id</option>フラグをGHCに渡す。
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><option>-hide-all-packages</option>
        <indexterm><primary><option>-hide-package</option></primary>
          </indexterm></term>
        <listitem>
          <para>インストール済みパッケージの露出フラグを無視し、それらをデフォルトで隠すようにする。このフラグを使うなら、必要なパッケージは(<literal>base</literal>も含めて)全て<option>-package</option>オプションで露出させる必要がある。</para>

          <para>これは、どんなパッケージが大域的に露出されているかにプログラムが依存しないようにするのに有効である。また、パッケージへの依存を明示的に述べることは良いことである。このような理由で、Cabalは常に<option>-hide-all-packages</option>フラグをGHCに渡す。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><option>-hide-package</option> <replaceable>P</replaceable>
        <indexterm><primary><option>-hide-package</option></primary>
          </indexterm></term>
        <listitem>
          <para>このオプションは<option>-package</option>の逆を行う。すなわち、指定されたパッケージを<firstterm>隠された</firstterm>状態にする。この状態では、そのパッケージのモジュールはHaskellの<literal>import</literal>指令でインポートすることができない。</para>
          
          <para>このオプションが指定されていても、このパッケージは最終的にプログラムにリンクされるかもしれない(別の露出パッケージが直接・間接にこのパッケージに依存しているかもしれないので)ことに注意せよ。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><option>-ignore-package</option> <replaceable>P</replaceable>
        <indexterm><primary><option>-ignore-package</option></primary>
          </indexterm></term>
        <listitem>
          <para>指定されると、コンパイラは、パッケージ<replaceable>P</replaceable>および<literal>P</literal>に依存する全てのパッケージが全くインストールされていないかのように振る舞う。</para>

          <para><literal>-igonore-package P</literal>と言うのは、<literal>P</literal>、及び<literal>P</literal>に依存する全てのパッケージについて<literal>-hide-package</literal>フラグを与えるのと同じである。<literal>P</literal>に依存するインストール済みパッケージがどれなのか前もって分からないことがあるが、そういうときに<literal>-ignore-package</literal>フラグが便利である。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><option>-no-auto-link-packages</option>
        <indexterm><primary><option>-no-auto-link-packages</option></primary>
          </indexterm></term>
        <listitem>
          <para>デフォルトでは、GHCは<literal>base</literal>および<literal>rts</literal>パッケージを自動的にリンクに組み入れる。このフラグはこの振る舞いを無効にする。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><option>-package-name <replaceable>foo</replaceable></option></term>
        <indexterm><primary><literal>-package-name</literal></primary>
          <secondary>option</secondary></indexterm>
        <listitem>
          <para>コンパイルしようとしているモジュールが、パッケージ<literal>foo</literal>の一員であることを、GHCに伝える。このフラグが省略される(とてもよくある場合である)と、デフォルトのパッケージである<literal>main</literal>と推定される。</para>

          <para>注意: <option>-package-name</option>の引数はそのパッケージの完全な<literal>パッケージ名-バージョン</literal>形式であるべきである。例えば、<literal>-package mypkg-1.2</literal>のように。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><option>-trust</option> <replaceable>P</replaceable>
        <indexterm><primary><option>-trust</option></primary>
          </indexterm></term>
        <listitem>
          <para>このオプションは、インストール済みパッケージ<replaceable>P</replaceable>を露出し、さらにGHCによって信用されるようにする。このコマンドは<option>-package</option>と非常に似た形で機能するが、追加の作用として、パッケージデータベースの内容にかかわらず、GHCが選択されたパッケージを信用するようにする。(<xref linkend="safe-haskell"/>を見よ)。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><option>-distrust</option> <replaceable>P</replaceable>
        <indexterm><primary><option>-distrust</option></primary>
          </indexterm></term>
        <listitem>
          <para>このオプションは、インストール済みパッケージ<replaceable>P</replaceable>を露出し、さらにGHCによって信用されないようにする。このコマンドは<option>-package</option>と非常に似た形で機能するが、追加の作用として、パッケージデータベースの内容にかかわらず、GHCが選択されたパッケージに信用を置かないようにする。(<xref linkend="safe-haskell"/>を見よ)。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><option>-distrust-all</option>
        <indexterm><primary><option>-distrust-all</option></primary>
          </indexterm></term>
        <listitem>
          <para>インストール済みパッケージ群の信用フラグを無視し、デフォルトで信用しないようにする。このフラグをSafe Haskellと共に使うなら、信用される必要があるパッケージは(<literal>base</literal>も含めて)<option>-trust</option>オプションを使って明示的に信用を与えられなければならない。このオプションはパッケージの隠し/露出状態を変えないので、システム中の全てのパッケージに<option>-distrust</option>を与えるのとは異なる。(<xref linkend="safe-haskell"/>を見よ)。</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </sect2>

  <sect2 id="package-main">
    <title>mainパッケージ</title>

  <para>完全なHaskellプログラムは全て、<literal>main</literal>パッケージの<literal>Main</literal>モジュールの<literal>main</literal>を定義せねばならない。(<option>-package-name</option>フラグを省略すると<literal>main</literal>パッケージ用のコードがコンパイルされる)。これを怠ると、やや不明瞭なリンク時エラーのメッセージが出る。
<programlisting>
/usr/bin/ld: Undefined symbols:
_ZCMain_main_closure
</programlisting>
</para>

  </sect2>

  <sect2 id="package-overlaps">
    <title>パッケージを使うことのHaskell言語への影響</title>

    <para>パッケージを使っていると、同じ名前の二つのモジュールができることがあり得る。例えば、あなたのプログラムがパッケージPを使っていて、Pには隠されたモジュールMがあり、さらにあなたのプログラムにもモジュールMがあるかもしれない。あるいは、利用している複数のパッケージの依存関係が重複したモジュールを含むかもしれない。パッケージの依存関係のせいで、あるプログラムが一つのパッケージの複数のバージョンを含むことさえあり得る。</para>

    <para>これらの状況は、それだけではエラーではないが、<footnote><para>GHC 6.4まではエラーだったが、6.6以降はそうではない。</para></footnote>興味深い結果を招くことがある。例として、パッケージ<literal>P</literal>のバージョン1に<literal>M.T</literal>という型があるとすると、これはパッケージ<literal>P</literal>のバージョン2由来の<literal>M.T</literal>と同じ型では<emphasis>ない</emphasis>。一方が必要なときにもう一方を使おうとするとGHCはエラーを報告するだろう。</para>

    <para>形式的にいうと、Haskell98では、プログラム中の実体(関数または型またはクラス)はそれが定義されているモジュール名と名前との対で一意に識別される。GHCでは、ある実体は、パッケージ、モジュール、名前の三つ組で一意に識別される。</para>
  </sect2>

  <sect2 id="package-databases">
    <title>パッケージデータベース</title>
 
    <para>パッケージデータベースとは、インストール済みのパッケージについての詳細が記録されている場所である。パッケージデータベースは一つのディレクトリであり、通常<literal>package.conf.d</literal>という名前である。これには各パッケージごとのファイルと、パッケージデータのバイナリキャッシュが入った<literal>package.cache</literal>が置かれている。通常、パッケージデータベースの中身を直接見たり変更したりする必要はないはずである。パッケージデータベースの管理はすべて<literal>ghc-pkg</literal>ツールを介して行える(<xref linkend="package-management"/>を見よ)。
    </para>

    <para>
      GHCは特定の二つのパッケージデータベースについて知っている。
    </para>

    <itemizedlist>
      <listitem>
        <para>大域的パッケージデータベース。これはGHCのインストール内容に含まれる。例えば、<filename>/usr/lib/ghc-6.12.1/package.conf.d</filename>。</para>
      </listitem>
      <listitem>
        <para>各ユーザ専用のパッケージデータベース。Unixシステムではこれは<filename>$HOME/.ghc/<replaceable>arch</replaceable>-<replaceable>os</replaceable>-<replaceable>version</replaceable>/package.conf.d</filename>であり、Windowsでは<filename>C:\Documents&nbsp;And&nbsp;Settings\<replaceable>user</replaceable>\ghc\package.conf.d</filename>のようなところである。<literal>ghc-pkg</literal>ツールはこのファイルがどこに置かれるべきか知っていて、存在しなければこれを作る。(<xref linkend="package-management"/>を見よ)</para>
      </listitem>
    </itemizedlist>

    <para>GHCは、起動すると、これらの二つのパッケージデータベースの内容を読み、既知のパッケージの一覧を作り上げる。パッケージの一覧表を見るには、GHCを<option>-v</option>フラグ付きで走らせれば良い。</para>

    <para>パッケージデータベースには重複があっても良く、スタック構造で配置される。スタックの一番上に近いパッケージは下のものより優先される(それを<emphasis>覆い隠す</emphasis>)。デフォルトでは、スタックには大域データベースとユーザのパッケージデータベースがこの順であるだけである。</para>

    <para>GHCのパッケージデータベースのスタックを制御するには、以下のオプションを使えば良い。</para>

    <variablelist>
      <varlistentry>
        <term>
          <option>-package-db <replaceable>file</replaceable></option>
          <indexterm><primary><option>-package-db</option></primary></indexterm>
        </term>
        <listitem>
          <para>パッケージデータベース<replaceable>file</replaceable>を現在のスタックの一番上に置く。この方法で読まれるデータベースにあるパッケージは、スタックに最初からあったものや以前に指定されたパッケージよりも優先される。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><option>-no-global-package-db</option>
          <indexterm><primary><option>-no-global-package-db</option></primary>
          </indexterm>
        </term>
        <listitem>
          <para>パッケージデータベースのスタックから大域パッケージデータベースを取り除く。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><option>-no-user-package-db</option>
          <indexterm><primary><option>-no-user-package-db</option></primary>
          </indexterm>
        </term>
        <listitem>
          <para>ユーザ固有のパッケージデータベースを初期スタックにロードしない。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><option>-clear-package-db</option>
          <indexterm><primary><option>-clear-package-db</option></primary>
          </indexterm>
        </term>
        <listitem>
            <para>現在のパッケージデータベーススタックを空にする。このオプションは、以前に指定されたパッケージデータベースを(<literal>GHC_PACKAGE_PATH</literal>環境変数から読まれたものも含めて)全てパッケージデータベーススタックから取り除く。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><option>-global-package-db</option>
          <indexterm><primary><option>-global-package-db</option></primary>
          </indexterm>
        </term>
        <listitem>
          <para>現在のスタックの一番上に大域パッケージデータベースを加える。このオプションは、<literal>-no-global-package-db</literal>の後に使うことで、スタック内で大域パッケージデータベースがロードされるべき位置を指定することができる。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><option>-user-package-db</option>
          <indexterm><primary><option>-user-package-db</option></primary>
          </indexterm>
        </term>
        <listitem>
          <para>現在のスタックの一番上にユーザのパッケージデータベースを加える。このオプションは、<literal>-no-user-package-db</literal>の後に使うことで、スタック内でユーザのパッケージデータベースがロードされるべき位置を指定することができる。</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <sect3 id="ghc-package-path">
      <title><literal>GHC_PACKAGE_PATH</literal>環境変数</title>
      <indexterm><primary>Environment variable</primary><secondary><literal>GHC_PACKAGE_PATH</literal></secondary>
      </indexterm>
      <indexterm><primary><literal>GHC_PACKAGE_PATH</literal></primary></indexterm>
      <para><literal>GHC_PACKAGE_PATH</literal>環境変数に<literal>:</literal>区切り(Windowsでは<literal>;</literal>区切り)でパッケージデータベースファイルを並べて指定することができる。この一覧はGHCとghc-pkgが使う。このとき、一覧に先に現れるデータベースが後のものより優先される。これは<literal>PATH</literal>環境変数の挙動に倣ったものである。この一覧が左から順に探索されると考えると良い。</para>

      <para><literal>GHC_PACKAGE_PATH</literal>が区切り子で終わるなら、デフォルトのパッケージデータベーススタック(つまり、ユーザのパッケージデータベースと大域パッケージデータベースがこの順で)付け加えられる。例えば、通常のパッケージにあなた自身のデータベースを付け加えるには、次のようにすると良い。(Unixの例)
<screen>
$ export GHC_PACKAGE_PATH=$HOME/.my-ghc-packages.conf:</screen>
        (Windowsでは<literal>:</literal>の代わりに<literal>;</literal>を使うこと)</para>

      <para><literal>GHC_PACKAGE_PATH</literal>が正しく設定されているかどうかを確かめるには、<literal>ghc-pkg list</literal>とすれば良い。これは、利用中のパッケージデータベースを、探索されるのと逆の順序で全て表示する。</para>
    </sect3>
  </sect2>

  <sect2 id="package-ids">
    <title>パッケージID、依存関係、壊れたパッケージ</title>

    <para>インストール済みのパッケージにはそれぞれ固有の識別子(「インストール済みパッケージID」または単に短く「パッケージID」)があり、そのシステムにインストールされている他のパッケージと区別される。インストール済みパッケージそれぞれに決められたパッケージIDを見るには、<literal>ghc-pkg list -v</literal>を使えばよい。</para>

    <screen>
$ ghc-pkg list -v
using cache: /usr/lib/ghc-6.12.1/package.conf.d/package.cache
/usr/lib/ghc-6.12.1/package.conf.d
   Cabal-1.7.4 (Cabal-1.7.4-48f5247e06853af93593883240e11238)
   array-0.2.0.1 (array-0.2.0.1-9cbf76a576b6ee9c1f880cf171a0928d)
   base-3.0.3.0 (base-3.0.3.0-6cbb157b9ae852096266e113b8fac4a2)
   base-4.2.0.0 (base-4.2.0.0-247bb20cde37c3ef4093ee124e04bc1c)
   ...
</screen>

    <para>パッケージ名の後の括弧内にある文字列がパッケージIDである。これは通常パッケージ名とバージョンで始まり、コンパイルされたパッケージから導出されたハッシュ文字列で終わる。パッケージ間の依存関係は、単にパッケージとバージョンについてではなく、パッケージIDについて表現される。例えば、この<literal>haskell98</literal>パッケージの依存関係を見て欲しい。</para>

    <screen>
$ ghc-pkg field haskell98 depends
depends: array-0.2.0.1-9cbf76a576b6ee9c1f880cf171a0928d
         base-4.2.0.0-247bb20cde37c3ef4093ee124e04bc1c
         directory-1.0.0.2-f51711bc872c35ce4a453aa19c799008
         old-locale-1.0.0.1-d17c9777c8ee53a0d459734e27f2b8e9
         old-time-1.0.0.1-1c0d8ea38056e5087ef1e75cb0d139d1
         process-1.0.1.1-d8fc6d3baf44678a29b9d59ca0ad5780
         random-1.0.0.1-423d08c90f004795fd10e60384ce6561
</screen>

    <para>パッケージを再インストールしたときに、それに依存するパッケージを再コンパイルし忘れると問題が起こるが、パッケージIDはこの問題を検出するために存在する。再コンパイルの依存関係が必要なのは、例え同じソースコードから同じコンパイラでビルドされたとしても、新しくコンパイルされたパッケージのABI(Application Binary Interface)が異なるかもしれないからである。パッケージIDがあると、再コンパイルしたパッケージは前の版とは異なるパッケージIDを持つことになるので、前の版に依存していたパッケージは宙に浮いた状態、つまり依存関係のうちどれかが満たされていない状態になる。この意味で壊れているパッケージは、<literal>ghc-pkg list</literal>の出力において、赤色(可能なら)か、さもなくば中括弧で囲まれて示される。次の例において、<literal>filepath</literal>パッケージを再コンパイル、再インストールしたので、これによって<literal>Cabal</literal>を含むいくつかの依存物が壊れている。</para>

    <screen>
$ ghc-pkg list
WARNING: there are broken packages.  Run 'ghc-pkg check' for more details.
/usr/lib/ghc-6.12.1/package.conf.d:
    {Cabal-1.7.4}
    array-0.2.0.1
    base-3.0.3.0
    ... etc ...
</screen>

    <para>加えて、<literal>ghc-pkg list</literal>は壊れたパッケージがあることについて注意を促し、<literal>ghc-pkg check</literal>を勧める。これは、この失敗の性質についてさらなる情報を表示するものである。
    </para>

    <screen>
$ ghc-pkg check
There are problems in package ghc-6.12.1:
  dependency "filepath-1.1.0.1-87511764eb0af2bce4db05e702750e63" doesn't exist
There are problems in package haskeline-0.6.2:
  dependency "filepath-1.1.0.1-87511764eb0af2bce4db05e702750e63" doesn't exist
There are problems in package Cabal-1.7.4:
  dependency "filepath-1.1.0.1-87511764eb0af2bce4db05e702750e63" doesn't exist
There are problems in package process-1.0.1.1:
  dependency "filepath-1.1.0.1-87511764eb0af2bce4db05e702750e63" doesn't exist
There are problems in package directory-1.0.0.2:
  dependency "filepath-1.1.0.1-87511764eb0af2bce4db05e702750e63" doesn't exist

The following packages are broken, either because they have a problem
listed above, or because they depend on a broken package.
ghc-6.12.1
haskeline-0.6.2
Cabal-1.7.4
process-1.0.1.1
directory-1.0.0.2
bin-package-db-0.0.0.0
hpc-0.5.0.2
haskell98-1.0.1.0
</screen>

    <para>この問題を解決するには、壊れたパッケージ群を、新しい依存関係に対して再コンパイルしなければならない。これをするのに最も簡単な方法は、<literal>cabal-install</literal>を使うか、あるいは<ulink url="http://hackage.haskell.org/packages/hackage.html">HackageDB</ulink>からそのパッケージをダウンロードして通常と同じようにビルド、インストールすることである。</para>

    <para>GHC自身が依存しているパッケージを再コンパイルすることがないように注意。これをすると<literal>ghc</literal>パッケージ自体が壊れる可能性があり、<literal>ghc</literal>は単純にコンパイルしなおすことができない。この状態から回復するにはGHCを再インストールするしかないだろう。</para>
  </sect2>

  <sect2 id="package-management">
    <title>パッケージ管理(<literal>ghc-pkg</literal>コマンド)</title>
    <indexterm><primary>packages</primary>
      <secondary>management</secondary></indexterm>
 
    <para><literal>ghc-pkg</literal>ツールは、パッケージデータベースの情報を取得したり、これに変更を加えたりするためのものである。どんなパッケージデータベースが使われているか見るには、<literal>ghc-pkg&nbsp;list</literal>とすれば良い。<literal>ghc-pkg</literal>が知っているパッケージデータベースのスタックは、<literal>GHC_PACKAGE_PATH</literal>環境変数(<xref linkend="ghc-package-path"/>を見よ)を使うか、<literal>ghc-pkg</literal>のコマンド行から<literal>--package-db</literal>を使うことで変更できる。</para>

    <para>データベースを変更するとき、<literal>ghc-pkg</literal>はデフォルトで大域的データベースを変更する。<option>--user</option>を指定すればユーザデータベースが操作される。また、<option>--package-db</option>を使ってまったく別のデータベースを操作させることもできる。これらのオプションが複数与えられたときは、もっとも右にあるものが対象のデータベースとして使われる。</para>

   <para>パッケージデータベースに問い合わせを行うコマンド(list、latest、describe、find、dot)は、フラグ<option>--user</option>、<option>--global</option>、<option>--package-db</option>によって指定されるデータベースの列に対して動作する。これらのフラグが一つも与えられなかった場合、デフォルトは<option>--global</option> <option>--user</option>である。</para>

    <para><literal>GHC_PACKAGE_PATH</literal>環境変数が設定されていて、その値の最後が区切り子(Unixでは<literal>:</literal>、Windowsでは<literal>;</literal>)でないとき、最後のデータベースが大域データベースとみなされ、<literal>ghc-pkg</literal>はデフォルトでこれを変更する。このようになっているのは、<literal>GHC_PACKAGE_PATH</literal>を使って仮想的なパッケージ環境を構築し、そこでは他に何も指定することなくCabalパッケージをインストールできるようにすることが可能であるように、である。</para>

    <para><literal>ghc-pkg</literal>プログラムは下の一覧にあるような方法で実行できる。パッケージ名が必要なところでは、バージョン番号を含めて完全な形で指定しても良いし(<literal>network-1.0</literal>のように)、バージョン番号なしで指定しても良い。パッケージをバージョン番号なしで指定すると、そのパッケージの全てのバージョンが該当する。指定された操作は該当する全てのパッケージに対して行われる。パッケージの全てのバージョンが該当するという指定子は<replaceable>pkg</replaceable><literal>-*</literal>のように書くこともでき、こうすれば複数のパッケージが該当するだろうことがより明確になる。</para>

    <variablelist>
      <varlistentry>
        <term><literal>ghc-pkg init <replaceable>path</replaceable></literal></term>
        <listitem>
          <para><replaceable>path</replaceable>に、新しい空のパッケージデータベースを作る。<replaceable>path</replaceable>が既に存在していてはならない。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>ghc-pkg register <replaceable>file</replaceable></literal></term>
        <listitem>
          <para><replaceable>file</replaceable>(これは「<literal>-</literal>」であっても良い。その場合標準入力)からパッケージの仕様を読み、インストール済みパッケージのデータベースに加える。<replaceable>file</replaceable>の構文は<xref linkend="installed-pkg-info"/>で与えられる。</para>

          <para>パッケージの仕様はインストール済みパッケージのものであってはならない。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>ghc-pkg update <replaceable>file</replaceable></literal></term>
        <listitem>
          <para><literal>register</literal>と同様だが、同名のパッケージがインストール済みなら、新しいもので置き換える。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>ghc-pkg unregister <replaceable>P</replaceable></literal></term>
        <listitem>
          <para>指定されたパッケージをデータベースから削除する。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>ghc-pkg check</literal></term>
        <listitem>
          <para>パッケージデータベース内の依存関係の整合性を検査し、依存関係が満たされていないパッケージがあれば報告する。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>ghc-pkg expose <replaceable>P</replaceable></literal></term>
        <listitem>
          <para>パッケージ<replaceable>P</replaceable>の<literal>exposed</literal>フラグ(訳注: 露出フラグ)を<literal>True</literal>に設定する。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>ghc-pkg hide <replaceable>P</replaceable></literal></term>
        <listitem>
          <para>パッケージ<replaceable>P</replaceable>の<literal>exposed</literal>フラグ(訳注: 露出フラグ)を<literal>False</literal>に設定する。</para>
        </listitem>
      </varlistentry>

       <varlistentry>
        <term><literal>ghc-pkg trust <replaceable>P</replaceable></literal></term>
         <listitem>
          <para>パッケージ<replaceable>P</replaceable>の<literal>trusted</literal>フラグを<literal>True</literal>に設定する。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>ghc-pkg distrust <replaceable>P</replaceable></literal></term>
        <listitem>
          <para>パッケージ<replaceable>P</replaceable>の<literal>trusted</literal>フラグを<literal>False</literal>に設定する。</para>
         </listitem>
       </varlistentry>

      <varlistentry>
        <term><literal>ghc-pkg list [<replaceable>P</replaceable>] [<option>--simple-output</option>]</literal></term>
        <listitem>
          <para>このオプションは、<literal>ghc-pkg</literal>の知っているデータベースそれぞれについて、現在インストールされているパッケージを表示する。これには大域データベース、ユーザ固有のデータベース、及びコマンド行から<option>-f</option>オプションで指定されたファイルが含まれる。</para>

          <para>隠されたパッケージ(<literal>exposed</literal>フラグ(訳注: 露出フラグ)が<literal>False</literal>であるもの)は括弧付きで表示される。</para>

          <para>パッケージ識別子<replaceable>P</replaceable>は省略可能だが、これが与えられると、この識別子に該当するパッケージのみが出力される。</para>
          
          <para><option>--simple-output</option>オプションが与えられると、パッケージはスペースで区切られて一行で出力され、データベース名は含まれない。これは<literal>ghc-pkg list</literal>の出力をスクリプトでパースするのが楽なようにである。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>ghc-pkg find-module <replaceable>M</replaceable> [<option>--simple-output</option>]</literal></term>
        <listitem>
    <para>このオプションは、<replaceable>M</replaceable>というモジュールをエクスポートしている登録済みパッケージを列挙する。例を挙げる。</para>
<screen>
$ ghc-pkg find-module Var
c:/fptools/validate/ghc/driver/package.conf.inplace:
    (ghc-6.9.20080428)

$ ghc-pkg find-module Data.Sequence
c:/fptools/validate/ghc/driver/package.conf.inplace:
    containers-0.1
</screen>
  <para>それ以外の点については、オプションを含め、<literal>ghc-pkg list</literal>と同じように振る舞う。</para>
        </listitem>
      </varlistentry>


      <varlistentry>
        <term><literal>ghc-pkg latest <replaceable>P</replaceable></literal></term>
        <listitem>
          <para>パッケージ<replaceable>P</replaceable>の最新の利用可能な版を表示する。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>ghc-pkg describe <replaceable>P</replaceable></literal></term>
        <listitem>
          <para>指定されたパッケージの完全な説明を出力する。説明は<literal>InstalledPackageInfo</literal>の形で、これは<literal>ghc-pkg register</literal>への入力ファイルの書式と同じである。詳細は<xref linkend="installed-pkg-info"/>を見よ。</para>

          <para>パターンが複数のパッケージと照合する場合、個々のパッケージの説明が<literal>---</literal>という文字列だけからなる行で区切られて出力される。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>ghc-pkg field <replaceable>P</replaceable> <replaceable>field</replaceable>[,<replaceable>field</replaceable>]*</literal></term>
        <listitem>
          <para>インストール済みパッケージ<literal>P</literal>の説明のうち、一つのフィールドを表示する。コンマで区切ることで複数のフィールドを選択できる。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>ghc-pkg dot</literal></term>
        <listitem>
          <para>パッケージの依存関係のグラフを、<ulink url="http://www.graphviz.org/">graphviz</ulink>への入力に適した形式で生成する。例えば、依存グラフのPDFを生成するには次のようにする。</para>
<screen>
ghc-pkg dot | tred | dot -Tpdf >pkgs.pdf
</screen>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>ghc-pkg dump</literal></term>
        <listitem>
          <para>全てのパッケージについて、<literal>InstalledPackageInfo</literal>の形式で完全な説明を出力する。複数のパッケージは<literal>---</literal>という文字列だけからなる行で区切られる。</para>

          <para>これは<literal>ghc-pkg describe '*'</literal>とほとんど同じである。ただし、<literal>ghc-pkg dump</literal>は結果をパースするツールによって使われることを意図しているので、例えば<literal>ghc-pkg describe '*'</literal>はパターンに照合するパッケージを見つけられなかった場合にエラーを出力するのに対し、<literal>ghc-pkg dump</literal>は何も出力しないだけである。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>ghc-pkg recache</literal></term>
        <listitem>
          <para>選択したデータベースについて、バイナリキャッシュファイル<filename>package.cache</filename>を再作成する。これは、キャッシュが何らかの理由でデータベースの内容との同期が取れなくなった場合に必要かもしれない(この疑いがある場合、<literal>ghc-pkg</literal>が警告を発するだろう)。</para>

          <para>これ以外で<literal>ghc-pkg recache</literal>が便利なのは、パッケージを手動で登録する場合である。パッケージの登録は、適切なファイルをデータベースディレクトリに置き、<literal>ghc-pkg recache</literal>でキャッシュを更新するだけで可能である。自動化されたパッケージシステムにとっては、こちらの方法でパッケージを登録する方が便利かもしれない。
          </para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>
      <literal>find-module</literal>の<replaceable>M</replaceable>、<literal>list</literal>と<literal>describe</literal>の<replaceable>P</replaceable>、そして<literal>field</literal>については、部分文字列照合ができる。その場合、部分文字列の開放端を<literal>'*'</literal>で示す。(<literal>prefix*</literal>、<literal>*suffix</literal>、<literal>*infix*</literal>のように)。例を示す(出力は省略)。
    </para>
    <screen>
    -- regex関係のパッケージを全て表示する
    ghc-pkg list '*regex*' --ignore-case
    -- 文字列関係のパッケージを全て表示する
    ghc-pkg list '*string*' --ignore-case
    -- OpenGL関係のパッケージ
    ghc-pkg list '*gl*' --ignore-case
    -- Data階層のモジュールをエクスポートしているパッケージを一覧
    ghc-pkg find-module 'Data.*'
    -- Monadモジュールをエクスポートしているパッケージを一覧
    ghc-pkg find-module '*Monad*'
    -- 全てのパッケージの名前とメンテナを表示
    ghc-pkg field '*' name,maintainer
    -- 全てのパッケージのhaddockのhtmlの場所を表示
    ghc-pkg field '*' haddock-html
    -- データベース全体をダンプ
    ghc-pkg describe '*'
</screen>

    <para>さらに、<literal>ghc-pkg</literal>は以下のフラグを受け付ける。</para>

    <variablelist>
      <varlistentry>
        <term>
          <option>-f</option> <replaceable>file</replaceable>
          <indexterm><primary><option>-f</option></primary>
          </indexterm>
        </term>
        <term>
          <option>-package-db</option> <replaceable>file</replaceable>
          <indexterm><primary><option>-package-db</option></primary>
          </indexterm>
        </term>
        <listitem>
          <para><replaceable>file</replaceable>をパッケージデータベースのスタックに加える。さらに、後続のオプションに上書きされない限り、<literal>register</literal>、<literal>unregister</literal>、<literal>expose</literal>、<literal>hide</literal>コマンドが変更するデータベースは<replaceable>file</replaceable>になる。これを上書きし得るのは、<option>--package-db</option>、<option>--user</option>、<option>--global</option>である。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>
          <option>--force</option>
          <indexterm><primary>
              <option>--force</option>
            </primary></indexterm>
        </term>
        <listitem>
          <para>パッケージを登録するとき、足りない依存関係、ディレクトリ、ファイルを無視して構わず追加する。これは、使っているパッケージシステムの要請で、ファイルをビルドしてインストールする前にGHCにパッケージを登録しないといけない場合に有用かもしれない。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>
          <option>--global</option><indexterm><primary><option>--global</option></primary>
          </indexterm>
        </term>
        <listitem>
          <para>大域的パッケージデータベースを操作する。(これがデフォルトである)。このフラグは<literal>register</literal>、<literal>update</literal>、<literal>unregister</literal>、<literal>expose</literal>、<literal>hide</literal>の各コマンドに影響する。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>
          <option>--help</option><indexterm><primary><option>--help</option></primary>
          </indexterm>
        </term>
        <term>
          <option>-?</option><indexterm><primary><option>-?</option></primary>
          </indexterm>
        </term>
        <listitem>
          <para>コマンド行構文の要約を出力する。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>
          <option>--user</option><indexterm><primary><option>--user</option></primary>
          </indexterm>
        </term>
        <listitem>
          <para>現在のユーザのパッケージデータベースを操作する。このフラグは<literal>register</literal>、<literal>update</literal>、<literal>unregister</literal>、<literal>expose</literal>、<literal>hide</literal>の各コマンドに影響する。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>
          <option>-v</option><optional><replaceable>n</replaceable></optional><indexterm><primary><option>-v</option></primary><secondary>ghc-pkg 
              option</secondary></indexterm>
        </term>
        <term>
          <option>--verbose</option><optional>=<replaceable>n</replaceable></optional><indexterm><primary><option>--verbose</option></primary><secondary>ghc-pkg option</secondary></indexterm>
        </term>
        <listitem>
          <para>多弁さを制御する。多弁さの水準は0から2までであり、デフォルトは1である。<option>-v</option>のみなら2が選択される。
          </para>
        </listitem>
      </varlistentry>          

      <varlistentry>
        <term>
          <option>-V</option><indexterm><primary><option>-V</option></primary>
          </indexterm>
        </term>
        <term>
          <option>--version</option><indexterm><primary><option>--version</option></primary>
          </indexterm>
        </term>
        <listitem>
          <para><literal>ghc-pkg</literal>のバージョン番号を出力する。</para>
        </listitem>
      </varlistentry>
    </variablelist>

  </sect2>

  <sect2 id="building-packages">
    <title>Haskellソースからパッケージをビルドする</title>
    <indexterm><primary>packages</primary>
      <secondary>building</secondary></indexterm>

    <para>苦労してパッケージをビルドすることは推奨されない。代わりに、可能なら<ulink url="../Cabal/index.html">Cabal</ulink>(訳注: 未訳。<ulink url="http://www.haskell.org/ghc/docs/latest/html/Cabal/index.html">web上の最新版</ulink>)を使ってほしい。しかし、あなたのパッケージが特に複雑だったリ、大量の設定を要したりするなら、低レベルな機構にフォールバックしなければならないかもしれないので、そういう強者のためにいくつか手がかりを示しておく。</para>
 
    <para>パッケージをインストールする際、<literal>ghc-pkg</literal>に渡すための「インストール済みパッケージ情報」ファイルを構築する必要がある。このファイルの内容は<xref linkend="installed-pkg-info"/>に説明されている。</para>

    <para>パッケージ中のHaskellコードは、ビルドされて一つ以上のライブラリアーカイブ(例えば<filename>libHSfoo.a</filename>)になるか、あるいは単一の共有オブジェクト(例えば<filename>HSfoo.dll/.so/.dylib</filename>)になることもできる。共有オブジェクトが単一でなければいけないのは、コンパイラが共有オブジェクト間呼び出しを作るか共有オブジェクト内呼び出しを作るかの判断にパッケージシステムが用いられるからである。(共有オブジェクト間呼び出しには余分な間接参照が必要になる)。</para>
    <itemizedlist>
      <listitem>
        <para>静的ライブラリをビルドするのは<literal>ar</literal>を用いて為される。次のように。</para>

<screen>ar cqs libHSfoo-1.0.a A.o B.o C.o ...</screen>

        <para>ここで、<filename>A.o</filename>、<filename>B.o</filename>などはコンパイル済みHaskellモジュールであり、<filename>libHSfoo.a</filename>は作りたいライブラリである。システムによって構文が微妙に違うかもしれないので、問題があれば説明書を確かめること。</para>

      </listitem>
      <listitem>
        <para>パッケージ<literal>foo</literal>をロードするに当たって、GHCはそれの<literal>libHSfoo.a</literal>ライブラリを直接ロードすることもできるが、リンク済みの単一の<literal>HSfoo.o</literal>の形のパッケージをロードすることもできる。<literal>.o</literal>ファイルをロードするのはやや速いが、代わりにコンパイル済みパッケージのコピーを一つ余分に持つ必要がある。経験的には、パッケージのモジュールが<option>-split-objs</option>付きでコンパイルされたのなら、パッケージをGHCiにロードする時間を減らせるので<literal>HSfoo.o</literal>を使う価値がある。<option>-split-objs</option>なしでは、<literal>.o</literal>と<literal>.a</literal>のライブラリの間にあまり大きなロード時間の違いがないので、<literal>.a</literal>だけを置いておくことでディスク領域を節約した方が良い。GHC配布物中では、GHCパッケージ自体を除く大部分のパッケージに<literal>.o</literal>を用意している。
        </para>

        <para><literal>HSfoo.o</literal>ファイルはCabalによって自動的にビルドされる。これを無効にするには<option>--disable-library-for-ghci</option>を使う。手動でビルドするには、以下のGNU <command>ld</command>コマンドを使うことができる。</para>

<screen>ld -r --whole-archive -o HSfoo.o libHSfoo.a</screen>

        <para>(MacOS Xなら<literal>--whole-archive</literal>の代わりに<literal>-all_load</literal>を使うこと。)</para>
        
      </listitem>
      <listitem>
        <para>パッケージを共有ライブラリとしてビルドする場合、リンクの段階を行うためにGHCを使うことができる。これによって、内部的に使うリンカの詳細が一部隠され、GHCが対応している全ての共有オブジェクト形式(DLL、ELF DSO、Mac OSのdylib)に対して共通のインタフェースが得られる。共有オブジェクトは特定の方法で命名されねばならないが、これは次の二つの理由による。(1)GHCのコンパイラバージョンが名前に含まれていなければならない。これは、ライブラリを二つの異なるバージョンのGHCでコンパイルすると、呼び出し規約の点でまず間違いなく非互換になるので、これらが衝突しないようにするためである。(2)この名前は、静的ライブラリの名前とは異なっていなければならない。さもなくば、精密にリンカを制御することができず、<option>-static</option>/<option>-dynamic</option>フラグが動作するようにできなくなるだろう。<xref linkend="options-linker"/>を見よ。</para>

<screen>ghc -shared libHSfoo-1.0-ghc<replaceable>GHCVersion</replaceable>.so A.o B.o C.o</screen>
        <para>共有オブジェクトの名前の中にGHCのバージョン番号を使うことで、異なるバージョンのGHCでコンパイルした異なるバージョンのライブラリをシステムの標準の場所(たとえば*nixの/usr/lib以下)にインストールすることが可能になる。GHCのバージョン番号を得るには、<literal>ghc --numeric-version</literal>を起動して、その出力を<replaceable>GHCVersion</replaceable>として使えばよい。共有オブジェクトをリンクするためにオブジェクトファイルを準備する方法について、<xref linkend="options-codegen"/>も参照せよ。</para>
      </listitem>
    </itemizedlist>
    
      <para>新しいパッケージの一部となるべきモジュールをコンパイルするときは、<literal>-package-name</literal>オプション(<xref linkend="using-packages"/>)を使うこと。パッケージのコンパイル時に<literal>-package-name</literal>オプションを付け忘れるとおそらく惨事になるが、それが分かるのは後でそのパッケージからモジュールをインポートしようとしたときだろう。この時点でGHCは、そのモジュールがあると期待されるパッケージと、<literal>.hi</literal>ファイルに記録されたパッケージ名が異なることに文句をいう。</para>
    <para>共有オブジェクトについて注意に値することがある。それぞれのパッケージが単一の共有オブジェクトファイルとしてビルドされているとき、共有オブジェクトへの参照は余分な間接参照を必要とするので、パッケージ内での参照の方がパッケージ間参照よりもコストがかからない。もちろん、このことは<filename>main</filename>パッケージにも当てはまる。</para>
    </sect2>

  <sect2 id="installed-pkg-info">
    <title>
      <literal>InstalledPackageInfo</literal>: パッケージの仕様
    </title>

    <para>パッケージの仕様は一つのHaskellレコードである。具体的には、Distribution.InstalledPackageInfoモジュールにあるレコード<ulink url="&libraryCabalLocation;/Distribution-InstalledPackageInfo.html#%tInstalledPackageInfo">InstalledPackageInfo</ulink><!-- 訳注: %tではなくt%3A -->である。これはCabalパッケージの一部であり、GHCに付属している。</para>

    <para><literal>InstalledPackageInfo</literal>には人間可読の構文がある。<literal>parseInstalledPackageInfo</literal>および<literal>showInstalledPackageInfo</literal>という二つの関数でこの構文をそれぞれ読んだり書いたりできる。次に示すのは<literal>unix</literal>パッケージの<literal>InstalledPackageInfo</literal>の例である。</para>

<screen>
$ ghc-pkg describe unix
name: unix
version: 2.3.1.0
id: unix-2.3.1.0-de7803f1a8cd88d2161b29b083c94240
license: BSD3
copyright:
maintainer: libraries@haskell.org
stability:
homepage:
package-url:
description: This package gives you access to the set of operating system
             services standardised by POSIX 1003.1b (or the IEEE Portable
             Operating System Interface for Computing Environments -
             IEEE Std. 1003.1).
             .
             The package is not supported under Windows (except under Cygwin).
category: System
author:
exposed: True
exposed-modules: System.Posix System.Posix.DynamicLinker.Module
                 System.Posix.DynamicLinker.Prim System.Posix.Directory
                 System.Posix.DynamicLinker System.Posix.Env System.Posix.Error
                 System.Posix.Files System.Posix.IO System.Posix.Process
                 System.Posix.Process.Internals System.Posix.Resource
                 System.Posix.Temp System.Posix.Terminal System.Posix.Time
                 System.Posix.Unistd System.Posix.User System.Posix.Signals
                 System.Posix.Signals.Exts System.Posix.Semaphore
                 System.Posix.SharedMem
hidden-modules:
trusted: False
import-dirs: /usr/lib/ghc-6.12.1/unix-2.3.1.0
library-dirs: /usr/lib/ghc-6.12.1/unix-2.3.1.0
hs-libraries: HSunix-2.3.1.0
extra-libraries: rt util dl
extra-ghci-libraries:
include-dirs: /usr/lib/ghc-6.12.1/unix-2.3.1.0/include
includes: HsUnix.h execvpe.h
depends: base-4.2.0.0-247bb20cde37c3ef4093ee124e04bc1c
hugs-options:
cc-options:
ld-options:
framework-dirs:
frameworks:
haddock-interfaces: /usr/share/doc/ghc/html/libraries/unix/unix.haddock
haddock-html: /usr/share/doc/ghc/html/libraries/unix
</screen>

    <para>以下はこのファイルの構文の簡単な解説である。</para>

    <para>パッケージの仕様はいくつかのフィールド・値の対からなっている。フィールドにはまず行の左端から始まるフィールド名があり、「:」がそれに続き、さらに値が次の「左端から始まる行」またはファイル終端まで続く。</para>

    <para>値の記法はフィールドによって異なる。次のようにいくつかのフィールド型がある。</para>

    <variablelist>
      <varlistentry>
        <term>自由形式</term>
        <listitem>
          <para>任意の文字列。解釈されたりパースされたりすることはない。</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>文字列</term>
        <listitem>
          <para>非空白文字の列、または引用符で囲まれた任意の文字の列<literal>"..."</literal>。</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>文字列の並び</term>
        <listitem>
          <para>コンマで区切られた文字列の列。空の列であっても良い。</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>加えて、特別な構文を持つフィールドもいくつかある。(例えば、パッケージ名、バージョン、依存関係)</para>

    <para>許されるフィールドと、その型は、以下の通りである。</para>

    <variablelist>
      <varlistentry>
        <term>
          <literal>name</literal>
          <indexterm><primary><literal>name</literal></primary><secondary>package specification</secondary></indexterm>
        </term>
        <listitem>
          <para>パッケージ名。(バージョンを含まない)</para>
        </listitem>
      </varlistentry>
 
      <varlistentry>
        <term>
          <literal>id</literal>
          <indexterm><primary><literal>id</literal></primary><secondary>package specification</secondary></indexterm>
        </term>
        <listitem>
          <para>パッケージID。適切なものを選ぶのはあなたの責任である。</para>
        </listitem>
      </varlistentry>
 
      <varlistentry>
        <term>
          <literal>version</literal>
          <indexterm><primary><literal>version</literal></primary><secondary>package specification</secondary></indexterm>
        </term>
        <listitem>
          <para>パッケージのバージョン。通常は<literal>A.B</literal>の形である。(任意の数値要素が許される)</para>
        </listitem>
      </varlistentry>
 
      <varlistentry>
        <term>
          <literal>license</literal>
          <indexterm><primary><literal>auto</literal></primary><secondary>package specification</secondary></indexterm>
        </term>
        <listitem>
          <para>(文字列)パッケージが配布されるにあたってのライセンス。このフィールドは型<ulink url="&libraryCabalLocation;/Distribution-License.html#t:License"><literal>License</literal></ulink>の値である。</para>
        </listitem>
      </varlistentry>

        <varlistentry>
          <term>
            <literal>license-file</literal>
            <indexterm><primary><literal>license-file</literal></primary><secondary>package specification</secondary></indexterm>
          </term>
          <listitem>
            <para>(省略可能な文字列)このパッケージについての詳細なライセンス情報の置かれたファイルの名前。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>copyright</literal>
            <indexterm><primary><literal>copyright</literal></primary><secondary>package specification</secondary></indexterm>
          </term>
          <listitem>
            <para>(省略可能な自由形式)著作権表示の文字列。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>maintainer</literal>
            <indexterm><primary><literal>maintainer</literal></primary><secondary>package specification</secondary></indexterm>
          </term>
          <listitem>
            <para>(省略可能な自由形式)パッケージのメンテナのメールアドレス。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>stability</literal>
            <indexterm><primary><literal>stability</literal></primary><secondary>package specification</secondary></indexterm>
          </term>
          <listitem>
            <para>(省略可能な自由形式)パッケージの安定性を示す文字列。(例: stable、provisional、experimental)</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>homepage</literal>
            <indexterm><primary><literal>homepage</literal></primary><secondary>package specification</secondary></indexterm>
          </term>
          <listitem>
            <para>(省略可能な自由形式)パッケージのホームページのURL。</para>
          </listitem>
        </varlistentry>

      <varlistentry>
        <term>
            <literal>package-url</literal>
            <indexterm><primary><literal>package-url</literal></primary><secondary>package specification</secondary></indexterm>
          </term>
          <listitem>
            <para>(省略可能な自由形式)ダウンロード可能な、このパッケージの配布物のURL。この配布物はCabalパッケージであるべきである。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>description</literal>
            <indexterm><primary><literal>description</literal></primary><secondary>package specification</secondary></indexterm>
          </term>
          <listitem>
            <para>(省略可能な自由形式)パッケージの説明。</para>
          </listitem>
        </varlistentry>

      <varlistentry>
          <term>
            <literal>category</literal>
            <indexterm><primary><literal>category</literal></primary><secondary>package specification</secondary></indexterm>
          </term>
          <listitem>
            <para>(省略可能な自由形式)パッケージが所属する分類。このフィールドは将来の中央集権化されたパッケージ配布フレームワーク(仮称Hackage)との連携のためのものである。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>author</literal>
            <indexterm><primary><literal>author</literal></primary><secondary>package specification</secondary></indexterm>
          </term>
          <listitem>
            <para>(省略可能な自由形式)パッケージの作者。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>exposed</literal>
            <indexterm><primary><literal>exposed</literal></primary><secondary>package specification</secondary></indexterm>
          </term>
          <listitem>
            <para>(真偽値)パッケージが露出されるか否か。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>exposed-modules</literal>
            <indexterm><primary><literal>exposed-modules</literal></primary><secondary>package specification</secondary></indexterm>
          </term>
          <listitem>
            <para>(文字列の並び)このパッケージがエクスポートするモジュール。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>hidden-modules</literal>
            <indexterm><primary><literal>hidden-modules</literal></primary><secondary>package specification</secondary></indexterm>
          </term>
          <listitem>
            <para>(文字列の並び)このパッケージが提供するが、プログラマには露出されないモジュール。こういうモジュールをインポートすることはできないが、重複モジュール制限の対象にはなる。(訳注: この制限はもはや存在しない)つまり、同じプログラムの別のパッケージが同じ名前のモジュールを提供していてはいけない。</para>
        </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>trusted</literal>
            <indexterm><primary><literal>trusted</literal></primary><secondary>package specification</secondary></indexterm>
          </term>
          <listitem>
            <para>(真偽値)このパッケージが信用されているか否か。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>import-dirs</literal>
            <indexterm><primary><literal>import-dirs</literal></primary><secondary>package specification</secondary></indexterm>
          </term>
          <listitem>
            <para>(文字列の並び)パッケージのインタフェースファイル(<literal>.hi</literal>ファイル)のあるディレクトリの一覧。</para>

            <para>パッケージがプロファイル版のライブラリを含むなら、そのインタフェースファイルの接尾辞は<literal>.p_hi</literal>であるべきである。したがって、パッケージは同じライブラリの通常版とプロファイル版を衝突なしに両方含むことができる。(下記の<literal>library_dirs</literal>も見よ)</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>library-dirs</literal>
            <indexterm><primary><literal>library-dirs</literal></primary><secondary>package specification</secondary></indexterm>
          </term>
          <listitem>
            <para>(文字列の並び)このパッケージのライブラリがあるディレクトリの一覧。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>hs-libraries</literal>
            <indexterm><primary><literal>hs-libraries</literal></primary><secondary>package specification</secondary></indexterm>
          </term>
          <listitem>
            <para>(文字列の並び)このパッケージ内の、Haskellコードのライブラリの一覧。<literal>.a</literal>または<literal>.dll</literal>という接尾辞は省略する。パッケージがライブラリとしてビルドされるときは、<literal>lib</literal>という接頭辞も省く。</para>

            <para>GHCiで使うためには、各ライブラリにはオブジェクトファイルもあるべきである。オブジェクトファイルの名前には<literal>lib</literal>接頭辞がなく、プラットフォームに置ける通常の接尾辞が付く。</para>

            <para>例えば、パッケージ仕様でHaskellライブラリを<filename>HSfoo</filename>と指定したとすると、GHCが実際に使うライブラリファイルは以下のものである。</para>
            <variablelist>
              <varlistentry>
                <term><filename>libHSfoo.a</filename></term>
                <listitem>
                  <para>UnixおよびWindows(mingw)システムにおけるライブラリの名前。Unixシステムでは動的ライブラリをビルドするのがサポートされていないことに注意。</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><filename>HSfoo.dll</filename></term>
                <listitem>
                  <para>Windowsシステムにおける動的ライブラリの名前。(なくても良い)</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term><filename>HSfoo.o</filename></term>
                <term><filename>HSfoo.obj</filename></term>
                <listitem>
                  <para>GHCiが使う、ライブラリのオブジェクト版。</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>extra-libraries</literal>
            <indexterm><primary><literal>extra-libraries</literal></primary><secondary>package specification</secondary></indexterm>
          </term>
          <listitem>
            <para>(文字列の並び)このパッケージの外部ライブラリの一覧。<literal>hs-libraries</literal>と<literal>extra-libraries</literal>の違いは、<literal>hs-libraries</literal>には通常、プロファイルや並列処理などのビルドオプションの違う、複数の版があることである。複数の版は区別のために異なる接尾辞を持つ。例えば、標準プレリュードライブラリのプロファイル版は<filename>libHSbase_p.a</filename>という名前で、<literal>_p</literal>がこれがプロファイル版であることを示している。接尾辞は<literal>hs-libraries</literal>についてのみGHCによって自動で加えられ、<literal>extra-libraries</literal>のライブラリには加えられない。</para>

            <para><literal>extra-libraries</literal>に列挙されるライブラリはシステムのリンカがサポートするならどんなライブラリでも良く、動的ライブラリでも良い。(Unixでは<literal>.so</literal>、Windowsでは<literal>.DLL</literal>)</para>

            <para>また、<literal>extra-libraries</literal>はリンカのコマンド行において<literal>hs-libraries</literal>よりも後に置かれる。もしその逆の依存関係があり(つまり、<literal>extra-libraries</literal>が<literal>hs-libraries</literal>に依存する)、しかもそれらが静的ライブラリなら、パッケージを二つに分割する必要があるかもしれない。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>include-dirs</literal>
            <indexterm><primary><literal>include-dirs</literal></primary><secondary>package specification</secondary></indexterm>
          </term>
          <listitem>
            <para>(文字列の並び)このパッケージのCインクルードファイルが置かれるディレクトリの一覧。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
           <literal>includes</literal>
           <indexterm><primary><literal>includes</literal></primary><secondary>package specification</secondary></indexterm>
          </term>
          <listitem>
            <para>(文字列の並び)このパッケージを使ってCを介したコンパイルをするときにインクルードするべきファイルの一覧。典型的には、これはこのパッケージで使われる全てのC関数のプロトタイプを含んでいて、パッケージ中のHaskell関数がインライン化された結果これらの関数が呼ばれることになったときに使われる。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>depends</literal>
            <indexterm><primary><literal>depends</literal></primary><secondary>package specification</secondary></indexterm>
          </term>
          <listitem>
            <para>(パッケージIDの並び)このパッケージが依存するパッケージの一覧。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>hugs-options</literal>
            <indexterm><primary><literal>hugs-options</literal></primary><secondary>package specification</secondary></indexterm>
          </term>
          <listitem>
            <para>(文字列の並び)このパッケージのためにHugsに渡すオプション。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>cc-options</literal>
            <indexterm><primary><literal>cc-options</literal></primary><secondary>package specification</secondary></indexterm>
          </term>
          <listitem>
            <para>(文字列の並び)このパッケージが使われるときにgccのコマンド行に渡される追加の引数。(Cを介したコンパイルでのみ使われる)</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>ld-options</literal>
            <indexterm><primary><literal>ld-options</literal></primary><secondary>package specification</secondary></indexterm>
          </term>
          <listitem>
            <para>(文字列の並び)このパッケージが使われるとき、リンク時に<command>gcc</command>のコマンド行に渡される追加の引数。</para>
          </listitem>
        </varlistentry>
        
        <varlistentry>
          <term>
            <literal>framework-dirs</literal>
            <indexterm><primary><literal>framework-dirs</literal></primary><secondary>package specification</secondary></indexterm>
          </term>
          <listitem>
            <para>(文字列の並び)Darwin/MacOS Xにおいて、このパッケージが使うフレームワークをのあるディレクトリの一覧。これは<option>-framework-path</option>オプションに対応する。その他全てのプラットフォームでは無視される。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>frameworks</literal>
            <indexterm><primary><literal>frameworks</literal></primary><secondary>package specification</secondary></indexterm>
          </term>
          <listitem>
            <para>(文字列の並び)Darwin/MacOS Xにおいて、リンクするフレームワークの一覧。これは<option>-framework</option>オプションに対応する。どのフレームワークを実際に使うかについてはAppleのdeveloper documentationを見てほしい。この項目はその他のプラットフォームでは無視される。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>haddock-interfaces</literal>
            <indexterm><primary><literal>haddock-interfaces</literal></primary><secondary>package specification</secondary></indexterm>
          </term>
          <listitem>
            <para>(文字列の並び)このパッケージの<ulink url="http://www.haskell.org/haddock/">Haddock</ulink>インタフェースファイル(<literal>.haddock</literal>ファイル)の一覧。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <literal>haddock-html</literal>
            <indexterm><primary><literal>haddock-html</literal></primary><secondary>package specification</secondary></indexterm>
          </term>
          <listitem>
            <para>(省略可能な文字列)Haddockで生成されたこのパッケージのHTML文書のあるディレクトリ。</para>
          </listitem>
        </varlistentry>
      </variablelist>
 
<!--  This isn't true any more.  I'm not sure if we still need it -SDM
      <para>
      The <literal>ghc-pkg</literal> tool performs expansion of
      environment variables occurring in input package specifications.
      So, if the <literal>mypkg</literal> was added to the package
      database as follows:
      </para>
<screen>
  $ installdir=/usr/local/lib ghc-pkg -a &lt; mypkg.pkg
</screen>

      <para>
      The occurrence of <literal>${installdir}</literal> is replaced
      with <literal>/usr/local/lib</literal> in the package data that
      is added for <literal>mypkg</literal>.
      </para>
 
      <para>
      This feature enables the distribution of package specification
      files that can be easily configured when installing.
      </para>

      <para>For examples of more package specifications, take a look
      at the <literal>package.conf</literal> in your GHC
      installation.</para>

-->

    </sect2>
  </sect1>

<!-- Emacs stuff:
     ;;; Local Variables: ***
     ;;; sgml-parent-document: ("users_guide.xml" "book" "chapter" "sect1") ***
     ;;; End: ***
 -->
