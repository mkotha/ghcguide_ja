<?xml version="1.0" encoding="UTF-8"?>
<chapter id="ghci">
  <title>GHCiを使う</title>
  <indexterm><primary>GHCi</primary></indexterm>
  <indexterm><primary>interpreter</primary><see>GHCi</see></indexterm>
  <indexterm><primary>interactive</primary><see>GHCi</see></indexterm>
  
  <para>GHCi<footnote><para>「i」はinteractiveのiである</para></footnote>はGHCの対話環境であり、Haskellの式を対話的に評価したりプログラムを解釈実行したりできる。もしあなたが<ulink url="http://www.haskell.org/hugs/">Hugs</ulink><indexterm><primary>Hugs</primary></indexterm>に慣れ親しんでいるなら、GHCiの扱いにもすぐに慣れるだろう。しかしながら、GHCiはコンパイル済みコードをロードすることができ、また、GHCが提供する言語拡張の全て<footnote><para>ただし、現在のところ、<literal>foreign export</literal>を除く</para></footnote>をサポートする。<indexterm><primary>FFI</primary><secondary>GHCi support</secondary></indexterm><indexterm><primary>Foreign Function Interface</primary><secondary>GHCi support</secondary></indexterm>また、GHCiには対話的デバッガが含まれている。(<xref linkend="ghci-debugger"/>を見よ)</para>

  <sect1 id="ghci-introduction">
    <title>GHCiの紹介</title>

    <para>GHCiセッションの例を見ていくことから始めよう。GHCiは<literal>ghci</literal>コマンドで起動することができる。</para>

<screen>
$ ghci
GHCi, version 6.8.1: http://www.haskell.org/ghc/  :? for help
Loading package base ... linking ... done.
Prelude> 
</screen>

    <para>GHCiがプレリュードと標準ライブラリをロードするのに少し時間が掛かるかもしれない。その後、プロンプトが表示される。バナーにある通り、<literal>:?</literal>と打ち込めば利用可能なコマンド一覧と、それぞれの短い説明が得られる。</para>

    <para>これらのコマンドの大部分はこれから説明する。Hugsの利用者へ: 多くのことがHugsと同じように動作するので、すぐに使えるようになるはずである。</para>

    <para>プロンプトでは、Haskellの式を入力することができる。</para>
    <indexterm><primary>prompt</primary><secondary>GHCi</secondary>
  </indexterm>

<screen>
Prelude> 1+2
3
Prelude> let x = 42 in x / 9
4.666666666666667
Prelude> 
</screen>

    <para>GHCiは行全体を一つの式だと解釈し、それを評価する。式は複数の行に渡っていてはいけない。エンターキーが押されると、GHCiは即座にそれを評価しようとする。</para>
  </sect1>

  <sect1 id="loading-source-files">
    <title>ソースファイルをロードする</title>

    <para>次のようなHaskellソースコードが<filename>Main.hs</filename>というファイルに置かれているとしよう。</para>

<programlisting>
main = print (fac 20)

fac 0 = 1
fac n = n * fac (n-1)
</programlisting>

    <para><filename>Main.hs</filename>はどこでも好きなところに保存することができるが、カレントディレクトリ<footnote><para>GHCiをシェルから起動したのなら、GHCiのカレントディレクトリはシェルのそれと同じである。GHCiをWindowsの「スタート」メニューから起動したなら、カレントディレクトリはおそらく<filename>C:\Documents and Settings\<replaceable>user name</replaceable></filename>あたりになる。</para></footnote>以外の場所に保存した場合、GHCiでディレクトリを正しく変更する必要がある。</para>

<screen>
Prelude> :cd <replaceable>dir</replaceable>
</screen>

    <para>ここで、<replaceable>dir</replaceable>は<filename>Main.hs</filename>を保存したディレクトリ(あるいはフォルダ)である。</para>

    <para>HaskellのソースファイルをGHCiにロードするには、<literal>:load</literal>コマンドを使う。</para>
    <indexterm><primary><literal>:load</literal></primary></indexterm>

<screen>
Prelude> :load Main
Compiling Main             ( Main.hs, interpreted )
Ok, modules loaded: Main.
*Main>
</screen>

    <para>GHCiは<literal>Main</literal>モジュールをロードし、プロンプトが「<literal>*Main></literal>」に変わった。これは、プロンプトに入力される式を評価するのに使われる文脈が、今ロードしたばかりの<literal>Main</literal>モジュールになったことを示すためのものである(<literal>*</literal>が何を意味するかについては<xref linkend="ghci-scope"/>で説明する)。つまり、これで<filename>Main.hs</filename>で定義された関数を含む式を入力できるようになったということである。</para>

<screen>
*Main> fac 17
355687428096000
</screen>

    <para>複数のモジュールからなるプログラムをロードするのも同様に簡単である。「最上位の」モジュールの名前を<literal>:load</literal>コマンドに指定すれば良い(ヒント: <literal>:load</literal>は<literal>:l</literal>に短縮できる)。最上位のモジュールはふつう<literal>Main</literal>であるが、必ずしもそうである必要はない。GHCiは最上位のモジュールから直接・間接に必要とされているモジュールを見付け、それらを依存関係の順にロードする。</para>

    <sect2 id="ghci-modules-filenames">
      <title>モジュールとファイル名</title>
      <indexterm><primary>modules</primary><secondary>and filenames</secondary></indexterm>
      <indexterm><primary>filenames</primary><secondary>of modules</secondary></indexterm>
      
      <para>GHCは<replaceable>M</replaceable>というモジュールがどのファイルにあるかをどのようにして知るのだろうか。GHCiは、<literal><replaceable>M</replaceable>.hs</literal>または<literal><replaceable>M</replaceable>.lhs</literal>というファイルを探すのである。したがって、大部分のモジュールでは、モジュール名とファイル名は一致しなければならない。一致しなかった場合、GHCiはモジュールを見つけ出すことができない。</para>

      <para>この規則には一つの例外がある。<literal>:load</literal>を使ってプログラムをロードするとき、あるいは<literal>ghci</literal>を起動するとき、モジュール名ではなくファイル名を指定することができる。そのファイルはもし存在するならロードされ、どんなモジュールを含んでいても構わない。これは、複数の<literal>Main</literal>モジュールが一つのディレクトリにある場合、全てを<filename>Main.hs</filename>と呼ぶことはできないので、特に便利である。</para>

      <para>ソースファイルを探すときの探索パスは、次に示すように、GHCiのコマンド行で<option>-i</option>を使って指定することができる。</para>

<screen>ghci -i<replaceable>dir<subscript>1</subscript></replaceable>:...:<replaceable>dir<subscript>n</subscript></replaceable></screen>

      <para>あるいは、GHCiの中から<literal>:set</literal>コマンドを使って設定することもできる(<xref linkend="ghci-cmd-line-options"/>を見よ)<footnote><para>GHCiや<option>&ndash;&ndash;make</option>モードでは<option>-i</option>オプションは<emphasis>ソース</emphasis>ファイルの探索パスを指定するのに対し、標準の一括コンパイルモードでは<option>-i</option>オプションはインターフェースファイルの探索パスを指定することに注意。<xref linkend="search-path"/>を見よ。</para></footnote>。</para>

      <para>GHCiが上記のような方法で依存関係を追うことの帰結として、全てのモジュールにソースファイルがなければならない、というものがある。唯一の例外はパッケージ由来のモジュールで、これには<literal>Prelude</literal>や、<literal>IO</literal>、<literal>Complex</literal>といった標準ライブラリも含まれる。モジュールをロードしようとたときGHCiがソースファイルを見付けられなかった場合、たとえそのモジュールのオブジェクトファイルやインタフェースファイルがあったとしても、エラーメッセージが表示されるだろう。</para>
    </sect2>

    <sect2>
      <title>ソースコードの変更と再コンパイル</title>
      <indexterm><primary><literal>:reload</literal></primary></indexterm>

      <para>ソースコードに変更を加えて、GHCiに再コンパイルさせたいときは、<literal>:reload</literal>コマンドを使えば良い。プログラムは必要に応じて再コンパイルされる。このとき、GHCiは依存関係の変化がないモジュールを実際に再コンパイルするのを避けようと最善を尽くす。これは一括コンパイル時に再コンパイルを避ける機構(<xref linkend="recomp"/>を見よ)と同じである。</para>
    </sect2>
  </sect1>

  <sect1 id="ghci-compiled">
    <title>コンパイル済みコードをロードする</title>
    <indexterm><primary>compiled code</primary><secondary>in GHCi</secondary></indexterm>

    <para>HaskellのソースモジュールをGHCiにロードしたとき、それはふつうバイトコードに変換され、解釈実行器を使って実行される。しかし、解釈実行されるコードをコンパイル済みコードと共に実行することもできる。実際、GHCiは起動するとふつう<literal>base</literal>パッケージのコンパイル済みのものをロードする(そのなかに<literal>Purelude</literal>がある)。</para>

    <para>なぜコンパイル済みのコードを使う必要があるのだろうか。コンパイル済みコードは解釈実行されるコードに比べて大体10倍速いが、一方、生成するのに2倍の時間が掛かる(最適化が有効ならさらに長いかもしれない)のである。そのため、プログラムのあまり変更されない部分をコンパイルしておき、活発に開発されている部分には解釈実行器を使う、ということをするだけの価値がある。</para>

    <para><literal>:load</literal>でソースモジュールをロードするとき、GHCiは対応するオブジェクトファイルを探し、可能ならソースコードの解釈実行よりも優先してそれを使う。例えば、A、B、C、Dという四つのモジュールからなるプログラムがあるとしよう。モジュールBとCはどちらもDのみをインポートしていて、AはBとCをインポートしている。</para>
<screen>
      A
     / \
    B   C
     \ /
      D
</screen>
    <para>Dをコンパイルして、その後プログラム全体をロードすると次のようになる。</para>
<screen>
Prelude> :! ghc -c D.hs
Prelude> :load A
Compiling B                ( B.hs, interpreted )
Compiling C                ( C.hs, interpreted )
Compiling A                ( A.hs, interpreted )
Ok, modules loaded: A, B, C, D.
*Main>
</screen>

    <para>コンパイラのメッセージ中に、<literal>D</literal>についての行がない。これは、ソースファイルとその依存関係が、最後にコンパイルされたときから変更されていないため、コンパイルする必要ないからである。</para>

    <para>いつでも、<literal>:show modules</literal>コマンドを使って、その時点でロードされているモジュールの一覧を表示することができる。</para>

<screen>
*Main> :show modules
D                ( D.hs, D.o )
C                ( C.hs, interpreted )
B                ( B.hs, interpreted )
A                ( A.hs, interpreted )
*Main></screen>

    <para>ここでDを編集(あるいは編集したふりをする。これにはUnixの<literal>touch</literal>コマンドが便利である)すると、コンパイラはオブジェクトファイルを使うことができなくなる。既に古くなっているかもしれないからである。</para>

<screen>
*Main> :! touch D.hs
*Main> :reload
Compiling D                ( D.hs, interpreted )
Ok, modules loaded: A, B, C, D.
*Main> 
</screen>

    <para>Dがコンパイルされたが、この例ではDのソースは実際には変更されていないので、インタフェースは同じままであり、そのため再コンパイル検査器がA、B、Cを再コンパイルする必要がないと判断したことに注意。</para>

    <para>では他のモジュールをコンパイルしてみよう。</para>

<screen>
*Main> :! ghc -c C.hs
*Main> :load A
Compiling D                ( D.hs, interpreted )
Compiling B                ( B.hs, interpreted )
Compiling C                ( C.hs, interpreted )
Compiling A                ( A.hs, interpreted )
Ok, modules loaded: A, B, C, D.
</screen>

    <para>Cのコンパイル済みの版が使われていない。これはどうしたことかというと、GHCではコンパイル済みのモジュールは別のコンパイル済みのモジュールにしか依存できないのである。この場合は、CがDに依存するが、Dにはオブジェクトファイルがないので、GHCiはCのオブジェクトファイルも利用しなかった。では、Dもコンパイルしてみよう。</para>

<screen>
*Main> :! ghc -c D.hs
*Main> :reload
Ok, modules loaded: A, B, C, D.
</screen>

    <para>なにも起こらない！これは新たな教訓である。新しくコンパイルされたモジュールは<literal>:reload</literal>では使われない。<literal>:load</literal>が必要である。</para>

<screen>
*Main> :load A
Compiling B                ( B.hs, interpreted )
Compiling A                ( A.hs, interpreted )
Ok, modules loaded: A, B, C, D.
</screen>

    <para>このようなオブジェクトファイルの自動ロードは混乱の原因になることがある。なぜなら、モジュールの最上位の、エクスポートされていない定義をプロンプトの式で使えるのは、そのモジュールが解釈実行されているときだけだからである(<xref linkend="ghci-scope"/>を見よ)。このため、解釈実行器を使ってモジュールをロードするようにGHCiに強制したいと思うことがあるかもしれない。これは、<literal>:load</literal>を使うときに、モジュール名またはファイル名の前に<literal>*</literal>を置くことで実現できる。例を挙げる。</para>

<screen>
Prelude> :load *A
Compiling A                ( A.hs, interpreted )
*A>
</screen>

<para><literal>*</literal>が使われている場合、GHCiはコンパイル済みオブジェクトコードがあっても無視し、そのモジュールを解釈実行する。既にモジュールをいくつかオブジェクトコードとしてロードしていて、そのうち一つを解釈実行したいなら、全部を再ロードする代わりに、<literal>:add *M</literal>を使って、<literal>M</literal>が解釈実行されて欲しいことを指定することができる。(これによって別のモジュールも解釈実行されるかもしれないことに注意。これは、コンパイル済みモジュールが解釈実行モジュールに依存できないためである)。</para>

<para><literal>-fobject-code</literal>オプションを使うと、常にあらゆる物をオブジェクトコードにコンパイルし、決してインタプリタを使わないようにすることができる(<xref linkend="ghci-obj"/>を見よ)。</para>

    <para>ヒント: GHCはコンパイル済みの版が最新であることが確かな場合しかコンパイル済みオブジェクトファイルを使わないので、大きいプロジェクトを扱っているときは、ときどき<literal>ghc &ndash;&ndash;make</literal>を実行してプロジェクト全体をコンパイルし(例えば昼食を食べに行く前にね)、解釈実行器を使って作業を続けるというのが良い方法である。コードを変更すると、変更されたモジュールは解釈実行されるが、プロジェクト中のその他の部分は変わらずコンパイル済みのものが使われる。</para>
  </sect1>

  <sect1 id="interactive-evaluation">
    <title>プロンプトで対話的に評価する</title>

    <para>プロンプトに式を入力すると、GHCiは即座に評価して結果を印字する。
<screen>
Prelude> reverse "hello"
"olleh"
Prelude> 5+5
10
</screen>
</para>

<sect2><title>I/O動作とプロンプト</title>

<para>GHCiはプロンプトにおいて行うのは単なる式の評価だけではない。なんらかの<literal>a</literal>について<literal>IO a</literal>の型を持つものを入力すると、GHCiはそれをIO動作として<emphasis>実行</emphasis>するのである。
<screen>
Prelude> "hello"
"hello"
Prelude> putStrLn "hello"
hello
</screen>
さらに、次の場合には(そしてその場合に限り)、GHCiはIO動作の結果を印字する。
<itemizedlist>
  <listitem><para>結果の型が<literal>Show</literal>のインスタンスである。</para></listitem>
  <listitem><para>結果の型が<literal>()</literal>でない。</para></listitem>
</itemizedlist>
例えば、<literal>putStrLn :: String -> IO ()</literal>に注意すると、次のようになる。
<screen>
Prelude> putStrLn "hello"
hello
Prelude> do { putStrLn "hello"; return "yes" }
hello
"yes"
</screen>
</para></sect2>

    <sect2 id="ghci-stmts">
      <title>プロンプトで<literal>do</literal>記法を使う</title>
      <indexterm><primary>do-notation</primary><secondary>in GHCi</secondary></indexterm>
      <indexterm><primary>statements</primary><secondary>in GHCi</secondary></indexterm>
      
      <para>GHCiは実際には単なる式ではなく<firstterm>文</firstterm>を受け付ける。そのため、値や関数を名前に束縛して、後で式や文の中で使うことができる。</para>

      <para>GHCiプロンプトが受け付ける文の構文は、Haskellの<literal>do</literal>式における文の構文と全く同じである。ただし、こちらにはモナドの多重定義はない。プロンプトに入力される文は<literal>IO</literal>モナドの中になければならない。
<screen>
Prelude> x &lt;- return 42
Prelude> print x
42
Prelude>
</screen>
      <literal>x &lt;- return 42</literal>という文は、「<literal>return 42</literal>を<literal>IO</literal>モナドの中で実行し、結果を<literal>x</literal>に束縛する」という意味である。以降、<literal>x</literal>を文の中で使う(例えば、上でしたように、値を印字する)ことができるようになる。</para>

      <para><option>-fprint-bind-result</option>が設定されているなら、GHCiは次の場合に(そしてその場合に限り)、文の結果を印字する。
	<itemizedlist>
	  <listitem>
            <para>文が束縛ではないか、ただ一つの変数を束縛するモナド束縛(<literal>p &lt;- e</literal>)である。</para>
	  </listitem>
	  <listitem>
            <para>変数の型が多相的でなく、<literal>()</literal>でなく、<literal>Show</literal>のインスタンスである。</para>
	  </listitem>
	</itemizedlist>
      <indexterm><primary><option>-fprint-bind-result</option></primary></indexterm><indexterm><primary><option>-fno-print-bind-result</option></primary></indexterm>
      </para>

      <para>もちろん、非IOの式を<literal>let</literal>文を使って束縛することもできる。</para>
<screen>
Prelude> let x = 42
Prelude> x
42
Prelude>
</screen>
      <para>この二種類の束縛のもう一つの違いは、モナド束縛(<literal>p &lt;- e</literal>)が<emphasis>正格</emphasis>(<literal>e</literal>が評価される)のに対して、<literal>let</literal>形式では式がすぐには評価されないことである。</para>
<screen>
Prelude> let x = error "help!"
Prelude> print x
*** Exception: help!
Prelude>
</screen>

      <para>モナド束縛と違って、<literal>let</literal>束縛では束縛された値が自動的に印字されることがないことに注意。</para>

      <para>ヒント: <literal>let</literal>文を使って、プロンプトで関数を定義することもできる。</para>
<screen>
Prelude> let add a b = a + b
Prelude> add 1 2
3
Prelude>
</screen>
        <para>しかし、複数の節からなる関数を定義したり、相互再帰的な関数を定義したりしようとすると、このやりかたはすぐ面倒になる。レイアウト規則が使えず、定義全体を、明示的な中括弧とセミコロンを使って一行で与えないといけないからだ。</para>
<screen>
Prelude> let { f op n [] = n ; f op n (h:t) = h `op` f op n t }
Prelude> f (+) 0 [1..3]
6
Prelude>
</screen>
      <para>この問題を軽減するために、GHCiのコマンドを<literal>:{</literal>と<literal>:}</literal>で囲む(それぞれ一行使って)と、複数行に渡らせることができるようになっている。</para>
<screen>
Prelude> :{
Prelude| let { g op n [] = n
Prelude|     ; g op n (h:t) = h `op` g op n t
Prelude|     }
Prelude| :}
Prelude> g (*) 1 [1..3]
6
</screen>
      <para>このような複数行コマンドは全てのGHCiコマンドについて用いることができ、<literal>:{</literal>と<literal>:}</literal>の間の行は単純に一行に繋げられて解釈される。よって、この行の集りは繋げられたときに単一の正しいコマンドになっていなければならず、レイアウト規則を使うことはできない。複数行コマンドの主な目的は、モジュールのロードの代替にすることではなく、.ghciファイル(<xref linkend="ghci-dot-files"/>を見よ)での定義を見やすく、保守しやすくすることである。</para>

      <para>文を評価または実行している間に発生した例外は、GHCiのコマンド行インタフェースによって捕捉され、印字される(例外について詳しくは、ライブラリ説明書の<literal>Control.Exception</literal>を見よ)。</para>

      <para>束縛は、同じ名前の既存の束縛を覆い隠す。現在のモジュールの文脈でスコープにある実体も同様に覆い隠される。</para>

      <para>警告: プロンプトで導入された束縛は一時的なもので、次に<literal>:load</literal>か<literal>:reload</literal>コマンドが実行されるまでしか存在しない。これらのコマンドが実行されると、一時的な束縛は全て失われる。ただし、<literal>:module</literal>での文脈の変更では失われない。一時的な束縛が新しい場所に移動するだけである。</para>

      <para>ヒント: <literal>:show binding</literal>コマンドを使うと、その時点でスコープにある束縛の一覧を得ることができる。</para>

<screen>
Prelude> :show bindings
x :: Int
Prelude></screen>

      <para>ヒント: <literal>+t</literal>オプションを有効にすると、GHCiは文によって束縛された全ての変数の型を表示するようになる。例えば、次のようにである。</para>
      <indexterm><primary><literal>+t</literal></primary></indexterm>
<screen>
Prelude> :set +t
Prelude> let (x:xs) = [1..]
x :: Integer
xs :: [Integer]
</screen>

    </sect2>

    <sect2 id="ghci-scope">
      <title>プロンプトで実際にスコープにあるのは何か</title>

      <para>プロンプトに式を入力するとき、どの識別子や型がスコープにあるのだろうか。GHCiでは、式を評価する際の環境をどうやって構築するか、正確に指定することができる。単純な場合から始めよう。GHCiを開始すると、プロンプトは次のようになっている。</para>

<screen>Prelude></screen>

      <para>これは、<literal>Prelude</literal>モジュールの全てのものが現在スコープにあるということを示している。ここでファイルをGHCiにロードすると、プロンプトは次のように変わる。</para>

<screen>
Prelude> :load Main.hs
Compiling Main             ( Main.hs, interpreted )
*Main>
</screen>

      <para>新しいプロンプトは<literal>*Main</literal>であり、これは、入力される式が、<literal>Main</literal>モジュールのトップレベルの文脈で評価されるということである。<!-- 今ロードしたばかりの --><literal>Main</literal>モジュールのトップレベルでスコープにあるものは、全てプロンプトでもスコープにある。(<literal>Main</literal>が明示的に隠していない限り、これにはおそらく<literal>Prelude</literal>も含まれる)</para>

      <para><literal>*<replaceable>module</replaceable></literal>という構文は、プロンプトから入力される式に対して、<replaceable>module</replaceable>の完全なトップレベルスコープが使われるということを示している。<literal>*</literal>がない場合、そのモジュールがエクスポートしているものだけが可視である。</para>

      <para>扱えるのは単一のモジュールだけではない。GHCiは複数のモジュールのスコープを組み合わせることができ、このとき<literal>*</literal>が付く形式と<literal>*</literal>なしの形式を混合して用いることができる。GHCiはこれらのモジュールのスコープを全て組み合わせ、プロンプトのスコープとする。</para>
      
      <para>注意: 技術的な理由から、GHCiは解釈実行されるモジュールについてしか<literal>*</literal>形式をサポートしない。そのため、コンパイル済みモジュールとパッケージのモジュールは、それがエクスポートしたものでしかプロンプトのスコープに寄与できない。GHCiがモジュールの解釈実行版を使っていることを確実にするには、モジュールをロードする時に<literal>*</literal>を加えれば良い。例えば<literal>:load *M</literal>のように。</para>

      <para>スコープは<literal>:module</literal>コマンドで操作できる。例えば、現在のスコープが<literal>Prelude</literal>なら、次のようにして、<literal>IO</literal>モジュールでエクスポートされたものをスコープに導入することができる。</para>

<screen>
Prelude> :module +IO
Prelude IO> hPutStrLn stdout "hello\n"
hello
Prelude IO>
</screen>

      <para>(注意: <literal>:module +M</literal>の代わりに<literal>import M</literal>を使うこともできる。また、<literal>:module</literal>は<literal>:m</literal>に短縮できる)<literal>:module</literal>コマンドの完全な構文は次の通り。</para>

<screen>
:module <optional>+|-</optional> <optional>*</optional><replaceable>mod<subscript>1</subscript></replaceable> ... <optional>*</optional><replaceable>mod<subscript>n</subscript></replaceable>
</screen>

      <para><literal>+</literal>を使えばモジュールが現在のスコープに加えられ、<literal>-</literal>では削除される。<literal>+</literal>も<literal>-</literal>もない場合は、指定されたモジュール群がそのままで現在のスコープになる。この形式を使って、しかも<literal>Prelude</literal>を含めなかった場合、GHCiは<literal>Prelude</literal>が実は必要とされていると推定し、それを追加することに注意せよ。(<literal>Prelude</literal>が必要ない場合は、<literal>:m -Prelude</literal>で削除すれば良い)。</para>

      <para><literal>:load</literal>コマンドが実行されると、直近にロードされた「ターゲット」モジュールがスコープとして自動的に設定される。このとき、可能なら<literal>*</literal>形式が使われる。例えば、<literal>:load foo.hs bar.hs</literal>と入力したとき、<filename>bar.hs</filename>には<literal>Bar</literal>というモジュールがあるとすると、スコープは、<literal>Bar</literal>が解釈実行されているなら<literal>*Bar</literal>になり、<literal>Bar</literal>がコンパイル済みなら<literal>Prelude Bar</literal>になる。(GHCiは<literal>Prelude</literal>が指定されておらず、しかも<literal>*</literal>形式のモジュールが一つもないとき、自動的に<literal>Prelude</literal>を付け加える)</para>

      <para>複数のモジュールがスコープにあるとき、特に複数の<literal>*</literal>形式のモジュールがあるときは、名前の衝突が起こりやすい。Haskellでは、名前の衝突は曖昧な識別子が使われたときのみ報告されると定められており、GHCiもプロンプトで入力される式についてこれに倣っている。</para>

      <para>
        ヒント: GHCiはスコープにある名前についてタブ補完を行う。例えば、GHCiを起動して<literal>J&lt;tab&gt;</literal>と打つと、GHCiはそれを&ldquo;<literal>Just </literal>&rdquo;に展開する。
      </para>

      <sect3>
        <title><literal>:module</literal>と<literal>:load</literal></title>

        <para><literal>:module</literal>と<literal>:load</literal>は似たようなことをするように思えるかもしれない。どちらも、モジュールをスコープに入れるのに使うことができる。しかし、この二つには明確な違いがある。GHCiは、以下の二つのモジュール集合を意識する。</para>

        <itemizedlist>
          <listitem>
            <para>現在<emphasis>ロードされている</emphasis>モジュールの集合。この集合は、<literal>:load</literal>、<literal>:add</literal>、<literal>:reload</literal>によって変更される。
            </para>
          </listitem>
          <listitem>
            <para>現在<emphasis>スコープにある</emphasis>モジュールの集合。この集合は<literal>:module</literal>によって変更される。また、<literal>:load</literal>、<literal>:add</literal>、<literal>:reload</literal>の後に自動的に設定される</para>
          </listitem>
        </itemizedlist>

        <para>ロードされていないモジュールをスコープに入れることはできない。新しいモジュールをロードするために<literal>:module</literal>を使おうとすると「<literal>module M is not loaded</literal>」というメッセージが表示されるのはこのためである。</para>
      </sect3>

      <sect3 id="ghci-import-qualified">
	<title>修飾名</title>

        <para>手間をすこし省くことができるように、GHCiのプロンプトは、全てのパッケージの全てのモジュールと、現在GHCiにロードされている全てのモジュールについて、暗黙の<literal>import qualified</literal>宣言があるかのように振る舞う。これは<option>-fno-implicit-import-qualified</option><indexterm><primary><option>-fno-implicit-import-qualified</option></primary></indexterm>というフラグで無効にできる。</para>

      </sect3>

      <sect3>
        <title><literal>:main</literal>コマンドと<literal>:run</literal>コマンド</title>

        <para>
          プログラムがコンパイルされ実行されるとき、コマンド行引数にアクセスするために<literal>getArgs</literal>関数を使うことができる。しかし、ghciでテストをしているときは、コマンド行引数を単純に<literal>main</literal>関数の引数として渡すことはできない。<literal>main</literal>関数は直接には引数をとらないからである。
        </para>

        <para>
          その代わり、<literal>:main</literal>コマンドを使うことができる。これは、とにかくスコープにある<literal>main</literal>を、引数がコマンド行から渡されたのと同じようにして実行する。例えば、次のようにである。
        </para>

<screen>
Prelude> let main = System.Environment.getArgs >>= print
Prelude> :main foo bar
["foo","bar"]
</screen>

        <para>スペースなどの文字を含む引数は、引用符に入れることができ、Haskellの文字列と同じように扱われる。また、Haskellのリスト構文をそのまま使うこともできる。</para>

<screen>
Prelude> :main foo "bar baz"
["foo","bar baz"]
Prelude> :main ["foo", "bar baz"]
["foo","bar baz"]
</screen>

        <para>最後に、<literal>-main-is</literal>フラグや<literal>:run</literal>コマンドを使えば、その他の関数を呼ぶことができる。</para>

<screen>
Prelude> let foo = putStrLn "foo" >> System.Environment.getArgs >>= print
Prelude> let bar = putStrLn "bar" >> System.Environment.getArgs >>= print
Prelude> :set -main-is foo
Prelude> :main foo "bar baz"
foo
["foo","bar baz"]
Prelude> :run bar ["foo", "bar baz"]
bar
["foo","bar baz"]
</screen>

      </sect3>
    </sect2>
  

    <sect2>
      <title><literal>it</literal>という変数</title>
      <indexterm><primary><literal>it</literal></primary>
      </indexterm>
      
      <para>式(正確には束縛文でない文)がプロンプトに入力されると、GHCiはその値を暗黙のうちに変数<literal>it</literal>に束縛する。例えば、次のようにである。</para>
<screen>
Prelude> 1+2
3
Prelude> it * 2
6
</screen>
    <para>実際に何が起こっているかというと、GHCiは入力された式を型検査し、もし<literal>IO</literal>型でなければ、それを次のように変形するのである。式<replaceable>e</replaceable>は
<screen>
let it = <replaceable>e</replaceable>;
print it
</screen>
    になり、これがIO動作として実行される。</para>

    <para>そのため、元の式の型は<literal>Show</literal>のインスタンスでなければならない。そうでなければ、GHCiは次のように文句を言う。</para>

<screen>
Prelude&gt; id

&lt;interactive&gt;:1:0:
    No instance for (Show (a -&gt; a))
      arising from use of `print' at &lt;interactive&gt;:1:0-1
    Possible fix: add an instance declaration for (Show (a -> a))
    In the expression: print it
    In a 'do' expression: print it
</screen>

    <para>このエラーメッセージから、内部でどういう変換が起こっているかを少しうかがい知ることができる。</para>

      <para>式の型がなんらかの<literal>a</literal>について<literal>IO a</literal>である場合は、<literal>it</literal>は<literal>IO</literal>動作の結果(これの型は<literal>a</literal>である)に束縛される。例えば、以下。</para>
<screen>
Prelude> Time.getClockTime
Wed Mar 14 12:23:13 GMT 2001
Prelude> print it
Wed Mar 14 12:23:13 GMT 2001
</screen>

      <para>IO型の<replaceable>e</replaceable>についてなされる変換は、
<screen>
it &lt;- <replaceable>e</replaceable>
</screen>
      である。
      </para>

      <para>新しい式を評価するたびに<literal>it</literal>は新しい値で覆い隠され、<literal>it</literal>の古い値は失われることに注意。</para>
    </sect2>

    <sect2 id="extended-default-rules">
      <title>GHCiにおける型のデフォルト化</title>
    <indexterm><primary>Type default</primary></indexterm>
    <indexterm><primary><literal>Show</literal> class</primary></indexterm>
      <para>
      次のGHCiセッションを考えてみよう。
<programlisting>
  ghci> reverse []
</programlisting>
      GHCiは何をするべきか。厳密に言うと、このプログラムは曖昧である。<literal>show (reverse [])</literal>(ここでGHCiが計算するのはこれである)の型は<literal>Show a =&gt; a</literal>であり<!-- 訳注 これは誤り-->、これをどのように表示するかは<literal>a</literal>の型に依存する。例えば、
<programlisting>
  ghci> (reverse []) :: String
  ""
  ghci> (reverse []) :: [Int]
  []
</programlisting>
    のようになる。しかし、利用者が型を指定しなければならないというのは面倒なので、GHCiはHaskellの型デフォルト化規則(Haskell 98 改訂レポートのセクション4.3.4)を以下のように拡張している。標準の規則では、個々の型変数<literal>a</literal>について制約の集まり<literal>(C1 a, C2 a, ..., Cn a)</literal>を考え、次の条件が満たされたとき、この型変数をデフォルト化する。
    <orderedlist>
	    <listitem><para>型変数<literal>a</literal>が他のどの制約にも現れない。</para></listitem>
            <listitem><para><literal>Ci</literal>が全て標準のクラスである。</para></listitem>
            <listitem><para><literal>Ci</literal>のうち、少なくとも一つが数値クラスである。</para></listitem>
    </orderedlist>
GHCiのプロンプトでは、あるいはGHCで<literal>-XExtendedDefaultRules</literal>フラグが与えられている場合、以下の変更が適用される。
	<itemizedlist>
            <listitem><para>上の規則2が次のように緩和される: <literal>Ci</literal>が<emphasis>全て</emphasis>単引数の型クラスである。</para></listitem>
            <listitem><para>上の規則3が次のように緩和される: <literal>Ci</literal>のうち、少なくとも一つが数値クラスである<emphasis>か、<literal>Show</literal>であるか、<literal>Eq</literal>であるか、<literal>Ord</literal>である</emphasis>。</para></listitem>
            <listitem><para>単位型<literal>()</literal>が、型のデフォルト化の際に通常試す型のリストの先頭に追加される。</para></listitem>
      </itemizedlist>
    最後の点は、例えば、このプログラムに影響する。
<programlisting>
main :: IO ()
main = print def

instance Num ()

def :: (Num a, Enum a) => a
def = toEnum 0
</programlisting>
    これが、<literal>0</literal>ではなく<literal>()</literal>を表示する。型が<literal>Integer</literal>でなく<literal>()</literal>にデフォルト化されるためである。</para>
   <para>
    この変更の理由は、これによって<literal>IO a</literal>の動作が<literal>IO ()</literal>にデフォルト化されるので、ghciがこれらを走らせたときに結果を表示する必要がなくなることである。これは<literal>printf</literal>の場合に特に重要である。<literal>printf</literal>には<literal>IO a</literal>を返すインスタンスがあるが、これが返せるのは<literal>undefined</literal>だけである。(インスタンスがこの型なのは、printfがクラスシステムの拡張を必要としないようにである)。このため、もし型が<literal>Integer</literal>にデフォルト化されるなら、ghciはprintfを実行する時にエラーを発生させることになる。</para>
    </sect2>
  </sect1>

  <sect1 id="ghci-debugger">
    <title>GHCiデバッガ</title>
    <indexterm><primary>debugger</primary><secondary>in GHCi</secondary>
    </indexterm>

    <para>GHCiは単純な命令的スタイルのデバッガを搭載していて、実行中の計算を停めて変数の値を確かめることができる。このデバッガはGHCiに統合されており、デフォルトで有効になっている。デバッグ機能を使うのにフラグは必要ない。一つ、重要な制限があって、ブレークポイントとステップ実行は解釈実行されているモジュールでしか使えない。コンパイル済みコードはデバッガからは見えない<footnote><para>パッケージにはコンパイル済みコードしか入っていないので、パッケージをデバッグするにはそのソースを見つけてきて直接ロードするしかないことに注意。</para></footnote>。</para>

    <para>このデバッガは以下のものを提供する。
    <itemizedlist>
        <listitem>
          <para>プログラム中の関数定義や式に<firstterm>ブレークポイント</firstterm>を設定する能力。その関数が呼ばれたとき、あるいはその式が評価されたとき、GHCiは実行を中断してプロンプトに戻る。そこで、実行を続ける前に、局所変数の値を調べることができる。</para>
        </listitem>
        <listitem>
          <para><firstterm>ステップ実行</firstterm>ができる。評価器は、簡約をだいたい一回行うごとに実行を一時停止し、局所変数を調べることができるようにする。これはプログラムのあらゆる地点にブレークポイントを設定するのと同様である。</para>
        </listitem>
        <listitem>
          <para>実行を<firstterm>追跡モード</firstterm>で行うことができる。この場合、評価器は、発生した評価ステップをすべて記憶するが、実際のブレークポイントに達するまで実行を停止しない。一旦停止した後で、この評価ステップの履歴を調べることができる。</para>
        </listitem>
        <listitem>
          <para>例外(パターン照合の失敗や<literal>error</literal>など)をブレークポイントとして扱うことができる。これによって、プログラム中の例外の発生源を突き止めることが容易になる。</para>
        </listitem>
      </itemizedlist>
    </para>
      
    <para>現在のところ、&ldquo;スタックトレース&rdquo;を得る手段は提供されていないが、追跡と履歴の機能が有用な次善策になっていて、これらで十分エラー発生時の状況を知ることができることがしばしばある。例えば、例外が投げられたときに自動的にブレークするようにすることが可能で、これは例外がコンパイル済みコードで投げられた場合にも有効である。(<xref linkend="ghci-debugger-exceptions"/>を見よ)</para>
      
    <sect2 id="breakpoints">
      <title>ブレークポイントと変数内容の表示</title>
      
      <para>全体を通した例としてクイックソートを使おう。コードは以下の通り。</para>

<programlisting>
qsort [] = [] 
qsort (a:as) = qsort left ++ [a] ++ qsort right
  where (left,right) = (filter (&lt;=a) as, filter (&gt;a) as)

main = print (qsort [8, 4, 0, 3, 1, 23, 11, 18])
</programlisting>

      <para>まず、このモジュールをGHCiにロードする。</para>

<screen>
Prelude> :l qsort.hs
[1 of 1] Compiling Main             ( qsort.hs, interpreted )
Ok, modules loaded: Main.
*Main>
      </screen>       

      <para>ここで、qsortの二番目の等式の右辺にブレークポイントを設定する。</para>

<programlisting>
*Main> :break 2
Breakpoint 0 activated at qsort.hs:2:15-46
*Main>
</programlisting>
      
      <para><literal>:break 2</literal>というコマンドは、直近にロードされたモジュール(この場合<literal>qsort.hs</literal>)の2行目にブレークポイントを設定するものである。詳しく言うと、その行にある完全な部分式のうちもっとも左側にあるものが選ばれる。この場合<literal>(qsort left ++ [a] ++ qsort right)</literal>である。</para>

      <para>さて、プログラムを実行してみる。</para>

<programlisting>
*Main> main
Stopped at qsort.hs:2:15-46
_result :: [a]
a :: a
left :: [a]
right :: [a]
[qsort.hs:2:15-46] *Main>
</programlisting>

      <para>ブレークポイントのところで実行が中断した。プロンプトが変わって、現在ブレークポイントで停止していることと、その場所が<literal>[qsort.hs:2:15-46]</literal>であることを示している。場所をさらに明確にするには、<literal>:list</literal>コマンドが使える。</para>

<programlisting>
[qsort.hs:2:15-46] *Main> :list 
1  qsort [] = [] 
2  qsort (a:as) = qsort left ++ [a] ++ qsort right
3    where (left,right) = (filter (&lt;=a) as, filter (&gt;a) as)
</programlisting>

      <para><literal>:list</literal>コマンドは、現在のブレークポイントのまわりのコードを表示する。出力デバイスが対応しているなら、注目している部分式が太字で強調される。</para>

      <para>ブレークポイントの置かれた式の各自由変数(<literal>a</literal>と<literal>left</literal>と<literal>right</literal>)について、その束縛がGHCiに用意されている<footnote><para>元々、自由変数だけでなくスコープにあるあらゆる変数の束縛を用意していたが、これが性能にかなりの影響を与えることが分かった。そのため、現在は自由変数のみに制限している。</para></footnote>。さらに、この式の結果についての束縛(<literal>_result</literal>)も用意される。これらの変数は、GHCi上で普通に定義する変数と同じである。つまり、プロンプトに打ち込む式の中で使ったり、<literal>:type</literal>を使って型を問うたりできる。ただし、一つ重要な相違点があって、これらの変数は不完全な型しか持たないかもしれない。例えば、<literal>left</literal>の値を表示しようとすると次のようになる。</para>

<screen>
[qsort.hs:2:15-46] *Main> left

&lt;interactive&gt;:1:0:
    Ambiguous type variable `a' in the constraint:
      `Show a' arising from a use of `print' at &lt;interactive&gt;:1:0-3
    Cannot resolve unknown runtime types: a
    Use :print or :force to determine these types
</screen>

      <para>原因は、<literal>qsort</literal>が多相関数であって、GHCiが型情報を実行時に保持しないので、型変数に関係した自由変数の実行時の型を決定することができないことだ。これにより、プロンプトで<literal>left</literal>を表示しようとすると、GHCiは<literal>Show</literal>のどのインスタンスを使うべきか判断できず、上のエラーを出力する。</para>

      <para>幸いにも、デバッガには<literal>:print</literal>という汎用印字コマンドが搭載されている。このコマンドで、変数の実行時の値を調べ、その型を再構築することができる。これを<literal>left</literal>に対して試してみると次のようになる。</para>

<screen>
[qsort.hs:2:15-46] *Main> :set -fprint-evld-with-show
[qsort.hs:2:15-46] *Main> :print left
left = (_t1::[a])
</screen>

      <para>これでは大したことは分からない。何が起きたかというと、<literal>left</literal>が未評価の計算(中断された計算、<firstterm>サンク</firstterm>ともいう)に束縛されており、しかも<literal>:print</literal>は決して評価を強制しないのだ。これは、ブレークポイントで<literal>:print</literal>を使って値を調べるとき、望ましくない副作用を起こさずに済むようにするためだ。評価を強制しないので、プログラムが通常と異なる結果を与えることもないし、例外が発生することもないし、無限ループや別のブレークポイント(<xref linkend="nested-breakpoints"/>)に遭遇することもない。<literal>:print</literal>は、サンクをforceする代わりに、各サンクをアンダースコアから始まる新しい変数(ここでは<literal>_t1</literal>)に束縛する。</para>

        <para><literal>-fprint-evld-with-show</literal>というフラグは、<literal>:print</literal>が可能な限り既存の<literal>Show</literal>インスタンスを再利用するようにするものである。これが起こるのは、対象の変数の中身が完全に評価済みの時だけである。</para>

        <para>変数の評価状態を変えても構わない場合、<literal>:print</literal>の代わりに<literal>:force</literal>を使うことができる。<literal>:force</literal>コマンドは、サンクに遭遇する度に評価を強制するが、この点を除いて<literal>:print</literal>とまったく同じように振る舞う。</para>

<screen>
[qsort.hs:2:15-46] *Main> :force left
left = [4,0,3,1]
</screen>

      <para>ここで、<literal>:force</literal>が<literal>left</literal>の実行時の値を調べたので、この型が再構築された。この再構築の結果は次のようにして見ることができる。</para>

<screen>
[qsort.hs:2:15-46] *Main> :show bindings
_result :: [Integer]
a :: Integer
left :: [Integer]
right :: [Integer]
_t1 :: [Integer]
</screen>

      <para><literal>left</literal>の型が分かっただけでなく、他の部分的な型もすべて解決されている。よって、例えば<literal>a</literal>の値を問い合わせることができる。</para>

<screen>
[qsort.hs:2:15-46] *Main> a
8
</screen>
      
      <para>式全体の評価を<literal>:force</literal>で強制するのでなく、個々のサンクを評価したい場合、Haskellの<literal>seq</literal>が便利かもしれない。例えば以下のように使う。</para>

<screen>
[qsort.hs:2:15-46] *Main> :print right
right = (_t1::[Integer])
[qsort.hs:2:15-46] *Main> seq _t1 ()
()
[qsort.hs:2:15-46] *Main> :print right
right = 23 : (_t2::[Integer])
</screen>

      <para>ここでは、サンク<literal>_t1</literal>だけを評価し、これでリストの頭部が分かった。尾部は別のサンクで、<literal>_t2</literal>に束縛された。ここでは<literal>seq</literal>関数は少々使いにくいので、<literal>:def</literal>を使ってもっと良いインタフェースをつけると良いかもしれない。(後は読者への練習問題としよう！)</para>

      <para>最後に、現在の実行を再開することができる。</para>

<screen>
[qsort.hs:2:15-46] *Main> :continue
Stopped at qsort.hs:2:15-46
_result :: [a]
a :: a
left :: [a]
right :: [a]
[qsort.hs:2:15-46] *Main> 
</screen>

      <para>実行は、前に停止した点から再開し、同じブレークポイントで再び停止した。</para>


      <sect3 id="setting-breakpoints">
        <title>ブレークポイントを設定する</title>

        <para>ブレークポイントを設定する方法はいくつかある。おそらくもっとも簡単な方法は最上位の関数の名前を使うことだろう。</para>

<screen>
   :break <replaceable>identifier</replaceable>
</screen>

      <para><replaceable>identifier</replaceable>は最上位の関数の名前(修飾名も使える)である。ただし、この関数の定義されているモジュールが、現在GHCiにロードされており、さらに解釈実行されていなければならない。ブレークポイントは関数の本体、関数が完全に適用されたがパターン照合が行われる前の点に設定される。</para>

      <para>行番号(と列番号)でブレークポイントを設定することもできる。</para>

<screen>
   :break <replaceable>line</replaceable>
   :break <replaceable>line</replaceable> <replaceable>column</replaceable>
   :break <replaceable>module</replaceable> <replaceable>line</replaceable>
   :break <replaceable>module</replaceable> <replaceable>line</replaceable> <replaceable>column</replaceable> 
</screen>

      <para>ブレークポイントを特定の行に設定する場合、GHCiは、その行で始まりその行で終わる部分式の中でもっとも左側にあるものを選ぶ。二つの完全な部分式が同じカラムから始まっているなら長い方が選ばれる。その行に完全な部分式が無い場合、その行で始まっている部分式の中でもっとも左側にあるものが選ばれる。それも失敗したら、その行を一部か全部覆う式の中でもっとも右側にあるものが選ばれる。</para>

      <para>ブレークポイントを特定の行の特定のカラムに設定する場合、GHCiはその地点を含む式の中で最小のものを選ぶ。注意: GHCは、TAB文字を、現れた場所に関わらず幅1とみなす。言い換えれば、カラム数を数えるのではなく文字を数えている。これはある種のエディタの振る舞いと整合するが、そうでないエディタもある。最善なのはそもそもソースコード中でタブ文字を使わないことである。(<xref linkend="options-sanity"/>中の<option>-fwarn-tabs</option>を見よ)</para>

      <para>モジュールが省略された場合、直近にロードされたモジュールが使われる。</para>

      <para>ブレークポイントを設定できない部分式もある。単一の変数は通常ブレークポイント位置とはみなされない。(ただし、その変数が関数定義かラムダかcaseの選択肢の右辺である場合は除く)。大まかに、ブレークポイントであるのは、全ての簡約基と、関数やラムダの本体、caseの選択肢、束縛文である。通常let式はブレークポイントでないが、その本体は常にブレークポイントである。そのletで束縛された変数の値を調べたいと思うのが普通だからである。</para>

      </sect3>
      <sect3>
        <title>ブレークポイントを一覧・削除する</title>

        <para>現在有効にされているブレークポイントの一覧は<literal>:show&nbsp;breaks</literal>で表示できる。</para>
<screen>
*Main> :show breaks
[0] Main qsort.hs:1:11-12
[1] Main qsort.hs:2:15-46
</screen>

        <para>ブレークポイントを削除するには、<literal>:show&nbsp;breaks</literal>コマンドの出力にある数字を与えて<literal>:delete</literal>コマンドを使えば良い。</para>
<screen>
*Main> :delete 0
*Main> :show breaks
[1] Main qsort.hs:2:15-46
</screen>        

        <para>全てのブレークポイントを一度に削除するには、<literal>:delete *</literal>とすれば良い。</para>

    </sect3>
    </sect2>

    <sect2 id="single-stepping">
      <title>ステップ実行</title>

      <para>ステップ実行は、プログラムの実行を可視化する偉大な方法であり、バグの原因を同定する手段としても有用である。<literal>:step</literal>コマンドを使うと、プログラム中の全てのブレークポイントが有効にされ、次のブレークポイントに達するまで実行される。<literal>:steplocal</literal>とすれば、現在のトップレベル関数の中にあるブレークポイントのみ有効にする。同様に、<literal>:stepmodule</literal>とすると現在のモジュール中にあるブレークポイントのみ有効にする。例えば以下のようになる。</para>

<screen>
*Main> :step main
Stopped at qsort.hs:5:7-47
_result :: IO ()
</screen>

      <para><literal>:step <replaceable>expr</replaceable></literal>コマンドは、<replaceable>expr</replaceable>のステップ実行を開始する。<replaceable>expr</replaceable>が省略された時は、現在のブレークポイントからステップ実行する。<literal>:stepover</literal>も同様に動作する。</para>

      <para>ステップ実行中には<literal>:list</literal>が特に便利で、自分がどこにいるか知ることができる。</para>

<screen>
[qsort.hs:5:7-47] *Main> :list
4  
5  main = print (qsort [8, 4, 0, 3, 1, 23, 11, 18])
6  
[qsort.hs:5:7-47] *Main>
</screen>

      <para>実際、GHCiには、ブレークポイントに達したときに決まったコマンドを実行する方法があるので、自動的に<literal>:list</literal>するようにできる。</para>

<screen>
[qsort.hs:5:7-47] *Main> :set stop :list
[qsort.hs:5:7-47] *Main> :step
Stopped at qsort.hs:5:14-46
_result :: [Integer]
4  
5  main = print (qsort [8, 4, 0, 3, 1, 23, 11, 18])
6  
[qsort.hs:5:14-46] *Main>
</screen>
    </sect2>

    <sect2 id="nested-breakpoints">
      <title>ブレークポイントのネスト</title>
      <para>GHCiがブレークポイントで停止したときに、プロンプトに入力された式が別のブレークポイントを起動した場合、この新しいブレークポイントが「現在の」ブレークポイントになり、古いものはスタックに保存される。このようにして、任意の数のブレークポイント文脈を作り上げることができる。例えば以下のように。</para>

<screen>
[qsort.hs:2:15-46] *Main> :st qsort [1,3]
Stopped at qsort.hs:(1,0)-(3,55)
_result :: [a]
... [qsort.hs:(1,0)-(3,55)] *Main>
</screen>

      <para>前に設定した2行目のブレークポイントで停止したところで、<literal>:step qsort [1,3]</literal>として新しい評価を開始した。この新しい評価は一ステップの後に(<literal>qsort</literal>の定義で)停止した。ここで、プロンプトが変わって先頭に<literal>...</literal>が付き、現在のブレークポイントの他に保存されたブレークポイントがあることを示している。この文脈スタックを見るには、<literal>:show context</literal>を使えば良い。</para>

<screen>
... [qsort.hs:(1,0)-(3,55)] *Main> :show context
--> main
  Stopped at qsort.hs:2:15-46
--> qsort [1,3]
  Stopped at qsort.hs:(1,0)-(3,55)
... [qsort.hs:(1,0)-(3,55)] *Main>
</screen>

        <para>現在の評価を放棄するには、<literal>:abandon</literal>が使える。</para>

<screen>
... [qsort.hs:(1,0)-(3,55)] *Main> :abandon
[qsort.hs:2:15-46] *Main> :abandon
*Main>
</screen>
    </sect2>

    <sect2 id="ghci-debugger-result">
      <title><literal>_result</literal>という変数</title>
      <para>ブレークポイントで停止したときやステップ実行するとき、GHCiは<literal>_result</literal>という変数を用意して、現在注目されている式の結果に束縛する。<literal>_result</literal>の値はおそらくまだ存在しない(その評価を止めたのだから)が、その評価を強制することはできる。その型が既知でshowできるなら、<literal>_result</literal>とプロンプトに入力するだけで表示できる。ただし、これを行うに当たって警告が一つある。<literal>_result</literal>を評価すると、さらにブレークポイントを起動する可能性が高いということだ。特に、<literal>:step</literal>でなく真のブレークポイントで停止していたなら、このブレークポイントが最初に起動する。このため、<literal>_result</literal>を評価する時には、おそらく即座に<literal>:continue</literal>を発行する必要がある。別の方法として、<literal>:force</literal>はブレークポイントを無視するので、これを使うこともできる。</para>
    </sect2>

    <sect2 id="tracing">
      <title>追跡と履歴</title>

      <para>プログラムをデバッグしている時にしばしば問われる問いの一つに、「どうやってここに来たんだ？」というものがある。伝統的な命令的デバッガは通常何らかのスタックトレースの機能を持っていて、それを使ってアクティブな関数呼び出しのスタック(字句的呼び出しスタックと呼ばれることもある)を確認することができる。このスタックによって、現在の地点に至るまでのコード上の道のりが分かる。残念なことに、これをHaskellで用意するのは難しい。正格な言語と違って、実行は深さ優先ではなく必要に応じて進むからである。GHCの実行エンジンにある「スタック」は字句的呼び出しスタックとは大きく異なる。理想的には、GHCが、この動的な呼び出しスタックに加えて、別に字句的呼び出しスタックを管理すれば良く、事実、我々のプロファイルシステム(<xref linkend="profiling"/>)はまさにこれを行っており、他のHaskellデバッガにもこれをしているものがある。しかし、現在のところ、GHCiは字句的呼び出しスタックを管理しない。(克服せねばならない技術的困難がいくつかある)。代わりに、ブレークポイントから直前の評価ステップに戻る方法を用意している。これは要するにステップ実行を逆向きにするのと同じで、多くの場合「どうやってここに来たんだ？」という疑問を解決するのに十分な情報を与える。</para>

      <para>追跡機能を使うには、式を<literal>:trace</literal>コマンドで評価する。例えば、<literal>qsort</literal>のベースケースにブレークポイントを設定する。</para>
<screen>
*Main&gt; :list qsort
1  qsort [] = [] 
2  qsort (a:as) = qsort left ++ [a] ++ qsort right
3    where (left,right) = (filter (&lt;=a) as, filter (&gt;a) as)
4  
*Main&gt; :b 1
Breakpoint 1 activated at qsort.hs:1:11-12
*Main&gt; 
</screen>

      <para>そして、小さな<literal>qsort</literal>を追跡付きで実行する。</para>

<screen>
*Main> :trace qsort [3,2,1]
Stopped at qsort.hs:1:11-12
_result :: [a]
[qsort.hs:1:11-12] *Main>
</screen>

      <para>これで、評価ステップの履歴を確かめることができる。</para>

<screen>
[qsort.hs:1:11-12] *Main> :hist
-1  : qsort.hs:3:24-38
-2  : qsort.hs:3:23-55
-3  : qsort.hs:(1,0)-(3,55)
-4  : qsort.hs:2:15-24
-5  : qsort.hs:2:15-46
-6  : qsort.hs:3:24-38
-7  : qsort.hs:3:23-55
-8  : qsort.hs:(1,0)-(3,55)
-9  : qsort.hs:2:15-24
-10 : qsort.hs:2:15-46
-11 : qsort.hs:3:24-38
-12 : qsort.hs:3:23-55
-13 : qsort.hs:(1,0)-(3,55)
-14 : qsort.hs:2:15-24
-15 : qsort.hs:2:15-46
-16 : qsort.hs:(1,0)-(3,55)
&lt;end of history&gt;
</screen>

      <para>履歴中の特定のステップを調べるには、<literal>:back</literal>を使う。</para>

<screen>
[qsort.hs:1:11-12] *Main> :back
Logged breakpoint at qsort.hs:3:24-38
_result :: [a]
as :: [a]
a :: a
[-1: qsort.hs:3:24-38] *Main> 
</screen>

      <para>履歴中の各ステップで局所変数が保存されており、通常同様に調べることができる。また、プロンプトが変わって、<literal>-1</literal>と、履歴中の最初のステップを調べていることを示している。<literal>:forward</literal>コマンドを使うと履歴中を前方に移動することができる。</para>

      <para><literal>:trace</literal>コマンドには式を与えても与えなくても良い。与えなかった場合、<literal>:step</literal>の場合と同様、追跡は現在のブレークポイントから始まる。</para>

      <para>履歴は<literal>:trace</literal>を使ったときしか記録されない。これは、全てのブレークポイントを履歴に記録することで性能が二倍以上悪化することが分かったからである。GHCiは最後の50ステップを履歴に記憶する。(将来、これを可変にするかもしれない)</para>
    </sect2>

    <sect2 id="ghci-debugger-exceptions">
      <title>例外をデバッグする</title>
      <para>もう一つデバッグ中によく発生する疑問として、「この例外はどこから来たんだ？」というものがある。<literal>error</literal>や<literal>head []</literal>によって発生する例外には文脈情報が付属していない。プログラム中のどの<literal>head</literal>の呼び出しがエラーの原因になったかを調べるのは骨の折れる作業であり、通常<literal>Debug.Trace.trace</literal>を使ったり、プロファイル付きでコンパイルして<literal>+RTS -xc</literal>(<xref linkend="prof-time-options"/>を見よ)を使ったりすることになる。</para>

      <para>GHCiデバッガの提供する方法を使うと、このようなエラーを素早く、かつコードを再コンパイルすることなしに突き止めることが、うまくすればできるかもしれない。一つの方法は、ソースコード中で例外を投げた場所にブレークポイントを設定し、<literal>:trace</literal>と<literal>:history</literal>を使って文脈を把握することだろう。しかし、<literal>head</literal>はライブラリ中にあり、そこに直接ブレークポイントを設定する訳にはいかない。このために、GHCiには<literal>-fbreak-on-exception</literal>フラグが用意されていて、これを使うと、例外が投げられた時に評価器が停止するようにできる。<literal>-fbreak-on-error</literal>も同様だが、これは例外が捕捉されなかった場合のみ停止する。例外によって停止したときは、GHCiはちょうどブレークポイントに当ったのと同じように振る舞うが、違いとして、ソースコード中の位置が表示されない。したがって、<literal>:trace</literal>と組み合わせて、例外が発生する直前のステップを記録するようにしないと、これらのコマンドはあまり有用でない。例えば次のように。</para>

<screen>
*Main> :set -fbreak-on-exception
*Main> :trace qsort ("abc" ++ undefined)
&ldquo;Stopped at &lt;exception thrown&gt;
_exception :: e
[&lt;exception thrown&gt;] *Main&gt; :hist
-1  : qsort.hs:3:24-38
-2  : qsort.hs:3:23-55
-3  : qsort.hs:(1,0)-(3,55)
-4  : qsort.hs:2:15-24
-5  : qsort.hs:2:15-46
-6  : qsort.hs:(1,0)-(3,55)
&lt;end of history&gt;
[&lt;exception thrown&gt;] *Main&gt; :back
Logged breakpoint at qsort.hs:3:24-38
_result :: [a]
as :: [a]
a :: a
[-1: qsort.hs:3:24-38] *Main&gt; :force as
*** Exception: Prelude.undefined
[-1: qsort.hs:3:24-38] *Main&gt; :print as
as = 'b' : 'c' : (_t1::[Char])
</screen>

      <para>投げられた例外そのものは、<literal>_exception</literal>という新しい変数に束縛される。</para>

      <para>例外発生時にブレークする機能は、プログラムが無限ループしているとき、それが何をしているかを調べるのに特に便利である。単にCtrl-Cを叩いて、履歴を見て、何が起こっていたかを調べれば良い。</para>
    </sect2>

    <sect2><title>例: 関数を調べる</title>
      <para>
        このデバッガを使って関数値を調べることは可能である。ブレークポイントで停止しており、スコープに関数があるとき、デバッガでその関数のソースコードを表示させることはできない。しかし、それを何らかの引数に適用して結果を観察することで、いくらかの情報を得ることはできる。
      </para>

      <para>
        束縛が多相的な場合、この手順は少し複雑になる。例を使って示すことにしよう。単純のために、良く知られた<literal>map</literal>関数を使う。
<programlisting>
import Prelude hiding (map)

map :: (a->b) -> [a] -> [b]
map f [] = []
map f (x:xs) = f x : map f xs
</programlisting>
      </para>

      <para>
        <literal>map</literal>にブレークポイントを設定し、呼ぶ。
<screen>
*Main> :break 5
Breakpoint 0 activated at  map.hs:5:15-28
*Main> map Just [1..5]
Stopped at map.hs:(4,0)-(5,12)
_result :: [b]
x :: a
f :: a -> b
xs :: [a]
</screen>
GHCiの伝えるところによって、<literal>f</literal>がスコープにあることが分かる。しかし、これの型はまだ完全には分かっていないので、これを何か引数に適用することはできない。それでも、最初の引数の型が<literal>x</literal>の型と同じで、結果の型が<literal>_result</literal>の型と関係していることは分かる。(訳注: 原文は、Nevertheless, observe that the type of its first argument is the
      same as the type of <literal>x</literal>, and its result type is shared
        with <literal>_result</literal>.) </para>

      <para>
        先に示した(<xref linkend="breakpoints"/>)ように、このデバッガはある程度賢く作ってあって、<literal>x</literal>や<literal>_result</literal>の型が解明されたときには<literal>f</literal>の型を更新することができる。よって、この例ですべきことは、<literal>x</literal>を少しだけforceして、その型と、ひいては<literal>f</literal>の引数部分の型を復元することである。
<screen>
*Main> seq x ()
*Main> :print x
x = 1
</screen>
      </para>
      <para>
        これで、<literal>x</literal>の型が再構築され、それによって<literal>f</literal>の型も再構築されたことを確認できる。</para>
<screen>
*Main> :t x
x :: Integer
*Main> :t f
f :: Integer -> b
</screen>
      <para>
        この時点で、好きなInteger型の引数にfを適用して、その結果を観察することができる。
<screen><![CDATA[
*Main> let b = f 10
*Main> :t b
b :: b
*Main> b
<interactive>:1:0:
    Ambiguous type variable `b' in the constraint:
      `Show b' arising from a use of `print' at <interactive>:1:0
*Main> :p b
b = (_t2::a)
*Main> seq b ()
()
*Main> :t b
b :: a
*Main> :p b
b = Just 10
*Main> :t b
b :: Maybe Integer
*Main> :t f
f :: Integer -> Maybe Integer
*Main> f 20
Just 20
*Main> map f [1..5]
[Just 1, Just 2, Just 3, Just 4, Just 5]
]]></screen>
      最初の<literal>f</literal>の適用では、<literal>f</literal>の結果の型を復元するために、型の再構築をもう少し行わなければならなかった。しかし、それ以降は、<literal>f</literal>を通常の方法で自由に使うことができる。
     </para>
    </sect2>

    <sect2><title>制約</title>
      <itemizedlist>
        <listitem>
          <para>ブレークポイントで停止したとき、既に評価中の変数を評価しようとすると、二番目の評価はハングする。この理由は、その変数が評価中であることをGHCが知っているため、新しい評価では、先に進む前にその結果を待つが、最初の評価はブレークポイントで停止しているのだから、もちろん結果は得られない、ということにある。評価がハングしたときはCtrl-Cで中断してプロンプトに戻ることができる。</para>
          <para>これがもっともよく起こるのは、CAF(例えばmain)を評価していて、ブレークポイントで停止し、そのCAFの値を再びプロンプトで要求した場合である。</para>
        </listitem>
	<listitem><para>
          暗黙パラメタ(<xref linkend="implicit-parameters"/>)がブレークポイントで利用できるのは、明示的な型シグネチャがある場合だけである。
	</para>
        </listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="ghci-invocation">
    <title>GHCiを起動する</title>
    <indexterm><primary>invoking</primary><secondary>GHCi</secondary></indexterm>
    <indexterm><primary><option>&ndash;&ndash;interactive</option></primary></indexterm>

    <para>GHCiは<literal>ghci</literal>または<literal>ghc &ndash;&ndash;interactive</literal>というコマンドで起動される。一つまたは複数のモジュールやファイル名をコマンド行から指定することもできる。そうすると、GHCiは、プロンプトで<literal>:load <replaceable>module</replaceable></literal>と入力されたときと同じように(<xref linkend="ghci-commands" />を見よ)、指定されたモジュールやファイル(と、それらが依存するモジュール)をロードする。例えば、GHCiを起動して、プログラム(<literal>Main.hs</literal>に最上位モジュールがある)をロードするには、次のように打てば良い。</para>

<screen>
$ ghci Main.hs
</screen>

    <para>GHCが受け付けるコマンド行オプション(<xref linkend="using-ghc"/>を見よ)の大部分は対話的モードでも有効であり、そうでないオプションは大抵明らかである。</para>

    <sect2>
      <title>パッケージ</title>
      <indexterm><primary>packages</primary><secondary>with GHCi</secondary></indexterm>

      <para>大部分のパッケージ(<xref linkend="using-packages"/>を見よ)は追加のフラグを指定することなく利用可能であり、初めて必要になったときに自動的にロードされる。</para>

      <para>一方で、隠されたパッケージについては、<literal>-package</literal>フラグを使ってロードを依頼する必要がある。</para>

<screen>
$ ghci -package readline
GHCi, version 6.8.1: http://www.haskell.org/ghc/  :? for help
Loading package base ... linking ... done.
Loading package readline-1.0 ... linking ... done.
Prelude> 
</screen>

      <para>起動中のGHCiから新しいパッケージをロードするには、次のコマンドが使える。</para>

<screen>
Prelude> :set -package <replaceable>name</replaceable>
</screen>

      <para>ただし、これをするとロードされているモジュールが全て未ロードになり、<literal>Prelude</literal>に戻されることになるので注意。</para>
    </sect2>

    <sect2>
      <title>追加のライブラリ</title>
      <indexterm><primary>libraries</primary><secondary>with GHCi</secondary></indexterm>
      
      <para>追加のライブラリは、コマンド行から、通常の<literal>-l<replaceable>lib</replaceable></literal>オプションを使って指定することができる。(ここでいう<emphasis>ライブラリ</emphasis>とは、他言語のオブジェクトコードのライブラリのことである。Haskellソースのライブラリを使うことについては、<xref linkend="ghci-modules-filenames"/>を見よ)例えば、「m」ライブラリをロードするには、次のようにすれば良い。</para>

<screen>
$ ghci -lm
</screen>

      <para><literal>.so</literal>形式の共有ライブラリを使うシステムでは、実際にロードされるライブラリは<filename>lib<replaceable>lib</replaceable>.so</filename>である。GHCiは、ライブラリを探すとき、以下の場所をこの順で試す。</para>

      <itemizedlist>
	<listitem>
          <para><literal>-L<replaceable>path</replaceable></literal>コマンド行オプションで指定されたパス。</para>
	</listitem>
	<listitem>
          <para>システムの標準ライブラリ探索パス。これは、システムによっては、<literal>LD_LIBRARY_PATH</literal>環境変数を設定することで変更できる。</para>
	</listitem>
      </itemizedlist>

      <para><literal>.dll</literal>形式の共有ライブラリを使うシステムでは、実際にロードされるライブラリは<filename><replaceable>lib</replaceable>.dll</filename>である。この場合も、ライブラリが見付からなかった場合はGHCiはエラーを報告する。</para>

      <para>GHCiは単なるオブジェクトファイル(プラットフォームによって、<literal>.o</literal>か<literal>.obj</literal>である)をコマンド行からロードすることもできる。これには、オブジェクトファイルの名前をコマンド行に追加するだけで良い。</para>

      <para><option>-l</option>の順序は意味を持つ。あるライブラリは、それが依存するライブラリよりも<emphasis>前</emphasis>に言及されなければならない。(<xref linkend="options-linker"/>を見よ)</para>
    </sect2>

  </sect1>

  <sect1 id="ghci-commands">
    <title>GHCiのコマンド群</title>

    <para>GHCiのコマンドは全て「<literal>:</literal>」ではじまり、一つのコマンド名とそれに続く零個以上のパラメータから成る。コマンド名は短縮することができ、曖昧な場合はより一般的に使われるコマンドが優先される。</para>

    <variablelist>
      <varlistentry>
        <term>
          <literal>:abandon</literal>
          <indexterm><primary><literal>:abandon</literal></primary></indexterm>
        </term>
	<listitem>
	  <para>実行中の評価を捨てる。(ブレークポイントでの停止中のみ有効)</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:add</literal> <optional><literal>*</literal></optional><replaceable>module</replaceable> ...
          <indexterm><primary><literal>:add</literal></primary></indexterm>
        </term>
	<listitem>
          <para><replaceable>module</replaceable>を現在の<firstterm>ターゲット集合</firstterm>に追加し、リロードを行う。通常、可能ならそのモジュールのコンパイル済みコードがロードされ、そうでなければそのモジュールはバイトコードにコンパイルされる。接頭辞<literal>*</literal>を使うことでモジュールがバイトコードとしてロードされることを強制できる。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:back</literal>
          <indexterm><primary><literal>:back</literal></primary></indexterm>
        </term>
	<listitem>
          <para>履歴中を一つ戻る。<xref linkend="tracing" />を見よ。<literal>:trace</literal>、<literal>:history</literal>、<literal>:forward</literal>も参照。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:break [<replaceable>identifier</replaceable> |
            [<replaceable>module</replaceable>] <replaceable>line</replaceable>
            [<replaceable>column</replaceable>]]</literal>
        </term>
          <indexterm><primary><literal>:break</literal></primary></indexterm>
	<listitem>
          <para>指定された関数、または指定された行の指定された位置にブレークポイントを設定する。<xref linkend="setting-breakpoints" />を見よ。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:browse</literal><optional><literal>!</literal></optional> <optional><optional><literal>*</literal></optional><replaceable>module</replaceable></optional> ...
          <indexterm><primary><literal>:browse</literal></primary></indexterm>
        </term>
	<listitem>
          <para><replaceable>module</replaceable>で定義されている識別子を表示する。<replaceable>module</replaceable>は、GHCiにロードされているか、パッケージの要素でなければならない。<replaceable>module</replaceable>が省略された場合、直近にロードされたモジュールが使われる。</para>
          <para><literal>*</literal>記号がモジュール名の前に置かれたときは、<replaceable>module</replaceable>でスコープにある<emphasis>全ての</emphasis>識別子が表示される。そうでない場合、一覧は<replaceable>module</replaceable>がエクスポートしたものに限定される。<literal>*</literal>形式は解釈実行されているモジュールに対してのみ有効である。コンパイル済みモジュール(パッケージ由来のモジュールも含む)に対しては非<literal>*</literal>形式の<literal>:browse</literal>のみが利用可能である。このコマンドの後ろに<literal>!</literal>記号が置かれた場合、データ構築子とクラスメソッドは個々に表示される。そうでなければ、データ型宣言やクラス宣言の一部としてのみ表示される。<literal>!</literal>の形式では、さらに、項目をグループに分けて、それぞれについて可能なインポートについてのコメントを付加する。</para>
<screen>
Prelude> :browse! Data.Maybe
-- not currently imported
Data.Maybe.catMaybes :: [Maybe a] -> [a]
Data.Maybe.fromJust :: Maybe a -> a
Data.Maybe.fromMaybe :: a -> Maybe a -> a
Data.Maybe.isJust :: Maybe a -> Bool
Data.Maybe.isNothing :: Maybe a -> Bool
Data.Maybe.listToMaybe :: [a] -> Maybe a
Data.Maybe.mapMaybe :: (a -> Maybe b) -> [a] -> [b]
Data.Maybe.maybeToList :: Maybe a -> [a]
-- imported via Prelude
Just :: a -> Maybe a
data Maybe a = Nothing | Just a
Nothing :: Maybe a
maybe :: b -> (a -> b) -> Maybe a -> b
</screen>
  <para>
    この出力が示すのは、現在のセッションの文脈(<literal>Prelude</literal>のスコープ)で、<literal>Data.Maybe</literal>の項目の最初の一団がインポートされておらず(ただしGHCiセッションでは完全修飾された形で利用できる。<xref linkend="ghci-scope"/>を見よ)、二番目の一団が<literal>Prelude</literal>を介してインポートされていて、修飾なし、あるいは<literal>Prelude.</literal>という修飾子付きの形式で利用できる、ということである。
  </para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:cd</literal> <replaceable>dir</replaceable>
          <indexterm><primary><literal>:cd</literal></primary></indexterm>
        </term>
	<listitem>
          <para>作業ディレクトリを<replaceable>dir</replaceable>に変更する。<replaceable>dir</replaceable>の先頭が「<literal>&tilde;</literal>」記号の場合、それは<literal>HOME</literal>環境変数の内容で置き換えられる。</para>

          <para>注意: ディレクトリを変更すると、ロードされているモジュールは全て未ロードになる。これは、探索パスがふつう相対ディレクトリを使って表されており、また、セッションの途中で探索パスを変更することがサポートされていないためである。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:cmd</literal> <replaceable>expr</replaceable>
          <indexterm><primary><literal>:cmd</literal></primary></indexterm>
        </term>
	<listitem>
          <para><replaceable>expr</replaceable>を<literal>IO String</literal>型の計算として実行し、その結果の文字列をGHCiコマンドのリストとして実行する。複数のコマンドは改行で区切る。<literal>:cmd</literal>コマンドは<literal>:def</literal>および<literal>:set stop</literal>と組み合わせて使うのに便利である。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:continue</literal> 
          <indexterm><primary><literal>:continue</literal></primary></indexterm>
        </term>
	<listitem><para>ブレークポイントで停止しているとき、実行中の評価を再開する。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
	  <literal>:ctags</literal> <optional><replaceable>filename</replaceable></optional>
	  <literal>:etags</literal> <optional><replaceable>filename</replaceable></optional>
	  <indexterm><primary><literal>:etags</literal></primary>
	  </indexterm>
	  <indexterm><primary><literal>:etags</literal></primary>
	  </indexterm>
	</term>
	<listitem>
          <para>Vi風のエディタ用(<literal>:ctags</literal>)またはEmacs風エディタ用(<literal>:etags</literal>)のタグファイルを生成する。ファイル名が指定されなかった場合は、それぞれデフォルトの<filename>tags</filename>または<filename>TAGS</filename>が使われる。ロードされているモジュール内の全ての関数、構築子、型のタグが作られる。これらのコマンドが働くには、全てのモジュールが解釈実行されていなければならない。</para>
          <para><xref linkend="hasktags"/>も見よ。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:def<optional>!</optional> <optional><replaceable>name</replaceable> <replaceable>expr</replaceable></optional></literal>
          <indexterm><primary><literal>:def</literal></primary></indexterm>
        </term>
	<listitem>
	  <para><literal>:def</literal>は、GHCiにおいて新しいコマンド(マクロと言ってもいい)を定義するのに使われる。コマンド<literal>:def</literal> <replaceable>name</replaceable> <replaceable>expr</replaceable>は、新しいGHCiコマンド<literal>:<replaceable>name</replaceable></literal>を、Haskellの式<replaceable>expr</replaceable>で実装されたものとして定義する。式の型は<literal>String -&gt; IO String</literal>でなければならない。<literal>:<replaceable>name</replaceable> <replaceable>args</replaceable></literal>がプロンプトに入力されると、GHCiは式<literal>(<replaceable>name</replaceable> <replaceable>args</replaceable>)</literal>を走らせ、結果の<literal>String</literal>を受け取り、それをコマンドの列として再びGHCiに入力する。結果においては、隣り合うコマンドは「<literal>\n</literal>」で区切られていなければならない。</para>

          <para>これは少々ややこしいので、いくつか例を挙げる。まず、次に示す新しいGHCiコマンドは、引数を取らず、結果を生成せず、単に現在の日時を出力するだけのものである。</para>

<screen>
Prelude> let date _ = Time.getClockTime >>= print >> return ""
Prelude> :def date date
Prelude> :date
Fri Mar 23 15:16:40 GMT 2001
</screen>

          <para>引数を取るコマンドの例を示す。これは<literal>:cd</literal>の再実装である。</para>

<screen>
Prelude> let mycd d = Directory.setCurrentDirectory d >> return ""
Prelude> :def mycd mycd
Prelude> :mycd ..
</screen>

          <para>あるいは、現在のディレクトリで「<literal>ghc &ndash;&ndash;make Main</literal>」を起動する単純な方法を定義することもできる。</para>

<screen>
Prelude> :def make (\_ -> return ":! ghc &ndash;&ndash;make Main")
</screen>

          <para>GHCiへの入力をファイルから読み込むコマンドを定義することもできる。これは、あらかじめ決まった束縛を繰り返しGHCiセッションにロードしたいというときに便利かもしれない。</para>

<screen>
Prelude> :def . readFile
Prelude> :. cmds.ghci
</screen>

          <para>このコマンドの名前は<literal>:.</literal>であるが、これは「<literal>.</literal>」(同じことをするUnixシェルのコマンド)のアナロジーである。</para>

          <para><literal>:def</literal>と単独で入力すると、現在定義されているマクロの一覧を表示する。既に存在するコマンド名を再定義しようとすると失敗する。ただし<literal>:def!</literal>の形式が使われた場合は別で、この場合その名前の古いコマンドは黙って失われる。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:delete * | <replaceable>num</replaceable> ...</literal> 
          <indexterm><primary><literal>:delete</literal></primary></indexterm>
        </term>
	<listitem>
          <para>ブレークポイントを番号で指定して削除する。(それぞれのブレークポイントの番号を見るには<literal>:show breaks</literal>を使う)。<literal>*</literal>の形式では、ブレークポイントを全て削除する。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:edit <optional><replaceable>file</replaceable></optional></literal>
          <indexterm><primary><literal>:edit</literal></primary></indexterm>
        </term>
	<listitem>
          <para>エディタを開いて、<replaceable>file</replaceable>、それが省略されたときは直近にロードされたモジュールを編集する。起動されるエディタは<literal>EDITOR</literal>環境変数から採られるか、<literal>EDITOR</literal>が設定されていないときはシステムのデフォルトエディタが使われる。使われるエディタは<literal>:set editor</literal>で変更することができる。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:etags</literal> 
        </term>
	<listitem>
	  <para><literal>:ctags</literal>を見よ。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:force <replaceable>identifier</replaceable> ...</literal>
          <indexterm><primary><literal>:force</literal></primary></indexterm>
        </term>
	<listitem>
          <para><replaceable>identifier</replaceable>の値を<literal>:print</literal>と同じ方法で表示する。<literal>:print</literal>と異なり、<literal>:force</literal>は、値をたどっていく間に出会ったサンクを評価する。これによって、例外や無限ループが発生したり、別のブレークポイント(これは無視されるが、その旨表示される)に当ったりするかもしれない。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:forward</literal>
          <indexterm><primary><literal>:forward</literal></primary></indexterm>
        </term>
	<listitem>
	  <para>履歴中で前進する。<xref linkend="tracing" />を見よ。<literal>:trace</literal>、<literal>:history</literal>、<literal>:back</literal>も参照。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:help</literal>
          <indexterm><primary><literal>:help</literal></primary></indexterm>
        </term>
	<term>
          <literal>:?</literal>
          <indexterm><primary><literal>:?</literal></primary></indexterm>
        </term>
	<listitem>
          <para>利用可能なコマンドの一覧を表示する。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:</literal>
          <indexterm><primary><literal>:</literal></primary></indexterm>
        </term>
	<listitem>
	  <para>前のコマンドを繰り返す。</para>
	</listitem>
      </varlistentry>

      <varlistentry>

	<term>
          <literal>:history [<replaceable>num</replaceable>]</literal>
          <indexterm><primary><literal>:history</literal></primary></indexterm>
        </term>
	<listitem>
	  <para>評価ステップの履歴を表示する。数値が与えられると、その数のステップを表示する(デフォルト: 20)。<literal>:trace</literal>と組み合わせて使う。<xref linkend="tracing" />を見よ。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:info</literal> <replaceable>name</replaceable> ...
          <indexterm><primary><literal>:info</literal></primary></indexterm>
        </term>
	<listitem>
          <para>与えられた名前についての情報を表示する。例えば、もし<replaceable>name</replaceable>がクラスなら、クラスメソッドとその型が印字される。もし<replaceable>name</replaceable>が型構築子なら、その定義が印字される。もし<replaceable>name</replaceable>が関数なら、その型が印字される。<replaceable>name</replaceable>がソースファイルからロードされたものであった場合、GHCiはその定義のソースコード中の位置も表示する。</para>
          <para>型およびクラスについては、それに言及するインスタンスもまとめて示す。無関係な情報を見せることがないように、インスタンスは、(a)その頭部が<replaceable>name</replaceable>に言及している、かつ(b)そのインスタンスで言及されているものが全て、<literal>:load</literal>または<literal>:module</literal>コマンドの結果としてスコープにある(修飾されていてもそうでなくても良い)、場合にのみ表示される。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:kind</literal> <replaceable>type</replaceable>
          <indexterm><primary><literal>:kind</literal></primary></indexterm>
        </term>
	<listitem>
          <para><replaceable>type</replaceable>の類を推論し、印字する。<replaceable>type</replaceable>は任意の型式で、<literal>Either Int</literal>のような型構築子の部分適用であっても構わない。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:load</literal> <optional><literal>*</literal></optional><replaceable>module</replaceable> ...
          <indexterm><primary><literal>:load</literal></primary></indexterm>
        </term>
	<listitem>
          <para>指定された<replaceable>module</replaceable>とそれが依存するモジュールすべてを再帰的にロードする。ここで、個々の<replaceable>module</replaceable>はモジュール名またはファイル名でなければならない。また、パッケージ中のモジュールの名前であってはいけない。</para>

          <para>以前にロードされていたモジュールは、パッケージ中のものを除いて、忘れ去られる。この新しいモジュールの集合を<firstterm>ターゲット集合</firstterm>と呼ぶ。<literal>:load</literal>を引数なしで使うと、ロードされているモジュールや束縛を全て未ロードにできることに注意。</para>

          <para>通常、可能ならそのモジュールのコンパイル済みコードがロードされ、そうでなければそのモジュールはバイトコードにコンパイルされる。接頭辞<literal>*</literal>を使うことでモジュールがバイトコードとしてロードされることを強制できる。</para>

          <para><literal>:load</literal>コマンドの後、以下のものが文脈として設定される。</para>

	  <itemizedlist>
	    <listitem>
              <para><replaceable>module</replaceable>が成功裡にロードされたなら、<replaceable>module</replaceable>。</para>
	    </listitem>
	    <listitem>
              <para>そうでないとき、今回の<literal>:load</literal>でロードされたモジュールがあるなら、最後に成功裡にロードされたモジュール。</para>
	    </listitem>
	    <listitem>
	      <para>そうでなければ、<literal>Prelude</literal>。</para>
	    </listitem>
	  </itemizedlist>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:main <replaceable>arg<subscript>1</subscript></replaceable> ... <replaceable>arg<subscript>n</subscript></replaceable></literal>
          <indexterm><primary><literal>:main</literal></primary></indexterm>
        </term>
        <listitem>
          <para>
            プログラムがコンパイルされ実行されるとき、コマンド行引数にアクセスするために<literal>getArgs</literal>関数を使うことができる。しかし、ghciでテストをしているときは、これらの引数を単純に<literal>main</literal>関数の引数として渡すことはできない。<literal>main</literal>関数は直接には引数をとらないからである。
          </para>

          <para>
            その代わり、<literal>:main</literal>コマンドを使うことができる。これは、とにかくスコープにある<literal>main</literal>を、引数がコマンド行から渡されたのと同じようにして実行する。例えば、次のようにである。
          </para>

<screen>
Prelude> let main = System.Environment.getArgs >>= print
Prelude> :main foo bar
["foo","bar"]
</screen>

        <para>スペースなどの文字を含む引数は、引用符に入れることができ、Haskellの文字列と同じように扱われる。また、Haskellのリスト構文をそのまま使うこともできる。</para>

<screen>
Prelude> :main foo "bar baz"
["foo","bar baz"]
Prelude> :main ["foo", "bar baz"]
["foo","bar baz"]
</screen>

        <para>最後に、<literal>-main-is</literal>フラグや<literal>:run</literal>コマンドを使えば、その他の関数を呼ぶことができる。</para>

<screen>
Prelude> let foo = putStrLn "foo" >> System.Environment.getArgs >>= print
Prelude> let bar = putStrLn "bar" >> System.Environment.getArgs >>= print
Prelude> :set -main-is foo
Prelude> :main foo "bar baz"
foo
["foo","bar baz"]
Prelude> :run bar ["foo", "bar baz"]
bar
["foo","bar baz"]
</screen>

        </listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:module <optional>+|-</optional> <optional>*</optional><replaceable>mod<subscript>1</subscript></replaceable> ... <optional>*</optional><replaceable>mod<subscript>n</subscript></replaceable></literal>
          <indexterm><primary><literal>:module</literal></primary></indexterm>
        </term>
        <term>
          <literal>import <replaceable>mod</replaceable></literal>
        </term>
	<listitem>
          <para>プロンプトに入力される文のための文脈を設定または改変する。<literal>import <replaceable>mod</replaceable></literal>の形式は<literal>:module +<replaceable>mod</replaceable></literal>と等価である。詳しくは<xref linkend="ghci-scope"/>を見よ。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:print </literal> <replaceable>names</replaceable> ...
          <indexterm><primary><literal>:print</literal></primary></indexterm>
        </term>
	<listitem>
          <para>評価を強制せずに値を表示する。<literal>:print</literal>は、型が不明、または部分的にしか分かっていない値に対して使うことができる。ブレークポイントにおける、多相型を持った局所変数がこれに当たる。<literal>:print</literal>は、実行時の値を調査しつつ、その値の型を再構築しようとし、可能ならGHCiの環境中でその型を精密にする。未評価の部分(サンク)に遭遇すると、<literal>:print</literal>は、それぞれのサンクに対して、<literal>_t</literal>で始まる名前の新しい変数を束縛する。さらなる情報は<xref linkend="breakpoints" />を見よ。<literal>:sprint</literal>コマンドも参照。これは<literal>:print</literal>と同様だが、新しい変数を束縛しない。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:quit</literal>
          <indexterm><primary><literal>:quit</literal></primary></indexterm>
        </term>
	<listitem>
          <para>GHCiを終了する。プロンプトでCtrl-Dを打つことでも終了できる。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:reload</literal>
          <indexterm><primary><literal>:reload</literal></primary></indexterm>
        </term>
	<listitem>
          <para>現在のターゲット集合とそれらが依存するモジュールのうち、変更のあったものがあれば、ターゲット集合を再ロードしようと試みる。結果として、新しいモジュールがロードされたり、ターゲットから間接的に必要とされなくなったモジュールが外されたりするかもしれないことに注意せよ。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:run</literal>
          <indexterm><primary><literal>:run</literal></primary></indexterm>
        </term>
	<listitem>
	  <para><literal>:main</literal>を見よ。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:set</literal> <optional><replaceable>option</replaceable>...</optional>
          <indexterm><primary><literal>:set</literal></primary></indexterm>
        </term>
	<listitem>
          <para>色々なオプションを設定する。利用可能なオプションの一覧は<xref linkend="ghci-set"/>を、GHCi固有のフラグは<xref linkend="interactive-mode-options"/>を見よ。<literal>:set</literal>コマンド単独では、どのオプションが現在有効になっているか表示する。また、現在の動的フラグの設定状況の一覧も表示する。GHCi固有のフラグは分けて表示される。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:set</literal> <literal>args</literal> <replaceable>arg</replaceable> ...
          <indexterm><primary><literal>:set args</literal></primary></indexterm>
        </term>
	<listitem>
          <para>プログラムが<literal>System.getArgs</literal><indexterm><primary>getArgs</primary></indexterm>を呼んだときに返される引数のリストを設定する。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
           <literal>:set</literal> <literal>editor</literal> <replaceable>cmd</replaceable>
        </term>
	<listitem>
          <para><literal>:edit</literal>コマンドで使われるエディタを<replaceable>cmd</replaceable>にする。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
	<term>
           <literal>:set</literal> <literal>prog</literal> <replaceable>prog</replaceable>
           <indexterm><primary><literal>:set prog</literal></primary></indexterm>
        </term>
	<listitem>
          <para>プログラムが<literal>System.getProgName</literal><indexterm><primary>getProgName</primary></indexterm>を呼んだときに返される文字列を設定する。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
           <literal>:set</literal> <literal>prompt</literal> <replaceable>prompt</replaceable>
        </term>
	<listitem>
          <para>GHCiのプロンプトとして使われる文字列を設定する。<replaceable>prompt</replaceable>の中では、<literal>%s</literal>という並びは現在スコープにあるモジュールの名前に置き換えられ、<literal>%%</literal>は<literal>%</literal>に置き換えられる。<replaceable>prompt</replaceable>が&quot;で始まる場合、HaskellのStringとしてパースされる。そうでない場合はそのまま文字列として扱われる。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
	<term>
           <literal>:set</literal> <literal>stop</literal>
          [<replaceable>num</replaceable>] <replaceable>cmd</replaceable>
        </term>
	<listitem>
	  <para>ブレークポイントに当たったとき、または履歴中で新しい項目が選択されたときに実行されるコマンドを設定する。<literal>:set :stop</literal>の最も一般的な使われ方は、現在位置のソースコードを表示することである。例えば<literal>:set stop :list</literal>のようにする。</para>

          <para>コマンドの前に数値が与えられた場合、指定されたブレークポイント(だけ)に到達した場合に実行される。これは場合によって非常に便利である。例えば、<literal>:set stop 1 :continue</literal>とすると、ブレークポイント1に到達した場合必ず<literal>:continue</literal>が実行されるので、実質的にこのブレークポイントを無効化している。(但し、ブレークポイントに到達した場合のメッセージは出力される)。さらには、<literal>:def</literal>と<literal>:cmd</literal>を巧妙に使って、<literal>:set stop</literal>で条件付きブレークポイントを実装することができる。</para>
<screen>
*Main> :def cond \expr -> return (":cmd if (" ++ expr ++ ") then return \"\" else return \":continue\"")
*Main> :set stop 0 :cond (x &lt; 3)
</screen>
          <para>同様の技法を使えば、指定した回数だけブレークポイントを無視することもできる。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:show bindings</literal>
          <indexterm><primary><literal>:show bindings</literal></primary></indexterm>
        </term>
	<listitem>
          <para>プロンプトで導入された束縛と、その型を表示する。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:show breaks</literal>
          <indexterm><primary><literal>:show breaks</literal></primary></indexterm>
        </term>
	<listitem>
	  <para>有効になっているブレークポイントの一覧を表示する。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:show context</literal>
          <indexterm><primary><literal>:show context</literal></primary></indexterm>
        </term>
	<listitem>
          <para>ブレークポイントで停止している、継続中の評価の一覧を表示する。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:show modules</literal>
          <indexterm><primary><literal>:show modules</literal></primary></indexterm>
        </term>
	<listitem>
          <para>現在ロードされているモジュールの一覧を表示する。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:show packages</literal>
          <indexterm><primary><literal>:show packages</literal></primary></indexterm>
        </term>
	<listitem>
    <para>現在有効なパッケージフラグと、現在ロードされているパッケージの一覧を表示する。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:show languages</literal>
          <indexterm><primary><literal>:show languages</literal></primary></indexterm>
        </term>
	<listitem>
    <para>現在有効な言語フラグを表示する。</para>
	</listitem>
      </varlistentry>


      <varlistentry>
	<term>
          <literal>:show [args|prog|prompt|editor|stop]</literal>
          <indexterm><primary><literal>:show</literal></primary></indexterm>
        </term>
	<listitem>
	  <para>指定された設定を表示する(<literal>:set</literal>を見よ)。</para>
	</listitem>
      </varlistentry>

       <varlistentry>
 	<term>
          <literal>:sprint</literal>
          <indexterm><primary><literal>:sprint</literal></primary></indexterm>
         </term>
 	<listitem>
	  <para>評価を強制せずに値を表示する。<literal>:sprint</literal>は<literal>:print</literal>に似ているが、違いは、未評価の部分項が新しい変数に束縛されず、単に「_」と表されることである。</para>
 	</listitem>
       </varlistentry>
      <varlistentry>
	<term>
          <literal>:step [<replaceable>expr</replaceable>]</literal> 
          <indexterm><primary><literal>:step</literal></primary></indexterm>
        </term>
	<listitem>
	  <para>直近のブレークポイントから一ステップ実行する。引数として式を与えられた場合、その式の評価のステップ実行を開始する。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:trace [<replaceable>expr</replaceable>]</literal>
          <indexterm><primary><literal>:trace</literal></primary></indexterm>
        </term>
	<listitem>
	  <para>与えられた式を評価(式を与えられなかった場合は直近のブレークポイントから再開)するが、後で<literal>:history</literal>で観察できるように評価ステップのログを残す。<xref linkend="tracing" />を見よ。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
         <literal>:type</literal> <replaceable>expression</replaceable>
         <indexterm><primary><literal>:type</literal></primary></indexterm>
        </term>
	<listitem>
          <para><replaceable>expression</replaceable>の型を推論し、印字する。多相型には明示的な全称量化が加えられる。推論に際して、単相性制限は適用されない。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:undef</literal> <replaceable>name</replaceable>
          <indexterm><primary><literal>:undef</literal></primary></indexterm>
        </term>
	<listitem>
          <para>利用者定義のコマンド<replaceable>name</replaceable>を未定義にする。(上の<literal>:def</literal>を見よ)</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:unset</literal> <replaceable>option</replaceable>...
          <indexterm><primary><literal>:unset</literal></primary></indexterm>
        </term>
	<listitem>
          <para>ある種のオプションを無効にする。利用可能なオプションの一覧は、<xref linkend="ghci-set"/>を見よ。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>:!</literal> <replaceable>command</replaceable>...
          <indexterm><primary><literal>:!</literal></primary></indexterm>
          <indexterm><primary>shell commands</primary><secondary>in GHCi</secondary></indexterm>
        </term>
	<listitem>
          <para>シェルのコマンド<replaceable>command</replaceable>を実行する。</para>
	</listitem>
      </varlistentry>

    </variablelist>
  </sect1>

  <sect1 id="ghci-set">
    <title><literal>:set</literal>コマンド</title>
    <indexterm><primary><literal>:set</literal></primary></indexterm>

    <para><literal>:set</literal>コマンドでは二系統のオプションを設定できる。「<literal>+</literal>」で始まるGHCiオプションと「-」で始まる「コマンド行」オプションである。</para>

    <para>注意: 現在のところ、<literal>:set</literal>コマンドは引数における引用符の使用を一切サポートしていない。引用符は削除されず、複数の単語を一つにまとめるのに使うこともできない。例えば、<literal>:set -DFOO='BAR BAZ'</literal>は期待した通りには動かないだろう。</para>

    <sect2>
      <title>GHCiオプション</title>
      <indexterm><primary>options</primary><secondary>GHCi</secondary>
      </indexterm>

      <para>GHCiオプションは、<literal>:set</literal>で有効化、
      <literal>:unset</literal>で無効化できる。</para>

      <para>利用できるGHCiオプションは以下のものである。</para>

      <variablelist>
	<varlistentry>
	  <term>
            <literal>+r</literal>
            <indexterm><primary><literal>+r</literal></primary></indexterm>
            <indexterm><primary>CAFs</primary><secondary>in GHCi</secondary></indexterm>
            <indexterm><primary>Constant Applicative Form</primary><see>CAFs</see></indexterm>
          </term>
	  <listitem>
            <para>通常、ロードされたモジュールにあるトップレベルの式(CAF(Constant Applicative Form)、あるいは定作用形とも呼ばれる)を評価した結果は、複数回のプロンプトでの評価をまたがって保持される。<literal>+r</literal>を有効にすると、トップレベルの式の評価結果はすべて、一回の評価が終わるごとに捨てられるようになる(それでも一回の評価の<emphasis>間は</emphasis>保持される)。</para>
	  
            <para>このオプションは、評価済みのトップレベル式が大量のメモリを消費するときや、再現性のある実行性能の計測をしたいときに有用かもしれない。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>
            <literal>+s</literal>
            <indexterm><primary><literal>+s</literal></primary></indexterm>
          </term>
	  <listitem>
            <para>一つ式を評価するごとに、経過時間や確保されたバイト数などの統計情報を表示する。注意: 確保されたバイト数はGC毎に計算されるので、これは記憶領域管理器の確保領域の大きさ程度の正確さしかない。そういうわけで、GCが起こらなかった場合、値として0が表示されるかもしれない。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>
            <literal>+t</literal>
            <indexterm><primary><literal>+t</literal></primary></indexterm>
          </term>
	  <listitem>
            <para>文がプロンプトに入力されたとき、束縛された変数それぞれの型を表示する。入力されたのが単一の式なら、束縛されるのは変数「<literal>it</literal>」だけである。</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="ghci-cmd-line-options">
      <title>GHCiからGHCのコマンド行オプションを設定する</title>

      <para>通常のGHCのコマンド行オプションを<literal>:set</literal>を使って設定することもできる。例えば、<option>-fglasgow-exts</option>を有効にするには、次のように入力すれば良い。</para>

<screen>
Prelude> :set -fglasgow-exts
</screen>
      
      <para>GHCのコマンド行オプションのうち、<firstterm>動的な</firstterm>オプション(<xref linkend="flag-reference"/>の表を見よ)として設計されているものは全て、<literal>:set</literal>を使って有効にすることができる。オプションを無効にするには、逆の効果を持つオプションを有効にすれば良い。</para><indexterm><primary>dynamic</primary><secondary>options</secondary></indexterm>

<screen>
Prelude> :set -fno-glasgow-exts
</screen>

      <para><xref linkend="flag-reference"/>には、可能なオプション全てについて逆の効果を持つオプションが記されている。</para>

      <para>ある種の静的なオプション(特に、<option>-package</option>、<option>-I</option>、<option>-i</option>、<option>-l</option>)も使えるが、次に再ロードするまで効果を発揮しないものもある。</para>
      <indexterm><primary>static</primary><secondary>options</secondary></indexterm>
    </sect2>
  </sect1>
  <sect1 id="ghci-dot-files">
    <title><filename>.ghci</filename>ファイル</title>
    <indexterm><primary><filename>.ghci</filename></primary><secondary>file</secondary>
    </indexterm>
    <indexterm><primary>startup</primary><secondary>files, GHCi</secondary>
    </indexterm>

    <para>GHCiは、開始するとき、<literal>-ignore-dot-ghci</literal>フラグが与えられていない限り、以下の各ファイルが存在していれば、この順で読み、書かれているコマンドを実行する。</para>

    <orderedlist>
    <listitem>
      <para><filename>./.ghci</filename></para>
    </listitem>
    <listitem>
      <para><literal><replaceable>appdata</replaceable>/ghc/ghci.conf</literal>、ただし<replaceable>appdata</replaceable>はシステムに依存。通常は<literal>C:/Documents and Settings/<replaceable>user</replaceable>/Application Data</literal>のようなところ。</para>
    </listitem>
    <listitem>
      <para>Unixでは、<literal>$HOME/.ghc/ghci.conf</literal></para>
    </listitem>
    <listitem>
      <para><literal>$HOME/.ghci</literal></para>
    </listitem>
   </orderedlist>

    <para><filename>ghci.conf</filename>ファイルは、あなたのお気に入りのオプション(例えば<literal>:set +s</literal>)を有効にしたり、便利なマクロを定義したりするのに適している。また、<filename>.ghci</filename>をHaskellプロジェクトのディレクトリに置いて、プロジェクトで使われるオプションを設定するようにしておくと、GHCiを立ち上げるたびにそれを打ち込まなくて済むので便利である。例えば、プロジェクトがGHC拡張とCPPを使い、ソースファイルがA、B、Cという三つのサブディレクトリに置かれているなら、次の数行を<filename>.ghci</filename>に置くことができる。</para>

<screen>
:set -fglasgow-exts -cpp
:set -iA:B:C
</screen>

    <para>(厳密には<option>-i</option>フラグは静的オプションであるが、このように<literal>:set</literal>しても動くことに注意。ただし、この変更は、次に<literal>:load</literal>が実行されるまで効果を発揮しない。)</para>

    <para>GHCiマクロを沢山持つようになると、それらを別のファイルから調達したいと思うかもしれない。また、<filename>.ghci</filename>ファイルをデバッグしているときに、それを実行中のGHCiにロードしたいと思うことがあるかもしれない。</para>

<screen>
:def source readFile
</screen>

    <para>あなたの<filename>.ghci</filename>にこのマクロを置いておけば、<literal>:source file</literal>とすることで<literal>file</literal>からGHCiコマンドを読み込むことができる。Haskell wikiのページ<ulink url="http://haskell.org/haskellwiki/GHC/GHCi">GHC/GHCi</ulink>では、<filename>.ghci</filename>についてのその他の助言を読むことが(そしてもちろん、追加することも)できる。</para>

    <para>開始時ファイルが読まれるかどうかを制御する二つのコマンド行オプションがある。</para>

    <variablelist>
      <varlistentry>
	<term>
          <option>-ignore-dot-ghci</option>
          <indexterm><primary><option>-ignore-dot-ghci</option></primary></indexterm>
        </term>
	<listitem>
          <para>開始するとき、<filename>./.ghci</filename>その他の開始時ファイルを読まない。</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>
          <option>-read-dot-ghci</option>
          <indexterm><primary><option>-read-dot-ghci</option></primary></indexterm>
        </term>
	<listitem>
          <para><filename>.ghci</filename>その他の開始時ファイル(上記)を読む。通常これがデフォルトであるが、<option>-read-dot-ghci</option>は前に指定された<option>-ignore-dot-ghci</option>を上書きするのに使うことができる。</para>
	</listitem>
      </varlistentry>
    </variablelist>

  </sect1>

  <sect1 id="ghci-obj">
    <title>GHCi内でオブジェクトコードにコンパイルする</title>

    <para>デフォルトでは、GHCiはHaskellソースコードをコンパイルして、ランタイムシステムが解釈できるバイトコードを出力する。GHCiはHaskellコードをオブジェクトコードにコンパイルすることもできる。この機能を有効にするには、コマンド行または<literal>:set</literal>で<option>-fobject-code</option>フラグを使えばよい。(<option>-fbyte-code</option>とすればまた元のバイトコードコンパイルに戻る)。オブジェクトコードへのコンパイルは時間が掛かるが、コードはバイトコードと比べて10〜20倍早く動作する。</para>

    <para>GHCi内でオブジェクトコードにコンパイルする機能は、コンパイル型アプリケーションを開発しているときに特に便利である。GHCを<option>--make</option>オプション付きで再起動するのよりも<literal>:reload</literal>コマンドがずっと速いからで、これはインタフェースファイルがすべてメモリにキャッシュされているからである。</para>

    <para>オブジェクトコードにコンパイルすることには欠点もある。例えば、オブジェクトコードのモジュールにはブレークポイントを設定することができない。解釈実行されているモジュールでは全ての最上位の束縛がGHCiから可視であるのに対して、オブジェクトコードのモジュールではエクスポートされたものしか可視でない。</para>
  </sect1>

  <sect1 id="ghci-faq">
    <title>FAQと注意事項</title>
    
    <variablelist>
      <varlistentry>
        <term>インタプリタがforeign export宣言のあるモジュールをロードできません！</term>
	<listitem>
          <para>残念ながらその通りである。それはまだ実装されていない。問題のあるモジュールは手でコンパイルしてからGHCiにロードしてほしい。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>
          GHCiで<literal>-O</literal>がうまく働きません！
          <indexterm><primary><option>-O</option></primary></indexterm>
         </term>
	<listitem>
          <para>技術的な理由から、バイトコードコンパイラが特定の最適化過程とうまく相互作用しないので、解釈実行器を使うときは最適化が無効にしてある。これは大きな問題ではない。高速に実行されるべきコードは、コンパイルしておくことで、最適化つきで解釈実行するよりもずっと速く実行できる。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term>非ボックス化タプルがGHCiで使えない</term>
	<listitem>
          <para>その通り。しかし、非ボックス化タプルを使うモジュールをコンパイルして、それをGHCiにロードするということは常にできる。(ちなみに、上記の、<literal>-O</literal>がGHCiで使えないというのは、バイトコードコンパイラが非ボックス化タプルを扱えないからである)</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term>GHCiが入力を待っている間、並列スレッドが走りつづけてくれない。</term>
	<listitem>
          <para>GHCiが<option>-threaded</option>スイッチを有効(デフォルト)にしてコンパイルされている限り、問題はないはずである。インストールしたGHCの供給元に相談してほしい。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
        <term><literal>getContents</literal>を使った後、<literal>:load</literal>か<literal>:reload</literal>するまで<literal>stdin</literal>が使えない。</term>

	<listitem>
          <para>それは<literal>getContents</literal>の定義通りの振る舞いである。<literal>getContents</literal>はハンドルを<firstterm>セミクローズ</firstterm>という状態にするが、その状態ではいかなるIO操作も禁止される。計算と計算の間でIOの状態は保持されるので、次に<literal>:load</literal>か<literal>:reload</literal>コマンドが実行されるまでセミクローズ状態が続く。</para>

          <para><literal>:set +r</literal>というコマンドで<literal>stdin</literal>が毎回元の状態に復元されるようにすることができる。これがうまく行くのは、<literal>stdin</literal>が単なるトップレベルの式で、他のトップレベルの式(CAF)と同様の方法で未評価の状態に戻すことができるからである。</para>

	</listitem>
      </varlistentry>

      <varlistentry>
       <term>WindowsのGHCiで計算を中断するのにCtrl-Cが使えない。</term>
        <listitem>
          <para><xref linkend="ghci-windows"/>を参照。</para>
        </listitem>
      </varlistentry>

      <varlistentry>
	<term>デフォルトのバッファリングモードがGHCiとGHCで異なっている。</term>
        <listitem>
          <para>
            GHCでは、デフォルトでstdoutハンドルは行バッファされている。しかし、GHCiでは、stdoutに関するバッファリングを無効にしてある。これが通常インタプリタに期待される振る舞いだからである。出力は生成されると同時に出現する。
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
  </sect1>

</chapter>

<!-- Emacs stuff:
     ;;; Local Variables: ***
     ;;; mode: xml ***
     ;;; sgml-parent-document: ("users_guide.xml" "book" "chapter") ***
     ;;; End: ***
 -->
