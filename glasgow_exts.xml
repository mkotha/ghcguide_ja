<?xml version="1.0" encoding="UTF-8"?>
<para>
<indexterm><primary>language, GHC</primary></indexterm>
<indexterm><primary>extensions, GHC</primary></indexterm>
既知のHaskell処理系はどれもそうだが、GHCもいくつかの言語拡張を実装している。これらは、コマンド行フラグやプラグマを使って有効/無効を切り替えられる。デフォルトでGHCが理解するのは、対応しているうちで最新のHaskellに、多少の拡張を加えたものである。
</para>

<para>
グラスゴー拡張の中には、Haskellを実装するのに使われている基礎となる機能に触れるようにするものがある。よって、可搬性のないコードを原始的な水準で書くつもりがあるなら、生の部分を操作することができる。効率を追求するとき、Haskellの高水準な機能の実装コストのせいで行き詰まる必要はない。常にそれらの機能の「下」でコードを書けるからである。極端な場合、速度が重要な部分は全てCで書き、それをあとでHaskellと合わせる、ということもできる。</para>

<para>
最低水準での作業に没頭する(例えば、至るところで<literal>MutableByteArray#</literal>を使ったり)前に、必要な機能に「Haskellらしい被覆」を被せるライブラリがないか確かめた方が良いだろう。<ulink url="../libraries/index.html">ライブラリ説明書</ulink>(訳注: 未訳。<ulink url="http://www.haskell.org/ghc/docs/latest/html/libraries/">web上の最新版</ulink>)にはGHC付属のライブラリが全て説明されている。
</para>

<!-- LANGUAGE OPTIONS -->
  <sect1 id="options-language">
    <title>言語オプション</title>

    <indexterm><primary>language</primary><secondary>option</secondary>
    </indexterm>
    <indexterm><primary>options</primary><secondary>language</secondary>
    </indexterm>
    <indexterm><primary>extensions</primary><secondary>options controlling</secondary>
    </indexterm>

    <para>言語オプションのフラグは、言語のどの変種が許されるか制御するものである。</para>

    <para>言語オプションは二つの方法で制御できる。
    <itemizedlist>
      <listitem><para>全ての言語オプションは"<option>-X...</option>"というコマンド行フラグ(例えば<option>-XTemplateHaskell</option>)によって有効に、"<option>-XNo...</option>"というフラグ(例えば<option>-XNoTemplateHaskell</option>)によって無効にできる。</para></listitem>
      <listitem><para>Cabalが認識する言語オプションなら、<literal>LANGUAGE</literal>プラグマを使って有効にすることもできる。<literal>{-# LANGUAGE TemplateHaskell #-}</literal>のように。(<xref linkend="language-pragma"/>を見よ)</para>
          </listitem>
      </itemizedlist></para>

    <para><option>-fglasgow-exts</option><indexterm><primary><option>-fglasgow-exts</option></primary></indexterm>フラグは、以下の拡張を有効にするのと同じである。&what_glasgow_exts_does;<option>-fglasgow-exts</option>の効果は、これらのオプションを有効にすること<emphasis>だけ</emphasis>である。我々はこの多目的フラグをやめて、機能を個別に有効にする方向に移行しようとしている。</para>

  </sect1>

<!-- UNBOXED TYPES AND PRIMITIVE OPERATIONS -->
<sect1 id="primitives">
  <title>非ボックス化型とプリミティブ演算</title>

<para>GHCは大量のプリミティブなデータ型と演算を基礎としている。(「プリミティブ」だというのは、Haskell自体では定義できないという意味である)。高速なコードを書くためにこれらを使うこともできるが、高水準の言語機能やライブラリを使った方が、通常はずっと苦痛が少なく、長期的に見て良い結果になる。運が良ければ、書いたコードは最適化されて、結局、効率的な非ボックス化版になる。もしそうならないときは知らせてほしい。</para>

<para>これらのプリミティブなデータ型と演算は全て<literal>GHC.Prim</literal>というライブラリからエクスポートされている。これには<ulink url="&libraryGhcPrimLocation;/GHC.Prim.html">詳細なオンライン説明書</ulink>がある。(この説明書は<filename>compiler/prelude/primops.txt.pp</filename>というファイルから生成されている)</para>
<para>プログラム中でプリミティブなデータ型や演算に言及したいなら、まず<literal>GHC.Prim</literal>をインポートしてそれらをスコープに導入しなければならない。多くは「&num;」で終わる名前を持っているので、そのようなものに言及するには拡張<option>-XMagicHash</option>(<xref linkend="magic-hash"/>)が必要である。
</para>

<para>プリミティブ演算は広範にわたって<link linkend="glasgow-unboxed">非ボックス化型</link>と<link linkend="unboxed-tuples">非ボックス化タプル</link>を使っている。ここではこれらについて短くまとめる。</para>

<sect2 id="glasgow-unboxed">
<title>非ボックス化型
</title>

<para>
<indexterm><primary>Unboxed types (Glasgow extension)</primary></indexterm>
</para>

<para>GHCにおいて、大部分の型は<firstterm>ボックス化</firstterm>されている。つまり、その型の値はヒープ中オブジェクトへのポインタで表現されている。例えば、Haskellの<literal>Int</literal>の表現は、二ワードのヒープ中オブジェクトである。一方、<firstterm>非ボックス化</firstterm>型は、値そのものによって表現され、ポインタやヒープ確保とは無関係である。</para>

<para>
非ボックス化型は、Cで使う「生の機械上の」型に相当する。<literal>Int&num;</literal> (long int)、<literal>Double&num;</literal> (double)、<literal>Addr&num;</literal> (void *)などである。これらの型の上の<emphasis>プリミティブ演算</emphasis>(PrimOp)は予想される通りのものである。例えば、<literal>(+&num;)</literal>は<literal>Int&num;</literal>についての加算であり、我々が皆愛する機械上の加算(通常一命令)である。</para>

<para>
プリミティブな(非ボックス化)型はHaskellで定義できないので、言語とコンパイラに組み込まれている。プリミティブ型は決して持ち上げられていない。すなわち、プリミティブ型の値はボトムになり得ない。慣習として、プリミティブな型、値、演算には<literal>&num;</literal>を接尾辞として付ける(ただし、あくまで慣習である)(<xref linkend="magic-hash"/>を見よ)。プリミティブ型には、リテラルのために特別な構文があるものもあるが、それも<link linkend="magic-hash">同じ節</link>で述べている。</para>

<para>
しばしば、プリミティブな型は単なるビットパターンで表される。例えば、<literal>Int&num;</literal>、<literal>Float&num;</literal>、<literal>Double&num;</literal>がそうである。しかし、常にそうという訳ではない。プリミティブな値がヒープに確保されたオブジェクトへのポインタで表現されていることもある。例として<literal>Array&num;</literal>、すなわちプリミティブ配列の型がある。プリミティブ配列はヒープに確保されているが、これは、大きすぎてレジスタに収まらず、コピーして持ち回るのはコストが掛かりすぎるからである。ある意味では、これがポインタで表現されているというのは偶然に過ぎない。プリミティブ型がポインタで表現されるときは、ポインタは必ずその値を指すのであって、未評価のサンクや間接参照等々を指すことはない。たくさんの数値計算を行うプログラムでは、非ボックス化型を使うことで「標準的な」書き方をしたものよりも<emphasis>ずっと</emphasis>速くなることがある。ある例では、三倍もの高速化が達成された。</para>

<para>
プリミティブ型を使うにあたって、いくつか制限がある。
<itemizedlist>
<listitem><para>もっとも基本的な制限は、プリミティブ値は、多相的な関数に渡したり多相的なデータ型中に保持したりできないということである。これによって<literal>[Int&num;]</literal>(つまり、プリミティブ整数のリスト)のようなものが禁止される。この制限があるのは、多相的な引数や多相的な構築子フィールドはポインタであると期待されているからである。これらに非ボックス化整数が入り込むと、GCの追跡対象となり、予測できないスペースリークを引き起こす。また、その多相的な要素に対して<function>seq</function>を行うと、ポインタとして参照外しを試みることになり、壊滅的な結果を招く。さらに悪いことに、非ボックス化型はポインタよりも大きいことがある。(<literal>Double&num;</literal>が一例)
</para>
</listitem>
<listitem><para>newtypeを定義するとき、その表現の型(データ構築子の引数の型)が非ボックス化型であってはならない。よって、以下は許されない。
<programlisting>
  newtype A = MkA Int#
</programlisting>
</para></listitem>
<listitem><para><emphasis>最上位の</emphasis>束縛で、非ボックス化型を持つ変数を束縛することはできない。
</para></listitem>
<listitem><para><emphasis>再帰的な</emphasis>束縛で、非ボックス化型を持つ変数を束縛することはできない。
</para></listitem>
<listitem><para>非ボックス化変数を(非再帰的、非最上位)パターン束縛で束縛することはできるが、そのようなパターン照合はすべて正格にしなければならない。例えば、次のように書くことはできない。
<programlisting>
  data Foo = Foo Int Int#

  f x = let (Foo a b, w) = ..rhs.. in ..body..
</programlisting>
<literal>b</literal>の型は<literal>Int#</literal>なので、代わりに、次のように書かなければならない。
<programlisting>
  data Foo = Foo Int Int#

  f x = let !(Foo a b, w) = ..rhs.. in ..body..
</programlisting>
</para>
</listitem>
</itemizedlist>
</para>

</sect2>

<sect2 id="unboxed-tuples">
<title>非ボックス化タプル
</title>

<para>
非ボックス化タプルは<literal>GHC.Exts</literal>でエクスポートされている訳ではない。これは言語フラグ<option>-XUnboxedTuples</option>によって有効になる構文的拡張である。非ボックス化タプルは次のような形をしている。
</para>

<para>

<programlisting>
(# e_1, ..., e_n #)
</programlisting>

</para>

<para>
ここで、<literal>e_1..e_n</literal>は任意の型(プリミティブであるかを問わない)をもつ式である。非ボックス化タプルの型も同様に書く。</para>

<para>
非ボックス化タプルが使われるのは、関数が複数の値を返す必要があり、なおかつ、通常のタプルを使ったときのようなヒープ確保を避けたい場合である。非ボックス化タプルが返されるとき、要素がレジスタかスタックに直接置かれる。非ボックス化タプルそれ自体は複合物としての表現を持たない。<literal>primops.txt.pp</literal>に載っているプリミティブ演算の多くが非ボックス化タプルを返す。特に、<literal>IO</literal>モナドおよび<literal>ST</literal>モナドでは、操作の連結に際して不要なメモリ確保をしなくても済むようにするために非ボックス化タプルが使われている。</para>

<para>
非ボックス化タプルの使用に際しては、いくつか規則が存在する。
<itemizedlist>
<listitem>

<para>
非ボックス化タプル型の値は、通常の非ボックス化型と同じ制約を受ける。すなわち、多相的なデータ構造に入れることはできないし、多相的な関数に渡すこともできない。

</para>
</listitem>
<listitem>
<para>
非ボックス化タプルの典型的な使いかたは、単純に複数の値を返し、その複数の結果を<literal>case</literal>式で束縛するというものである。
<programlisting>
  f x y = (# x+1, y-1 #)
  g x = case f x x of { (# a, b #) -&#62; a + b }
</programlisting>
パターン束縛中に非ボックス化タプルを用いることができる。
<programlisting>
  f x = let (# p,q #) = h x in ..body..
</programlisting>
<literal>p</literal>と<literal>q</literal>の型が非ボックス化型でないなら、通常のHaskellのパターン束縛と同様に、この束縛は遅延する。上記の例は次のように脱糖できる。
<programlisting>
  f x = let t = case h x o f{ (# p,q #) -> (p,q)
            p = fst t
            q = snd t
        in ..body..
</programlisting>
実際、束縛は再帰的であっても良い。
</para>
</listitem>
</itemizedlist>

</para>

</sect2>
</sect1>


<!-- ====================== SYNTACTIC EXTENSIONS =======================  -->

<sect1 id="syntax-extns">
<title>構文的拡張</title>

    <sect2 id="unicode-syntax">
      <title>Unicode構文</title>
      <para>言語拡張<option>-XUnicodeSyntax</option><indexterm><primary><option>-XUnicodeSyntax</option></primary></indexterm>は、特定のASCII文字列をUnicode文字を使って表すことを可能にする。以下の代替記法が提供される。</para>

      <informaltable>
	<tgroup cols="2" align="left" colsep="1" rowsep="1">
	  <thead>
	    <row>
	      <entry>ASCII</entry>
              <entry>Unicodeによる代替</entry>
	      <entry>コードポイント</entry>
	      <entry>名前</entry>
	    </row>
	  </thead>

<!--
               to find the DocBook entities for these characters, find
               the Unicode code point (e.g. 0x2237), and grep for it in
               /usr/share/sgml/docbook/xml-dtd-*/ent/* (or equivalent on
               your system.  Some of these Unicode code points don't have
               equivalent DocBook entities.
            -->

	  <tbody>
	    <row>
	      <entry><literal>::</literal></entry>
	      <entry>::</entry> <!-- no special char, apparently -->
              <entry>0x2237</entry>
	      <entry>PROPORTION</entry>
	    </row>
          </tbody>
	  <tbody>
	    <row>
	      <entry><literal>=&gt;</literal></entry>
	      <entry>&rArr;</entry>
	      <entry>0x21D2</entry>
              <entry>RIGHTWARDS DOUBLE ARROW</entry>
	    </row>
          </tbody>
	  <tbody>
	    <row>
	      <entry><literal>forall</literal></entry>
	      <entry>&forall;</entry>
	      <entry>0x2200</entry>
              <entry>FOR ALL</entry>
	    </row>
          </tbody>
	  <tbody>
	    <row>
	      <entry><literal>-&gt;</literal></entry>
	      <entry>&rarr;</entry>
	      <entry>0x2192</entry>
              <entry>RIGHTWARDS ARROW</entry>
	    </row>
          </tbody>
	  <tbody>
	    <row>
	      <entry><literal>&lt;-</literal></entry>
	      <entry>&larr;</entry>
	      <entry>0x2190</entry>
              <entry>LEFTWARDS ARROW</entry>
	    </row>
          </tbody>
	  <tbody>
	    <row>
	      <entry>-&lt;</entry>
	      <entry>&larrtl;</entry>
	      <entry>0x2919</entry>
	      <entry>LEFTWARDS ARROW-TAIL</entry>
	    </row>
          </tbody>

	  <tbody>
	    <row>
	      <entry>&gt;-</entry>
	      <entry>&rarrtl;</entry>
	      <entry>0x291A</entry>
	      <entry>RIGHTWARDS ARROW-TAIL</entry>
	    </row>
          </tbody>

	  <tbody>
	    <row>
	      <entry>-&lt;&lt;</entry>
	      <entry></entry>
	      <entry>0x291B</entry>
	      <entry>LEFTWARDS DOUBLE ARROW-TAIL</entry>
	    </row>
          </tbody>

	  <tbody>
	    <row>
	      <entry>&gt;&gt;-</entry>
	      <entry></entry>
	      <entry>0x291C</entry>
	      <entry>RIGHTWARDS DOUBLE ARROW-TAIL</entry>
	    </row>
          </tbody>

	  <tbody>
	    <row>
	      <entry>*</entry>
	      <entry>&starf;</entry>
	      <entry>0x2605</entry>
	      <entry>BLACK STAR</entry>
	    </row>
          </tbody>

        </tgroup>
      </informaltable>
    </sect2>

    <sect2 id="magic-hash">
      <title>魔法の井桁(magic hash)</title>
      <para><option>-XMagicHash</option>という言語拡張は、識別子に対する後置修飾子として「&num;」を認めるものである。つまり、「x&num;」が変数として有効に、「T&num;」が型構築子やデータ構築子として有効になる。</para>

      <para>この井桁記号はまったく意味論に影響を与えない。非ボックス化された値や型に「&num;」で終わる名前を付ける(たとえば<literal>Int&num;</literal>)傾向があるが、必須ではない。これらはただの通常の変数に過ぎないのである。また、拡張<option>-XMagicHash</option>が何かをスコープに導入することもない。例えば、<literal>Int&num;</literal>をスコープに導入するためには<literal>GHC.Prim</literal>(<xref linkend="primitives"/>を見よ)をインポートしなければならない。その後で、スコープに導入された<literal>Int&num;</literal>に<emphasis>言及</emphasis>することを可能にするのが<option>-XMagicHash</option>オプションである。</para>
      <para>また、<option>-XMagicHash</option>は新しい形式のリテラルを何種類か有効にする。(<xref linkend="glasgow-unboxed"/>を見よ)
	<itemizedlist>
	  <listitem><para> <literal>'x'&num;</literal>の型は<literal>Char&num;</literal></para> </listitem>
	  <listitem><para> <literal>&quot;foo&quot;&num;</literal>の型は<literal>Addr&num;</literal></para> </listitem>
	  <listitem><para> <literal>3&num;</literal>の型は<literal>Int&num;</literal>である。一般に、なんらかのHaskellの整数lexemeの後に<literal>&num;</literal>が付いたものは<literal>Int&num;</literal>になる。例えば<literal>-0x3A&num;</literal>や<literal>32&num;</literal>がそうである。</para></listitem>
	  <listitem><para> <literal>3&num;&num;</literal>の型は<literal>Word&num;</literal>である。一般に、なんらかの非負なHaskellの整数lexemeの後に<literal>&num;&num;</literal>が付いたものは<literal>Word&num;</literal>になる。</para> </listitem>
	  <listitem><para> <literal>3.2&num;</literal>の型は<literal>Float&num;</literal></para> </listitem>
	  <listitem><para> <literal>3.2&num;&num;</literal>の型は<literal>Double&num;</literal></para> </listitem>
	  </itemizedlist>
      </para>
   </sect2>

    <!-- ====================== HIERARCHICAL MODULES =======================  -->


    <sect2 id="hierarchical-modules">
      <title>階層的モジュール</title>

      <para>GHCは、モジュール名の構文について、ある小さな拡張をサポートしている。すなわち、モジュール名はドット「<literal>.</literal>」を含むことができる。これは「階層的モジュール名前空間」拡張とも呼ばれる。これは、通常平坦なHaskellモジュールの名前空間を拡張して、より柔軟な、モジュールの階層をつくり出すからである。</para>

      <para>この拡張は言語そのものにはほとんど影響を与えない。モジュール名は<emphasis>常に</emphasis>完全修飾されるので、完全修飾されたモジュール名を「真のモジュール名」だと考えることができる。従って、特に、モジュールの先頭の<literal>module</literal>キーワードの後には、完全なモジュール名を与えなければならない。例えば、<literal>A.B.C</literal>というモジュールは次のように始まらなければならない。</para>

<programlisting>module A.B.C</programlisting>


      <para>階層的モジュールを使っていて、修飾名を使いたいときは、<literal>as</literal>キーワードを使ってタイプ数を節約するのが常套手段である。例えば、次のようにである。</para>

<programlisting>
import qualified Control.Monad.ST.Strict as ST
</programlisting>

      <para>階層的モジュールが使われているときにGHCがどのようにソースファイルやインタフェースファイルを探索するかについては、<xref linkend="search-path"/>を見よ。</para>

      <para>GHCには、階層的に配置された大規模なライブラリ群が付属している。これについては、付属の<ulink url="../libraries/index.html">ライブラリ説明書</ulink>(訳注: 未訳。<ulink url="http://www.haskell.org/ghc/docs/latest/html/libraries/">web上の最新版</ulink>)を見てほしい。また、<ulink url="http://hackage.haskell.org/packages/hackage.html">HackageDB</ulink>から別のライブラリを入手してインストールすることもできる。</para>

    </sect2>

    <!-- ====================== PATTERN GUARDS =======================  -->

<sect2 id="pattern-guards">
<title>パターンガード</title>

<para>
<indexterm><primary>Pattern guards (Glasgow extension)</primary></indexterm>
以下の議論はSimon Peyton Jonesの元<ulink url="http://research.microsoft.com/~simonpj/Haskell/guards.html">提案</ulink>を短くしたものである。(この提案はパターンガードが実装される前に書かれたので、これを未実装の機能として扱っていることに注意)</para>

<para>
有限写像を表す抽象データ型と、それについてのlookup操作があったとしよう。

<programlisting>
lookup :: FiniteMap -> Int -> Maybe Int
</programlisting>

lookupは、与えられたキーが写像の定義域に含まれなければ<function>Nothing</function>を返し、そうでなければ<function>(Just v)</function>を返す。ここで<varname>v</varname>はそのキーが対応する値である。ここで次の定義を考えよう。
</para>

<programlisting>
clunky env var1 var2 | ok1 &amp;&amp; ok2 = val1 + val2
| otherwise  = var1 + var2
where
  m1 = lookup env var1
  m2 = lookup env var2
  ok1 = maybeToBool m1
  ok2 = maybeToBool m2
  val1 = expectJust m1
  val2 = expectJust m2
</programlisting>

<para>
補助関数は次のとおりである。
</para>

<programlisting>
maybeToBool :: Maybe a -&gt; Bool
maybeToBool (Just x) = True
maybeToBool Nothing  = False

expectJust :: Maybe a -&gt; a
expectJust (Just x) = x
expectJust Nothing  = error "Unexpected Nothing"
</programlisting>

<para>
<function>clunky</function>は何をしているのか？ガードである<literal>ok1 &amp;&amp; ok2</literal>は両方のlookupが成功したことを確かめている。このために、<function>maybeToBool</function>を使って<function>Maybe</function>を真偽値に変換している。<function>expectJust</function>の呼び出し(遅延評価される)は、lookupの結果から値を抽出し、返った値を<varname>val1</varname>と<varname>val2</varname>にそれぞれ束縛している。もしどちらかのlookupが失敗すると、clunkyは<literal>otherwise</literal>の選択肢を選び、引数の和を返す。</para>

<para>
これは確かに合法なHaskellだが、欲する結果を得るのに非常に冗長で自明でないやりかたをしている。おそらく、case式を使った方がclunkyをもっと直接的に書けるだろう。
</para>

<programlisting>
clunky env var1 var2 = case lookup env var1 of
  Nothing -&gt; fail
  Just val1 -&gt; case lookup env var2 of
    Nothing -&gt; fail
    Just val2 -&gt; val1 + val2
where
  fail = var1 + var2
</programlisting>

<para>
これで少し短くなったが、改善とは言えないだろう。もちろん、パターン照合やガードのついた等式をcase式に書き換えることは常にできる。これはまさに、複数の等式を持つ定義をコンパイルするときにコンパイラが行っていることである。Haskellにガードつきの等式があるのは、場合分けを一つ一つ独立に書き下していくことができるようにである。この構造はcaseを使った版では明らかでない。右辺のうちふたつは同じ(<function>fail</function>)だし、式全体がどんどんインデントされていっている。
</para>

<para>
私ならclunkyを次のように書く。
</para>

<programlisting>
clunky env var1 var2
  | Just val1 &lt;- lookup env var1
  , Just val2 &lt;- lookup env var2
  = val1 + val2
...clunkyの他の等式...
</programlisting>

<para>
意味は十分明快だろう。修飾子は順番に照合される。<literal>&lt;-</literal>修飾子(パターンガードと呼ぼう)については、右辺が評価され、左辺のパターンと照合される。照合が失敗するとガードが全体として失敗し、次の等式が試みられる。成功すると、それに沿った束縛が行われ、次の修飾子が、拡張された環境の下で照合される。ただし、リスト内包表記の場合と違って、<literal>&lt;-</literal>の右辺の式の型は左辺のパターンの型と同じである。パターンガードによって導入された束縛のスコープは、残りのガード修飾子と、その等式の右辺にわたる。</para>

<para>
リスト内包表記の場合と同様に、パターンガード間に自由に真偽式を混ぜることができる。例えば、次のようにである。
</para>

<programlisting>
f x | [y] &lt;- x
    , y > 3
    , Just z &lt;- h y
    = ...
</programlisting>

<para>
従って、現在のHaskellのガードは、修飾子がただ一つの要素からなり、その要素が真偽式であるような、特別な場合とみなされる。
</para>
</sect2>

    <!-- ===================== View patterns ===================  -->

<sect2 id="view-patterns">
<title>ビューパターン
</title>

<para>
ビューパターンを有効にするフラグは<literal>-XViewPatterns</literal>である。ビューパターンに関するさらなる情報と実例は<ulink url="http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns">Wikiのページ</ulink>にある。
</para>

<para>
ビューパターンは、他のパターンの中に入れ子にして使えるパターンガードに少々似ていて、抽象型に対するパターン照合の方法として便利である。例えば、プログラミング言語の実装において、その言語の型の構文を以下のように表現することがあるかもしれない。
<programlisting>
type Typ

data TypView = Unit
             | Arrow Typ Typ

view :: Type -> TypeView

-- さらに、Typを構築するための演算が続く...
</programlisting>
Typの表現は抽象的なままにされているので、実装では手の込んだ表現(例えば共有を管理するためのhash-consing)を使うこともできる。

ビューパターンがないと、このシグネチャを使うのは少々不便である。
<programlisting>
size :: Typ -> Integer
size t = case view t of
  Unit -> 1
  Arrow t1 t2 -> size t1 + size t2
</programlisting>
等式を使った関数定義は使えず、このcaseを繰り返すしかない。さらに、<literal>t</literal>に関する照合が別のパターンの深くに埋まっている場合、状況はもっと悪くなる。</para>

<para>
ビューパターンを使うと、関数viewをパターンの中で呼んで、その結果に対して照合を行うことができる。
<programlisting>
size (view -> Unit) = 1
size (view -> Arrow t1 t2) = size t1 + size t2
</programlisting>
つまり、<replaceable>expression</replaceable> <literal>-></literal> <replaceable>pattern</replaceable>と書かれる新しい形式のパターンを追加したのである。これは、「照合対象にexpressionを適用し、その適用の結果をpatternに対して照合せよ」という意味である。expressionは関数の型を持つ任意のHaskellの式であり、ビューパターンはパターンが使えるところならどこにでも使える。
</para>

<para>
<literal>(</literal><replaceable>exp</replaceable> <literal>-></literal> <replaceable>pat</replaceable> <literal>)</literal>というパターンの意味論は以下の通り。

<itemizedlist>

<listitem>スコープ規則:

<para>このビューパターンによって束縛される変数は、<replaceable>pat</replaceable>によって束縛される変数である。
</para>

<para>
<replaceable>exp</replaceable>中の変数は全て束縛された出現である(訳注: 変数はどれも束縛されていなければいけない、換言すればスコープにある変数しか使ってはいけないということ)が、「左の方」のパターン中で束縛された変数はスコープにある。この特徴によって、例えば、ある関数のある引数を、別の引数のビューの中で使うことができる。例えば、<xref linkend="pattern-guards"/>に登場した関数<literal>clunky</literal>は、ビューパターンを使って次のように書ける。

<programlisting>
clunky env (lookup env -> Just val1) (lookup env -> Just val2) = val1 + val2
...clunkyのその他の等式...
</programlisting>
</para>

<para>
より精密に言うと、スコープ規則は以下の通りである。
<itemizedlist>
<listitem>
<para>
単一のパターンの中で、ビューパターンの左にあるパターンで束縛された変数はスコープにある。例。
<programlisting>
example :: Maybe ((String -> Integer,Integer), String) -> Bool
example Just ((f,_), f -> 4) = True
</programlisting>

さらに、関数定義において、カリー化された引数を照合することで束縛された変数は、その後の引数におけるビューパターン内で使うことができる。
<programlisting>
example :: (String -> Integer) -> String -> Bool
example f (f -> 4) = True
</programlisting>
つまり、この場合のスコープ割り当ては、カリー化された引数をタプルにまとめた場合と同じになる。
</para>
</listitem>

<listitem>
<para>
<literal>let</literal>や<literal>where</literal>、もしくは最上位のような相互再帰的な束縛において、ある宣言中のビューパターンが別の宣言によって束縛された変数に言及することはできない。つまり、それぞれの宣言が自己完結していなければならない。例えば、以下のプログラムは許されない。
<programlisting>
let {(x -> y) = e1 ;
     (y -> x) = e2 } in x
</programlisting>

(この設計上の決定について、よりはっきりと述べたものが<ulink url="http://hackage.haskell.org/trac/ghc/ticket/4061">Trac #4061</ulink>にある。)

</para>
</listitem>
</itemizedlist>

</para>
</listitem>

<listitem><para>型付け: もし<replaceable>exp</replaceable>の型が<replaceable>T1</replaceable> <literal>-></literal> <replaceable>T2</replaceable>で<replaceable>pat</replaceable>が<replaceable>T2</replaceable>型の値に照合するなら、ビューパターン全体で<replaceable>T1</replaceable>型の値に照合する。</para></listitem>

<listitem><para>照合: <ulink url="http://www.haskell.org/onlinereport/">Haskell 98レポート</ulink>の3.17.3節(<ulink url="http://www.sampou.org/haskell/report-revised-j/exps.html#sect3.17.3">和訳</ulink>)の等式群に、以下のものを加える。
<programlisting>
case v of { (e -> p) -> e1 ; _ -> e2 }
 =
case (e v) of { p -> e1 ; _ -> e2 }
</programlisting>
つまり、<literal>(</literal> <replaceable>exp</replaceable> <literal>-></literal> <replaceable>pat</replaceable> <literal>)</literal>というパターンに変数<replaceable>v</replaceable>を照合するには、<literal>(</literal><replaceable>exp</replaceable> <replaceable> v</replaceable><literal>)</literal>を評価し、その結果を<replaceable>pat</replaceable>に対して照合する。
</para></listitem>

<listitem><para>効率性: ある関数定義やcase式の中で、同じビュー関数が複数の選択肢の中で使われている(例えば上の<literal>size</literal>)場合、ビュー関数が一回しか適用されないように、GHCはその関数の適用を集約して一つのネストしたcase式にしようとする。GHCのパターンのコンパイルは、<ulink url="http://research.microsoft.com/~simonpj/Papers/slpj-book-1987/">The Implementation of Functional Programming Languages</ulink>の第四章にある行列アルゴリズムに従っている。ある行列の最初の列の上部の行いくつか(訳注: top rows)が全て「同じ」式を持つビューパターンであった場合、それらのパターンは一つのネストされたcaseに変換される。これには、例えば、tuple中で整列したの隣接ビューパターンが含まれる。以下のような場合である。
<programlisting>
f ((view -> A, p1), p2) = e1
f ((view -> B, p3), p4) = e2
</programlisting>
</para>

<para>二つのビューパターンがどんなときに「同じ」であるかの現在の描像は非常に制限されたもので、完全な構文的同値性ですらない。それでも、変数、リテラル、適用、それにタプルを含んでいる。例えば、<literal>view ("hi", "there")</literal>が二つあった場合、それはまとめられる。一方、現在の実装はα同値性に従った比較を行わないので、<literal>(x, view x -> y)</literal>が二つあっても合体することはない。
</para>

</listitem>

</itemizedlist>
</para>

</sect2>

    <!-- ===================== n+k patterns ===================  -->

<sect2 id="n-k-patterns">
<title>n+kパターン</title>
<indexterm><primary><option>-XNPlusKPatterns</option></primary></indexterm>

<para>
<literal>n+k</literal>パターンへの対応はデフォルトで無効になっている。有効にするには、<option>-XNPlusKPatterns</option>フラグが使える。
</para>

</sect2>

    <!-- ===================== Traditional record syntax ===================  -->

<sect2 id="traditional-record-syntax">
<title>伝統的なレコード構文</title>
<indexterm><primary><option>-XNoTraditionalRecordSyntax</option></primary></indexterm>

<para>
<literal>C {f = x}</literal>のような伝統的なレコード構文はデフォルトで有効になっている。無効にするには、<option>-XNoTraditionalRecordSyntax</option>フラグが使える。
</para>

</sect2>

    <!-- ===================== Recursive do-notation ===================  -->

<sect2 id="recursive-do-notation">
<title>再帰的do記法
</title>

<para>
Haskell 98のdo記法では、<emphasis>再帰的な束縛</emphasis>が許されない。すなわち、do式中で束縛された変数は、テキスト中でそれより後ろのコードブロックからのみ可視である。let式と比較せよ。let式では、束縛変数がその束縛グループ全体から可視である。</para>

<para>全てではないが色々なモナドに関して、do内でのこのような再帰的束縛が実際に意味のあることだということが分かった。特に、この意味での再帰は、使われているモナドについての不動点演算子を要求する。これは<literal>Control.Monad.Fix</literal>で次のように定義されている<literal>MonadFix</literal>クラスの<literal>mfix</literal>メソッドによって表現される。
<programlisting>
class Monad m => MonadFix m where
   mfix :: (a -> m a) -> m a
</programlisting>
Haskellの<literal>Maybe</literal>、<literal>[]</literal> (リスト)、<literal>ST</literal> (正確版と遅延版の両方)、<literal>IO</literal>や他の多くのモナドは<literal>MonadFix</literal>インスタンスを持つ。一方、シグネチャ<literal>(a -> r) -> r</literal>を持つ継続モナドはこのインスタンスを持たない。
</para>
<para><literal>MonadFix</literal>に属するモナドについては、再帰的束縛を許すようなdo記法の拡張をGHCが提供する。<option>-XRecursiveDo</option> (言語プラグマ: <literal>RecursiveDo</literal>)がキーワード<literal>mdo</literal>と<literal>rec</literal>を含む必要な構文的サポートを提供する。この二つのキーワードはそれぞれ高水準・低水準の記法に使う。<literal>do</literal>式内の束縛とは異なり、<literal>mdo</literal>や<literal>rec</literal>によって導入される束縛は、ちょうど通常のlet式と同様に再帰的に定義される。<literal>mdo</literal>キーワードにちなんで、この記法を<emphasis>mdo記法</emphasis>とも呼ぶ。
</para>

<para>
以下は(人為的だが)単純な例である。
<programlisting>
{-# LANGUAGE RecursiveDo #-}
justOnes = mdo { xs &lt;- Just (1:xs)
               ; return (map negate xs) }
</programlisting>
あるいは、以下も同等である
<programlisting>
{-# LANGUAGE RecursiveDo #-}
justOnes = do { rec { xs &lt;- Just (1:xs) }
              ; return (map negate xs) }
</programlisting>
推測できるだろうが、<literal>justOnes</literal>は<literal>Just [-1,-1,-1,...</literal>に評価される。
</para>

<para>GHCにおけるmdo記法の実装は論文<ulink url="https://sites.google.com/site/leventerkok/recdo.pdf">A recursive do for Haskell</ulink>に記述されている元々の翻訳規則に良く則っている。この論文は<ulink url="http://sites.google.com/site/leventerkok/erkok-thesis.pdf">Value Recursion in Monadic Computations</ulink>という仕事を基礎としている。さらに、GHCは前者の論文に記述されている構文を拡張し、<literal>rec</literal>キーワードで示される低水準の構文を導入する。これを次に述べる。
</para>

<sect3>
<title>再帰的束縛グループ</title>
<para>
フラグ<option>-XRecursiveDo</option>は、<literal>rec</literal>という新しいキーワードを導入する。これは、相互再帰的なモナド文の集りをまとめて、一つの文を作るものである。</para>
<para><literal>let</literal>文と同様に、<literal>rec</literal>で束縛された変数はその<literal>rec</literal>グループの全体と、その<literal>rec</literal>の下で可視である。例として、次の二つを比較せよ。
<programlisting>
    do { a &lt;- getChar            do { a &lt;- getChar
       ; let { r1 = f a r2          ; rec { r1 &lt;- f a r2
       ;     ; r2 = g r1 }          ;     ; r2 &lt;- g r1 }
       ; return (r1 ++ r2) }        ; return (r1 ++ r2) }
</programlisting>
どちらの場合でも、<literal>r1</literal>と<literal>r2</literal>は<literal>let</literal>や<literal>rec</literal>のブロック全体と、それ以降の文の中で使える。違いは、<literal>let</literal>が非モナド的であるのに対して、<literal>rec</literal>はモナド的であることだ。(周知のように、Haskellにおいて<literal>let</literal>とは実際には<literal>letrec</literal>のことである)
</para>
<para>
    <literal>rec</literal>の意味論はかなり単純である。GHCが<literal>rec</literal>グループを見付けると、それの束縛変数の集合を計算し、<literal>mfix</literal>への呼び出しを適切に導入する。<literal>mfix</literal>は基礎となるモナド的な値再帰演算子であり、<literal>MonadFix</literal>クラスに所属する。例を挙げる。
<programlisting>
rec { b &lt;- f a c     ===>    (b,c) &lt;- mfix (\~(b,c) -> do { b &lt;- f a c
    ; c &lt;- f b a }                                        ; c &lt;- f b a
                                                          ; return (b,c) })
</programlisting>
通常通り、<literal>b</literal>、<literal>c</literal>等のメタ変数は任意のパターンであって良い。一般に、<literal>rec <replaceable>ss</replaceable></literal>という文は、脱糖されて次のような文になる。
<programlisting>
<replaceable>vs</replaceable> &lt;- mfix (\~<replaceable>vs</replaceable> -&gt; do { <replaceable>ss</replaceable>; return <replaceable>vs</replaceable> })
</programlisting>
ただし、<replaceable>vs</replaceable>は<replaceable>ss</replaceable>によって束縛される変数群からなるタプルである。
</para>
<para><literal>rec</literal>ブロックの翻訳過程は、<literal>mfix</literal>への呼び出しをラップしているに過ぎないことに特に注意せよ。束縛についてのその他の分析はなされない。これは次に述べる<literal>mdo</literal>記法の役割である。
</para>
</sect3>

<sect3>
<title>mdo記法</title>

<para><literal>rec</literal>ブロックは、再帰的な結び目を正確にどこに作るのかをコンパイラに指示する。しかし、結び目の位置決めがかなり繊細な問題になることが分かった。特に、結び目は可能な限り小さいグループを包んで欲しい。この過程は分割(segmentation)と呼ばれ、<ulink url="http://sites.google.com/site/leventerkok/">A recursive do for Haskell</ulink>の3.2節に詳細な記述がある。分割によってよりよい多相性が得られ、再帰的な結び目の大きさが軽減される。最も重要なのは、これがモナド的再帰のいわゆる<emphasis>right-shrinking</emphasis>公理が持つ本質的な問題が引き起こす不必要な干渉を避ける点である。短かく言うと、意味のあるモナドの大部分(IO、正格Stateなど)はこの公理を満たす再帰演算子を<emphasis>持たない</emphasis>ため、分割を行なわないと不要な干渉が発生し、最終的な翻訳結果の停止性を変えることがある。(詳細は<ulink url="http://sites.google.com/site/leventerkok/erkok-thesis.pdf">Value Recursion in Monadic Computations</ulink>の3.1および7.2.2節にある)
</para>

<para><literal>mdo</literal>記法は、<literal>rec</literal>ブロックをコードに明示的に置くという負担を取り除く。文で束縛された変数がそれ以降の文からのみ可視になる通常の<literal>do</literal>式と異なり、<literal>mdo</literal>式で束縛された変数はその式の全ての文から可視である。コンパイラは相互再帰する文からなる最小の分割単位を自動的に発見し、ユーザがその周りを<literal>rec</literal>修飾子で囲んだかのように扱う。
</para>

<para>この定義は構文的である。
</para>
<itemizedlist>
   <listitem>
       <para>生成子<replaceable>g</replaceable>が、字句的にそれより後にある生成子<replaceable>g'</replaceable>に<emphasis>依存する</emphasis>のは、以下の場合である。
       </para>
       <itemizedlist>
         <listitem>
           <para><replaceable>g</replaceable>によって使われる変数を<replaceable>g'</replaceable>が定義する、または
           </para>
         </listitem>
         <listitem>
           <para>
           <replaceable>g'</replaceable>が字句的に<replaceable>g</replaceable>と<replaceable>g''</replaceable>の間に現れる。ここで<replaceable>g</replaceable>は<replaceable>g''</replaceable>に依存しているものとする。
           </para>
         </listitem>
       </itemizedlist>
   </listitem>
   <listitem>
       <para>与えられた<literal>mdo</literal>式の<emphasis>分割単位(segment)</emphasis>とは、生成子の列であって、その列内のいかなる生成子も列外の生成子に依存しないような最小の列である。特別な場合として、<literal>mdo</literal>式の最後の式は、生成子ではないにもかかわらず、単独で分割単位を構成するとみなされる。
       </para>
   </listitem>
 </itemizedlist>
<para>この意味での分割単位は<emphasis>強連結成分</emphasis>の解析に関係しているが、分割単位は並び換えることができず、連続していなければならないという点が違いである。
</para>

<para><literal>mdo</literal>式の例と、それの<literal>rec</literal>ブロックへの翻訳を示す。
<programlisting>
mdo { a &lt;- getChar      ===> do { a &lt;- getChar
    ; b &lt;- f a c                ; rec { b &lt;- f a c
    ; c &lt;- f b a                ;     ; c &lt;- f b a }
    ; z &lt;- h a b                ; z &lt;- h a b
    ; d &lt;- g d e                ; rec { d &lt;- g d e
    ; e &lt;- g a z                ;     ; e &lt;- g a z }
    ; putChar c }               ; putChar c }
</programlisting>
与えられた<literal>mdo</literal>式が複数の<literal>rec</literal>ブロックを作ることがあるのに注意。再帰的な依存関係がない場合、<literal>mdo</literal>は<literal>rec</literal>ブロックを一つも導入しない。この場合、予想される通り、<literal>mdo</literal>式は<literal>do</literal>式と全く同じである。
</para>

<para>要約すると、<literal>mdo</literal>式を与えられたとき、GHCはまず分割を行ない、最小の再帰グループを包む<literal>rec</literal>を導入する、次に、結果として生成された<literal>rec</literal>がそれぞれ、前の節で記述したように<literal>Control.Monad.Fix.mfix</literal>への呼び出しを使って脱糖される。最初の<literal>mdo</literal>式は、この脱糖済みのコードと全く同様に型検査される。
</para>

<para>
再帰的do記法を使うにあたって、他にもいくつか重要な点がある。
<itemizedlist>
    <listitem>
        <para>
            これは<literal>-XRecursiveDo</literal>フラグまたは<literal>LANGUAGE RecursiveDo</literal>プラグマで有効になる。(同じフラグが、<literal>mdo</literal>記法と<literal>do</literal>記法内の<literal>rec</literal>の使用の両方を有効にする)
        </para>
    </listitem>
    <listitem>
        <para>
            <literal>rec</literal>ブロックは<literal>mdo</literal>式の中でも使うことができ、単一の文として扱われる。ただし、一つの式では<literal>mdo</literal>か<literal>rec</literal>ブロックのどちらかを使うのが良いスタイルである。
        </para>
    </listitem>
    <listitem>
        <para>
            あるモナドに再帰的な束縛を使う必要があるなら、そのモナドは<literal>MonadFix</literal>クラスのインスタンスとして宣言されていなければならない。
        </para>
    </listitem>
    <listitem>
        <para>
            次の<literal>MonadFix</literal>インスタンスは自動的に提供される。List, Maybe, IO。さらに、Control.Monad.STとControl.Monad.ST.Lazyモジュールは、Haskellの(それぞれ正格と遅延の)内部的な状態モナドについてのMonadFixインスタンスを提供する。
        </para>
    </listitem>
    <listitem>
        <para>
            <literal>let</literal>束縛や<literal>where</literal>束縛と同様に、一つの<literal>rec</literal>の中での名前の覆い隠しは許されない。つまり、一つの<literal>rec</literal>で束縛される名前は全て異なっていなければならない(そうでなければGHCが文句を言う)。
        </para>
    </listitem>
</itemizedlist>
</para>
</sect3>

</sect2>


   <!-- ===================== PARALLEL LIST COMPREHENSIONS ===================  -->

  <sect2 id="parallel-list-comprehensions">
    <title>並行リスト内包表記</title>
    <indexterm><primary>list comprehensions</primary><secondary>parallel</secondary>
    </indexterm>
    <indexterm><primary>parallel list comprehensions</primary>
    </indexterm>

    <para>並行リスト内包表記はリスト内包表記を自然に拡張したものである。リスト内包表記は、mapとfilterを書くための扱いやすい構文と捉えることができる。並行内包表記はこれをzipWith系関数を含むように拡張するものである。</para>

    <para>並行リスト内包表記は複数の独立した枝からなり、「|」で区切られる。それぞれの枝には修飾子が並べられる。例えば、以下のものは二つのリストをzipする。</para>

<programlisting>
   [ (x, y) | x &lt;- xs | y &lt;- ys ]
</programlisting>

    <para>結果のリストは、最も短い枝と同じ長さになる。この点で、並行リスト内包表記の振る舞いはzipのものを踏襲している。</para>

    <para>通常の内包表記への変換を規定することによって並行リスト内包表記を定義することができる。以下に示すのは基本的な考え方である。</para>

    <para>次のような並行内包表記があったとする。</para>

<programlisting>
   [ e | p1 &lt;- e11, p2 &lt;- e12, ...
       | q1 &lt;- e21, q2 &lt;- e22, ...
       ...
   ]
</programlisting>

    <para>これは次のように変換される。</para>

<programlisting>
   [ e | ((p1,p2), (q1,q2), ...) &lt;- zipN [(p1,p2) | p1 &lt;- e11, p2 &lt;- e12, ...]
                                         [(q1,q2) | q1 &lt;- e21, q2 &lt;- e22, ...]
                                         ...
   ]
</programlisting>

    <para>ここで、「zipN」は、枝の数に応じた適切なzipである。</para>

  </sect2>

  <!-- ===================== TRANSFORM LIST COMPREHENSIONS ===================  -->

  <sect2 id="generalised-list-comprehensions">
    <title>一般化(SQL風)リスト内包表記</title>
    <indexterm><primary>list comprehensions</primary><secondary>generalised</secondary>
    </indexterm>
    <indexterm><primary>extended list comprehensions</primary>
    </indexterm>
    <indexterm><primary>group</primary></indexterm>
    <indexterm><primary>sql</primary></indexterm>


    <para>一般化リスト内包表記は、SQLでおなじみのソートやグループ化といった操作を可能にするための、リスト内包表記という構文糖に対するさらなる強化である。これは、論文<ulink url="http://research.microsoft.com/~simonpj/papers/list-comp">Comprehensive comprehensions: comprehensions with "order by" and "group by"</ulink>で完全に記述されている。ただし、我々が使う構文は論文のものと僅かに異なる。</para>
<para>この拡張は<option>-XTransformListComp</option>というフラグによって有効になる。</para>
<para>例を示す。
<programlisting>
employees = [ ("Simon", "MS", 80)
, ("Erik", "MS", 100)
, ("Phil", "Ed", 40)
, ("Gordon", "Ed", 45)
, ("Paul", "Yale", 60)]

output = [ (the dept, sum salary)
| (name, dept, salary) &lt;- employees
, then group by dept using groupWith
, then sortWith by (sum salary)
, then take 5 ]
</programlisting>
この例では、リスト<literal>output</literal>の値は次のようになる。
<programlisting>
[("Yale", 60), ("Ed", 85), ("MS", 180)]
</programlisting>
</para>
<para>新しいキーワードが三つある。<literal>group</literal>、<literal>by</literal>、<literal>using</literal>である。(関数<literal>sortWith</literal>と<literal>groupWith</literal>はキーワードではない。<literal>GHC.Exts</literal>からエクスポートされている普通の関数である。)</para>

<para>内包表記修飾子の新しい形式が五つあり、すべて(既存の)キーワード<literal>then</literal>で導入される。
    <itemizedlist>
    <listitem>

<programlisting>
then f
</programlisting>

この文は、<literal>f</literal>が型<literal>forall a. [a] -> [a]</literal>を持つことを要求する。これの使用例として、最初にあげた例では<literal>take 5</literal>を適用するのに使われている。

    </listitem>


    <listitem>
<para>
<programlisting>
then f by e
</programlisting>

この形式は上のものに似ているが、fの最初の引数として渡される関数を作ることができる。そのため、fの型は<literal>forall a. (a -> t) -> [a] -> [a]</literal>でなければならない。型から分かるように、この関数は、変形対象のリストの要素からfがなんらかの情報を「射影抽出(project out)」できるようにするものである。</para>

    <para>ひとつの例が最初の例にある。この例では、変換されるリストの任意の要素について<literal>sortWith</literal>が<literal>sum salary</literal>を見つけ出すのに使われる関数が、<literal>sortWith</literal>への引数として与えられている。</para>

    </listitem>


    <listitem>

<programlisting>
then group by e using f
</programlisting>

    <para>グループ化系統の文のうち、最も一般的な形がこれである。この形式では、fの型が<literal>forall a. (a -> t) -> [a] -> [[a]]</literal>であることが要求される。上の<literal>then f by e</literal>の場合と同様、最初の引数はコンパイラによってfに与えられる。これは、変換対象のリストの各要素についてfがeを計算することができるようにする関数である。しかし、グループ化以外の場合と異なり、fはさらに対象のリストをいくつかの部分リストに分割する。これによって、この文以降のあらゆる点において、内包表記中でこれ以前に現われた束縛は、単一の値ではなく可能な値の<emphasis>リスト</emphasis>を指すようになる。これを理解する助けになるように、ひとつの例を見てみよう。</para>

<programlisting>
-- これはGHC.ExtsのgroupWithと同様に働くが、最初に入力をソートしない
groupRuns :: Eq b => (a -> b) -> [a] -> [[a]]
groupRuns f = groupBy (\x y -> f x == f y)

output = [ (the x, y)
| x &lt;- ([1..3] ++ [1..2])
, y &lt;- [4..6]
, then group by x using groupRuns ]
</programlisting>

    <para>結果として、変数<literal>output</literal>は次に示す値を取る。</para>

<programlisting>
[(1, [4, 5, 6]), (2, [4, 5, 6]), (3, [4, 5, 6]), (1, [4, 5, 6]), (2, [4, 5, 6])]
</programlisting>

    <para>関数<literal>the</literal>を使って、xの型をリストから元の数値型に戻したのに注意。対照的に、変数yは、グループ化によって導入されたリスト形式のままにしてある。</para>

    </listitem>

    <listitem>

<programlisting>
then group using f
</programlisting>

    <para>この形式のgroup文では、fの型は単純に<literal>forall a. [a] -> [[a]]</literal>である必要があり、ここまでの内包を直接グループ化するのに使われる。この形式の例を以下に示す。</para>

<programlisting>
output = [ x
| y &lt;- [1..5]
, x &lt;- "hello"
, then group using inits]
</programlisting>

    <para>結果は、「hello」という単語を五回並べた文字列の、すべての前方部分列(prefix)を含むリストになる。</para>

<programlisting>
["","h","he","hel","hell","hello","helloh","hellohe","hellohel","hellohell","hellohello","hellohelloh",...]
</programlisting>

    </listitem>
</itemizedlist>
</para>
  </sect2>

   <!-- ===================== MONAD COMPREHENSIONS ===================== -->

<sect2 id="monad-comprehensions">
    <title>Monad内包表記</title>
    <indexterm><primary>monad comprehensions</primary></indexterm>

    <para>モナド内包表記はリスト内包表記をあらゆるモナドに一般化したものである。これには並列内包表記(<xref linkend="parallel-list-comprehensions"/>)と変換内包表記(<xref linkend="generalised-list-comprehensions"/>)を含む。
    </para>

    <para>モナド内包表記は以下のものに対応する。</para>

    <itemizedlist>
        <listitem>
            <para>
                束縛:
            </para>

<programlisting>
[ x + y | x &lt;- Just 1, y &lt;- Just 2 ]
</programlisting>

            <para>束縛は、<literal>(&gt;&gt;=)</literal>と<literal>return</literal>を使って、次のような通常のdo記法に翻訳される。</para>

<programlisting>
do x &lt;- Just 1
   y &lt;- Just 2
   return (x+y)
</programlisting>

        </listitem>
        <listitem>
            <para>
                ガード:
            </para>

<programlisting>
[ x | x &lt;- [1..10], x &lt;= 5 ]
</programlisting>

            <para>ガードは<literal>guard</literal>関数を使って翻訳される。これには<literal>MonadPlus</literal>インスタンスが必要である。
            </para>

<programlisting>
do x &lt;- [1..10]
   guard (x &lt;= 5)
   return x
</programlisting>

        </listitem>
        <listitem>
            <para>変換文(<literal>-XTransformListComp</literal>を付けた場合と同様)。
            </para>

<programlisting>
[ x+y | x &lt;- [1..10], y &lt;- [1..x], then take 2 ]
</programlisting>

            <para>これは、以下のものに翻訳される。
            </para>

<programlisting>
do (x,y) &lt;- take 2 (do x &lt;- [1..10]
                       y &lt;- [1..x]
                       return (x,y))
   return (x+y)
</programlisting>

        </listitem>
        <listitem>
            <para>グループ化文(<literal>-XTransformListComp</literal>を付けた場合と同様)
            </para>

<programlisting>
[ x | x &lt;- [1,1,2,2,3], then group by x using GHC.Exts.groupWith ]
[ x | x &lt;- [1,1,2,2,3], then group using myGroup ]
</programlisting>

        </listitem>
        <listitem>
            <para>並列な文(<literal>-XParallelListComp</literal>付きの場合と同様)
            </para>

<programlisting>
[ (x+y) | x &lt;- [1..10]
        | y &lt;- [11..20]
        ]
</programlisting>

            <para>並列な文は<literal>mzip</literal>関数を使って翻訳される。これには<ulink url="&libraryBaseLocation;/Control-Monad-Zip.html"><literal>Control.Monad.Zip</literal></ulink>で定義されている<literal>MonadZip</literal>のインスタンスが必要である。</para>

<programlisting>
do (x,y) &lt;- mzip (do x &lt;- [1..10]
                     return x)
                 (do y &lt;- [11..20]
                     return y)
   return (x+y)
</programlisting>

        </listitem>
    </itemizedlist>

    <para><literal>MonadComprehensions</literal>拡張が有効なら、これらの機能が全て有効になる。内包表記の種類と、より詳細な使い方については、前の章、<xref linkend="generalised-list-comprehensions"/>と<xref linkend="parallel-list-comprehensions"/>に説明がある。一般に、モナド内包表記用に型<literal>[a]</literal>を型<literal>Monad m => m a</literal>に置き換えるだけで良い。</para>

    <para>注意: これらの例示ではほとんどリストモナドしか使っていないが、モナド内包表記はあらゆるモナドに対して働く。リストに関して必要なインスタンスは全て<literal>base</literal>パッケージが提供する。これによって<literal>MonadComprehensions</literal>が組み込みのリスト内包表記、変換内包表記、並列内包表記と後方互換になる。
    </para>
<para>より形式的には、脱糖は以下のように行われる。以下ではモナド内包表記<literal>[ e | Q]</literal>を脱糖したものを<literal>D[ e | Q]</literal>と書く。
<programlisting>
式: e
宣言: d
修飾子リスト: Q,R,S

-- 基本形
D[ e | ]               = return e
D[ e | p &lt;- e, Q ]  = e &gt;&gt;= \p -&gt; D[ e | Q ]
D[ e | e, Q ]          = guard e &gt;&gt; \p -&gt; D[ e | Q ]
D[ e | let d, Q ]      = let d in D[ e | Q ]

-- 並列内包表記 (並列な枝が複数あるならこれを繰り返す)
D[ e | (Q | R), S ]    = mzip D[ Qv | Q ] D[ Rv | R ] &gt;&gt;= \(Qv,Rv) -&gt; D[ e | S ]

-- 変換内包表記
D[ e | Q then f, R ]                  = f D[ Qv | Q ] &gt;&gt;= \Qv -&gt; D[ e | R ]

D[ e | Q then f by b, R ]             = f (\Qv -&gt; b) D[ Qv | Q ] &gt;&gt;= \Qv -&gt; D[ e | R ]

D[ e | Q then group using f, R ]      = f D[ Qv | Q ] &gt;&gt;= \ys -&gt;
                                        case (fmap selQv1 ys, ..., fmap selQvn ys) of
                                 	     Qv -&gt; D[ e | R ]

D[ e | Q then group by b using f, R ] = f (\Qv -&gt; b) D[ Qv | Q ] &gt;&gt;= \ys -&gt;
                                        case (fmap selQv1 ys, ..., fmap selQvn ys) of
                                           Qv -&gt; D[ e | R ]

ただし、QvはQで束縛された変数(のうち後で使われるもの)のタプルであり、
       selQviはQvをその第i成分に写すセレクタである

演算子       標準の束縛             期待される型
--------------------------------------------------------------------
return       GHC.Base               t1 -&gt; m t2
(&gt;&gt;=)        GHC.Base               m1 t1 -&gt; (t2 -&gt; m2 t3) -&gt; m3 t3
(&gt;&gt;)         GHC.Base               m1 t1 -&gt; m2 t2         -&gt; m3 t3
guard        Control.Monad          t1 -&gt; m t2
fmap         GHC.Base               forall a b. (a-&gt;b) -&gt; n a -&gt; n b
mzip         Control.Monad.Zip      forall a b. m a -&gt; m b -&gt; m (a,b)
</programlisting>
内包表記は、それを脱糖したものが型検査に通るなら型検査に通るべきである。
</para>
<para>
モナド内包表記は構文の再束縛(<xref linkend="rebindable-syntax"/>)に対応している。構文の再束縛なしの場合、「標準の束縛」で定義された演算子が使われる。構文の再束縛が有効な場合、各演算子は現在の字句的スコープから引かれる。例えば、並列内包表記は、スコープにある"<literal>mzip</literal>"をなんであれ使って型検査・脱糖される。</para>
<para>
再束縛される演算子は上の表にある「期待される型」を持っていなければならない。これらの型は驚くほど一般的である。例えば、次のような型を持つバインド演算子を使うことができる。
<programlisting>
(>>=) :: T x y a -> (a -> T y z b) -> T x z b
</programlisting>
変換内包表記の場合には、内包表記が任意のモナドに関する物であるだけでなく、グループが任意の(<literal>fmap</literal>を持つ)型<literal>n</literal>に関してパラメタ化されている。
</para>
</sect2>

   <!-- ===================== REBINDABLE SYNTAX ===================  -->
<sect2 id="rebindable-syntax">
<title>再束縛可能な構文とPreludeの暗黙インポート</title>

<para><indexterm><primary>-XNoImplicitPrelude option</primary></indexterm>GHCは通常<filename>Prelude.hi</filename>を自動的にインポートする。これが嫌なら、<option>-XNoImplicitPrelude</option>を使うと良い。こうすれば、自分自身のPreludeをインポートすることができる。(ただし、それに<literal>Prelude</literal>という名前をつけてはいけない。Haskellではモジュールの名前空間は平坦なので、Preludeモジュールと衝突を起こしてはならないのだ)</para>

            <para>自分で数値クラスの階層を定義するために、自作のプレリュードを実装しているとしよう。しかし、リテラルの「1」が、Haskellレポートの指定通りに<literal>Prelude.fromInteger 1</literal>を意味するとしたら、これは完全な無駄骨である。このため、<option>-XRebindableSyntax</option>フラグを使った場合には、以下に挙げる組込み構文は(Preludeのものではなく)<emphasis>スコープにあるものならなんでも</emphasis>使うようになる。
	    <itemizedlist>
	      <listitem>
		<para>整数リテラル<literal>368</literal>の意味は「<literal>fromInteger (368::Integer)</literal>」であり、「<literal>Prelude.fromInteger (368::Integer)</literal>」ではない。</para> </listitem>	

      <listitem><para>小数リテラルも全く同じように扱われる。変換は<literal>fromRational (3.68::Rational)</literal>である。
</para> </listitem>	

	  <listitem><para>多重定義された数値的パターンでの等値比較では、とにかくスコープにある<literal>(==)</literal>を使う。</para> </listitem>	

	  <listitem><para><literal>n+k</literal>パターンにおける減算演算およびだいなりいこーる比較では、とにかくスコープにある<literal>(-)</literal>と<literal>(>=)</literal>を使う。</para></listitem>

	      <listitem>
                <para>符号反転(例えば「<literal>- (f x)</literal>」)は、数値パターンでも式中でも「<literal>negate (f x)</literal>」を意味する。</para></listitem>

	      <listitem>
		<para>条件分岐(例えば、 "<literal>if</literal> e1 <literal>then</literal> e2 <literal>else</literal> e3")は"<literal>ifThenElse</literal> e1 e2 e3"を意味する。ただし<literal>case</literal>式は影響を受けない。</para></listitem>

	      <listitem>
	  <para>do記法の変換時にはとにかくスコープにある<literal>(>>=)</literal>、<literal>(>>)</literal>、<literal>fail</literal>が使われる。リスト内包表記、mdo(<xref linkend="recursive-do-notation"/>)、並行配列内包表記は影響を受けない。</para></listitem>

	      <listitem>
                <para>アロー記法(<xref linkend="arrow-notation"/>を見よ)では、とにかくスコープにある<literal>arr</literal>、<literal>(>>>)</literal>、<literal>first</literal>、<literal>app</literal>、<literal>(|||)</literal>、<literal>loop</literal>の各関数が使われる。ただし、他の構文要素の場合と異なり、これらの関数の型はPreludeのものとかなり良く近似していなければならない。詳細は固まっていので、もしこれを使いたいなら、声を掛けてほしい。
	      </para></listitem>
	    </itemizedlist>
<option>-XRebindableSyntax</option>は、<option>-XNoImplicitPrelude</option>を自動的に有効にする。
</para>
<para>
どの場合でも(アロー記法は例外)、コードの静的意味は脱糖された形でのそれと等しくなるはずである。これは少々予想に反するかもしれない。例えば、<literal>368</literal>というリテラルの静的意味は<literal>fromInteger (368::Integer)</literal>のそれとまったく同じである。従って、<literal>fromInteger</literal>は下に挙げるどんな型をもっていても良い。
<programlisting>
fromInteger :: Integer -> Integer
fromInteger :: forall a. Foo a => Integer -> a
fromInteger :: Num a => a -> Integer
fromInteger :: Integer -> Bool -> Bool
</programlisting>
</para>
	
             <para>警告: これは実験的な機能であり、通常ほど検査がなされない。脱糖されたプログラムを型検査するには<literal>-dcore-lint</literal>を使う。Core Lintが満足しているなら、問題ないはずである。</para>

</sect2>

<sect2 id="postfix-operators">
<title>後置演算子</title>

<para>
<option>-XPostfixOperators</option>フラグを使うと、演算子の左セクションの構文に小さな拡張が有効になり、これを使って後置演算子を定義することができるようになる。拡張とはこうである。以下のような左セクションがあったとしよう。
<programlisting>
  (e !)
</programlisting>
これは、(型検査と実行の両面において)以下の式と等しい。
<programlisting>
  ((!) e)
</programlisting>
(これは式<literal>e</literal>が何であっても、また演算子<literal>(!)</literal>が何であっても成り立つ)。Haskell 98の厳密な解釈では、このセクションは以下と同等だとされる。
<programlisting>
  (\y -> (!) e y)
</programlisting>
つまり、演算子は二引数の関数でなければならない。GHCでは一引数の関数であっても良く、結果として、関数を後置記法で書くことができるようになる。
</para>
<para>この拡張は関数定義の左辺には及ばない。従って、このような関数を定義するときには前置形を使わなければならない。</para>

</sect2>

<sect2 id="tuple-sections">
<title>タプルのセクション</title>

<para>
<option>-XTupleSections</option>フラグは、タプルの構築子をPython風に部分適用することを有効にする。例として、以下のプログラム
<programlisting>
  (, True)
</programlisting>
は、次の不恰好な表記と同じ意味の書き方とみなされる。
<programlisting>
  \x -> (x, True)
</programlisting>
タプルの引数はどんな組み合わせで省略してもよい。以下のように。
<programlisting>
  (, "I", , , "Love", , 1337)
</programlisting>
これは、次のように翻訳される。
<programlisting>
  \a b c d -> (a, "I", b, c, "Love", d, 1337)
</programlisting>
</para>

<para>
<link linkend="unboxed-tuples">unboxed tuples</link>を有効にしているなら、これについてもセクションが使える。例えば、
<programlisting>
  (# , True #)
</programlisting>
非ボックス化タプルにゼロ項のものはないので、次の式
<programlisting>
  (# #)
</programlisting>
は、変わらず非ボックス化単項タプルの構築子を意味する。
</para>

</sect2>

<sect2 id="lambda-case">
<title>ラムダcase</title>
<para>
<option>-XLambdaCase</option>フラグは以下の形の式を有効にする。
<programlisting>
  \case { p1 -> e1; ...; pN -> eN }
</programlisting>
これは以下と同等である。
<programlisting>
  \freshName -> case freshName of { p1 -> e1; ...; pN -> eN }
</programlisting>
<literal>\case</literal>はレイアウトを開始するので、以下のように書けることに注意。
<programlisting>
  \case
    p1 -> e1
    ...
    pN -> eN
</programlisting>
</para>
</sect2>

<sect2 id="multi-way-if">
<title>多選択肢のif式</title>
<para>
<option>-XMultiWayIf</option>フラグを使うと、GHCは以下のように複数の選択肢を持つ条件式を受け付ける。
<programlisting>
  if | guard1 -> expr1
     | ...
     | guardN -> exprN
</programlisting>
これは、だいたい次のものと同等である。
<programlisting>
  case () of
    _ | guard1 -> expr1
    ...
    _ | guardN -> exprN
</programlisting>
ただし、多選択肢のif式はレイアウトに変更を加えない。
</para>
</sect2>

<sect2 id="disambiguate-fields">
<title>レコードフィールドの曖昧性除去</title>
<para>
レコードの構築とパターンマッチにおいては、仮に同じフィールド名を持つデータ型が二つスコープにあったとしても、どのフィールドが言及されているのか全く曖昧でない。例えば以下のように。
<programlisting>
module M where
  data S = MkS { x :: Int, y :: Bool }

module Foo where
  import M

  data T = MkT { x :: Int }

  ok1 (MkS { x = n }) = n+1   -- 曖昧でない
  ok2 n = MkT { x = n+1 }     -- 曖昧でない

  bad1 k = k { x = 3 }  -- 曖昧
  bad2 k = x k          -- 曖昧
</programlisting>
スコープには二つの<literal>x</literal>があるが、<literal>ok1</literal>の定義中のパターンにおける<literal>x</literal>は、型<literal>S</literal>のフィールドを指す他にないということが明白である。関数<literal>ok2</literal>についても同様である。しかし、<literal>bad1</literal>におけるレコード更新と、<literal>bad2</literal>におけるレコード選択では、どちらの型が意図されているか明確でない。
</para>
<para>
Haskell 98はこの四つすべてを曖昧であると見做すが、<option>-XDisambiguateRecordFields</option>が与えられると、GHCは前者二つを認める。この規則は、Haskell 98でのインスタンス宣言の規則(インスタンス宣言中のメソッド束縛の左辺のメソッド名は曖昧さなくそのクラスのメソッドを(スコープにあれば)参照し、スコープに同名の別の変数があっても構わないとする)と全く同じである。これによって、異なるモジュールから同じフィールド名を使う二つのレコードをインポートしたときに、修飾名がそこらに散らばるのを軽減できる。
</para>
<para>
詳細をいくつか。
<itemizedlist>
<listitem><para>
フィールドの曖昧性除去は同名利用(<xref linkend="record-puns"/>を見よ)と組み合わせることができる。例。
<programlisting>
module Foo where
  import M
  x=True
  ok3 (MkS { x }) = x+1   -- 曖昧性除去と同名利用を両方使っている
</programlisting>
</para></listitem>

<listitem><para>
<option>-XDisambiguateRecordFields</option>が有効なら、対応する選択関数が<emphasis>修飾された</emphasis>形でしかスコープにない場合であっても、<emphasis>修飾されていない</emphasis>フィールド名を使うことができる。例えば、先に挙げた例と同じ<literal>M</literal>モジュールがあると仮定すると、これは合法である。
<programlisting>
module Foo where
  import qualified M    -- qualifiedであることに注意

  ok4 (M.MkS { x = n }) = n+1   -- 曖昧でない
</programlisting>
構築子<literal>MkS</literal>は修飾された形でしかスコープにないので、<literal>M.MkS</literal>と呼ばなければならない。しかし、スコープに<literal>M.x</literal>があっても<literal>x</literal>がないにもかかわらず、フィールド<literal>x</literal>を修飾する必要はない。(実質的に、これは構築子によって修飾されている)
</para></listitem>
</itemizedlist>
</para>

</sect2>

    <!-- ===================== Record puns ===================  -->

<sect2 id="record-puns">
<title>レコード同名利用
</title>

<para>
レコード同名利用(訳注: record puns; punは「駄洒落」「語呂合わせ」の意)は、<literal>-XNamedFieldPuns</literal>フラグによって有効になる。
</para>

<para>
レコードを使うとき、フィールド名と同じ名前の変数を束縛するようなパターンを書くことがよくある。以下のような場合である。

<programlisting>
data C = C {a :: Int}
f (C {a = a}) = a
</programlisting>
</para>

<para>
レコード同名利用は、この変数名を省略することを可能にする。よって、上と同じことを単に次のように書くことができる。

<programlisting>
f (C {a}) = a
</programlisting>

つまり、レコードパターン中において、<literal>a</literal>というパターンは<literal>a = a</literal>というパターン(同じ<literal>a</literal>という名前についての)に展開される。
</para>

<para>
以下のことに注意。
<itemizedlist>
<listitem><para>
レコード同名利用は式中でも使える。例えば、次のように書く。
<programlisting>
let a = 1 in C {a}
</programlisting>
これは次のものと同等である。
<programlisting>
let a = 1 in C {a = a}
</programlisting>

この展開は純粋に構文上のものであるため、レコード同名利用の式は、そのフィールド名と同じ綴りを持つなかで、最も内側の変数を参照する。
</para></listitem>

<listitem><para>
同じレコード中で、同名利用と通常のパターンを混ぜることができる。
<programlisting>
data C = C {a :: Int, b :: Int}
f (C {a, b = 4}) = a
</programlisting>
</para></listitem>

<listitem><para>
同名利用は、レコードパターンが使えるところ(例えば<literal>let</literal>束縛の中や最上位)ならどこでも使うことができる。
</para></listitem>

<listitem><para>
フィールド名が修飾されている場合は、その同名利用が展開されるときに修飾が取り除かれる。例えば、
<programlisting>
f (C {M.a}) = a
</programlisting>
は、
<programlisting>
f (M.C {M.a = a}) = a
</programlisting>
を意味する。(これは、構築子<literal>M.C</literal>のフィールド選択関数<literal>a</literal>が修飾された形でのみスコープにある場合に便利である)
</para></listitem>
</itemizedlist>
</para>

</sect2>

    <!-- ===================== Record wildcards ===================  -->

<sect2 id="record-wildcards">
<title>レコードワイルドカード
</title>

<para>
レコードワイルドカードは<literal>-XRecordWildCards</literal>フラグによって有効になる。このフラグによって<literal>-XDisambiguateRecordFields</literal>も有効になる。
</para>

<para>
沢山のフィールドのあるレコードでは、レコードパターンにおいてフィールドをいちいち書き下すのが面倒なことがある。次のような場合である。
<programlisting>
data C = C {a :: Int, b :: Int, c :: Int, d :: Int}
f (C {a = 1, b = b, c = c, d = d}) = b + c + d
</programlisting>
</para>

<para>
レコードワイルドカード構文では、レコードパターン中に「<literal>..</literal>」を使えるようになる。そうすると、省略したそれぞれの<literal>f</literal>が<literal>f = f</literal>というパターンに置換される。例として、上のパターンは次のように書ける。
<programlisting>
f (C {a = 1, ..}) = b + c + d
</programlisting>
</para>

<para>
さらなる詳細。
<itemizedlist>
<listitem><para>
ワイルドカードは他のパターン(同名利用(<xref linkend="record-puns"/>)も含む)と併用できる。例えば<literal>C {a = 1, b, ..})</literal>というパターンでのように。さらに、レコードワイルドカードはレコードパターンが使えるところならどこでも使えるので、<literal>let</literal>束縛や最上位でも使える。例えば、次の最上位の束縛は、<literal>b</literal>と<literal>c</literal>と<literal>d</literal>を定義する。
<programlisting>
C {a = 1, ..} = e
</programlisting>
</para></listitem>

<listitem><para>
レコードワイルドカードは式中でも使える。次のように書くことができる。
<programlisting>
let {a = 1; b = 2; c = 3; d = 4} in C {..}
</programlisting>
これは以下のように書くのと同じである。
<programlisting>
let {a = 1; b = 2; c = 3; d = 4} in C {a=a, b=b, c=c, d=d}
</programlisting>
この展開は純粋に構文上のものなので、レコードワイルドカード式は、省略されたフィールド名と同じ綴りの変数のうちもっとも内側にあるものを参照する。
</para></listitem>

<listitem><para>
「<literal>..</literal>」は省略された<emphasis>スコープにある</emphasis>レコードフィールドに展開される。より精密には、"<literal>C {..}</literal>"の展開が<literal>f</literal>を含むのは、以下の条件が成り立つ場合、そしてその場合に限る。
<itemizedlist>
<listitem><para>
<literal>f</literal>が構築子<literal>C</literal>のレコードフィールドである。
</para></listitem>
<listitem><para>
なんらかの形で<literal>f</literal>がスコープにある(修飾形でも、非修飾形でも)。
</para></listitem>
<listitem><para>
(パターンでなく)式の場合、変数<literal>f</literal>が、レコードセレクタ自身の束縛とは別に、非修飾形でスコープにある。
</para></listitem>
</itemizedlist>
例を示す。
<programlisting>
module M where
  data R = R { a,b,c :: Int }
module X where
  import M( R(a,b) )
  f b = R { .. }
</programlisting>
この<literal>R{..}</literal>は<literal>R{M.a=a}</literal>に展開される。<literal>b</literal>はレコードフィールドがスコープにないので省略される。<literal>c</literal>は変数<literal>c</literal>がスコープにない(もちろん、レコード選択子<literal>c</literal>の束縛を除いて)ので省略される。
</para></listitem>
</itemizedlist>
</para>

</sect2>

    <!-- ===================== Local fixity declarations ===================  -->

<sect2 id="local-fixity-declarations">
<title>局所結合性宣言
</title>

<para>Haskell 98レポートを注意深く読むと、<literal>let</literal>や<literal>where</literal>で導入される局所束縛の内部に結合性宣言(<literal>infix</literal>、<literal>infixl</literal>、<literal>infixr</literal>)が出現することが許されていることが分かる。しかし、このような束縛の意味論について、Haskellレポートはあまり詳しく規定していない。
</para>

<para>GHCでは、次のように、局所束縛に結合性宣言が付属していてもよい。
<programlisting>
let f = ...
    infixr 3 `f`
in
    ...
</programlisting>
そして、この結合性宣言は、この束縛がスコープにあるようなあらゆる場所で適用される。例えば、<literal>let</literal>式なら、他の<literal>let</literal>束縛の右辺と<literal>let</literal>式の本体で適用される。また、再帰的<literal>do</literal>式(<xref linkend="recursive-do-notation"/>)では、<literal>let</literal>文の局所結合性宣言は、束縛される名前と同様に、そのグループの全ての文に渡るスコープを持つ。
</para>

<para>
さらに、局所結合性宣言にはその名前についての局所束縛が付属「していなければならない」。次のように、別の場所で束縛された名前の結合性を設定しなおすことは不可能である。
<programlisting>
let infixr 9 $ in ...
</programlisting>

局所結合性宣言は技術的にHaskell 98なので、有効にするのにフラグは必要ない。
</para>
</sect2>

<sect2 id="package-imports">
  <title>パッケージ修飾されたインポート</title>

  <para><option>-XPackageImports</option>フラグが有効なら、GHCは、インポート宣言を、インポート先のモジュールが属しているべきパッケージ名で修飾することを認める。例をあげる。</para>

<programlisting>
import "network" Network.Socket
</programlisting>

  <para>こうすると、<literal>network</literal>パッケージ(のいずれかのバージョン)から<literal>Network.Socket</literal>をインポートすることになる。これは、同じモジュールが複数のパッケージから利用できたり、現在ビルド中のパッケージと外部のパッケージの両方にあったりする場合に、インポートの曖昧性を取り除くために使うことができる。</para>

  <para>注意: おそらく、あなたがこの機能を使う必要はないだろう。この機能は、主に我々がAPIの変更に際して後方互換なパッケージのバージョンをビルドすることができるように追加されたものである。一般的な事例では、この機能を使うと脆い依存が発生しやすい。モジュールはあるパッケージから別のパッケージに移ることがあり、その場合パッケージ修飾されたインポートは壊れるからである。</para>
</sect2>

<sect2 id="safe-imports-ext">
  <title>safeインポート</title>

  <para><option>-XSafe</option>、<option>-XTrustworthy</option>、<option>-XUnsafe</option>のいずれかのフラグを付けると、GHCはimport宣言の構文を拡張して<literal>import</literal>キーワードの後に任意で<literal>safe</literal>キーワードを受け取るようにする。この機能はSafe HaskellというGHC拡張の一部である。例えば、</para>

<programlisting>
import safe qualified Network.Socket as NS
</programlisting>

  <para>は、<literal>Network.Socket</literal>モジュールをインポートするが、Network.Socketが安全にインポートできる場合にしかコンパイルに成功しない。importがどういう場合に安全だとみなされるかの記述は<xref linkend="safe-haskell"/>を見よ。</para>
</sect2>

<sect2 id="syntax-stolen">
<title>盗まれた構文の概略</title>

    <para>専用の構文を有効にするオプションを使うと、Haskell 98で動作していたコードがコンパイルできなくなる<emphasis>可能性がある</emphasis>。これは大抵、変数名として使われていたものが予約語になることが原因である。この節では、言語拡張によって「盗まれた」構文を列挙する。ここではHaskell 98の字句構文(Haskell 98レポートを見よ)の記法と非終端記号を使っている。構文の変更については、既存の正しいプログラムに影響する可能性のあるもの(「盗まれた」構文)のみを列挙する。多くの拡張は新しい文脈自由構文を導入するが、これらの場合は例外なく、新しい構文を使って書かれたプログラムは適当なオプションなしではコンパイルできない。</para>

    <para>専用の構文には次の二種類がある。</para>

    <itemizedlist>
      <listitem>
        <para>新しい予約語や予約シンボル。もはやプログラムで識別子として使うことのできない文字列である。</para>
      </listitem>
      <listitem>
        <para>その他の専用構文。特定のオプションが有効になっていると別の意味を持つような文字の列。</para>
      </listitem>
    </itemizedlist>

<para>盗まれるのは以下の構文である。</para>

    <variablelist>
      <varlistentry>
	<term>
          <literal>forall</literal>
          <indexterm><primary><literal>forall</literal></primary></indexterm>
	</term>
	<listitem><para><option>-XExplicitForAll</option>によって盗まれる(型中において)。従って、<option>-XScopedTypeVariables</option>、<option>-XLiberalTypeSynonyms</option>、<option>-XRank2Types</option>、<option>-XRankNTypes</option>、<option>-XPolymorphicComponents</option>、<option>-XExistentialQuantification</option>によっても盗まれる。
	  </para></listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>mdo</literal>
          <indexterm><primary><literal>mdo</literal></primary></indexterm>
	</term>
	<listitem><para>
	<option>-XRecursiveDo</option>に盗まれる。
	  </para></listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>foreign</literal>
          <indexterm><primary><literal>foreign</literal></primary></indexterm>
	</term>
	<listitem><para>
	<option>-XForeignFunctionInterface</option>に盗まれる。
	  </para></listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>rec</literal>、<literal>proc</literal>、<literal>-&lt;</literal>、<literal>&gt;-</literal>、<literal>-&lt;&lt;</literal>、<literal>&gt;&gt;-</literal>、および<literal>(|</literal>、<literal>|)</literal>の括弧
          <indexterm><primary><literal>proc</literal></primary></indexterm>
	</term>
	<listitem><para>
	<option>-XArrows</option>によって盗まれる。
	  </para></listitem>
      </varlistentry>

      <varlistentry>
	<term>
	  <literal>?<replaceable>varid</replaceable></literal>,
	  <literal>%<replaceable>varid</replaceable></literal>
          <indexterm><primary>implicit parameters</primary></indexterm>
	</term>
	<listitem><para>
	<option>-XImplicitParams</option>によって盗まれる。
	  </para></listitem>
      </varlistentry>

      <varlistentry>
	<term>
	  <literal>[|</literal>,
	  <literal>[e|</literal>, <literal>[p|</literal>,
	  <literal>[d|</literal>, <literal>[t|</literal>,
	  <literal>$(</literal>,
	  <literal>$<replaceable>varid</replaceable></literal>
          <indexterm><primary>Template Haskell</primary></indexterm>
	</term>
	<listitem><para>
	<option>-XTemplateHaskell</option>によって盗まれる。
	  </para></listitem>
      </varlistentry>

      <varlistentry>
	<term>
	  <literal>[:<replaceable>varid</replaceable>|</literal>
          <indexterm><primary>quasi-quotation</primary></indexterm>
	</term>
	<listitem><para>
	<option>-XQuasiQuotes</option>によって盗まれる。
	  </para></listitem>
      </varlistentry>

      <varlistentry>
	<term>
	      <replaceable>varid</replaceable>{<literal>&num;</literal>},
	      <replaceable>char</replaceable><literal>&num;</literal>,	
	      <replaceable>string</replaceable><literal>&num;</literal>,
	      <replaceable>integer</replaceable><literal>&num;</literal>,
	      <replaceable>float</replaceable><literal>&num;</literal>,
	      <replaceable>float</replaceable><literal>&num;&num;</literal>,
	      <literal>(&num;</literal>, <literal>&num;)</literal>,	
	</term>
	<listitem><para>
	<option>-XMagicHash</option>によって盗まれる。
	  </para></listitem>
      </varlistentry>
    </variablelist>
</sect2>
</sect1>


<!-- TYPE SYSTEM EXTENSIONS -->
<sect1 id="data-type-extensions">
<title>データ型と型シノニムへの拡張</title>

<sect2 id="nullary-types">
<title>構築子のないデータ型</title>

<para><option>-XEmptyDataDecls</option>フラグ(または同等のLANGUAGEプラグマ)が指定されていると、構築子なしでデータ型を宣言できるようになる。例えば、以下のようにである。</para>

<programlisting>
  data S      -- S :: *
  data T a    -- T :: * -> *
</programlisting>

<para>構文的にいうと、この宣言は「= constrs」の部分を欠いている。このように定義される型は多相的でも良く、さらにどのような種について多相的でも良いが、種が<literal>*</literal>でないなら、明示的な種注釈を使う必要がある。(<xref linkend="kinding"/>を見よ)</para>

<para>このようなデータ型はボトムというただ一つの値しか持たないが、「幽霊型(phantom type)」を定義するときには便利なことがある。</para>
</sect2>

<sect2 id="datatype-contexts">
<title>データ型文脈</title>

<para>Haskellは、データ型に文脈を与えることを許している。例えば以下のように。</para>

<programlisting>
data Eq a => Set a = NilSet | ConsSet a (Set a)
</programlisting>

<para>これは、以下の型を持つ構築子を与える。</para>

<programlisting>
NilSet :: Set a
ConsSet :: Eq a => a -> Set a -> Set a
</programlisting>

<para>これはまずい機能だと広く考えられており、言語から削除される予定である。GHCでは、この機能は<literal>DatatypeContexts</literal>という非推奨の拡張で制御される。</para>
</sect2>

<sect2 id="infix-tycons">
<title>中置型構築子、中置クラス、中置型変数</title>

<para>
GHCでは、型構築子、クラス、型変数を演算子として定義し、式と同じように中置記法で書くことが許される。具体的には、以下のようにである。
<itemizedlist>
<listitem><para>
型構築子やクラスは、コロンで始まる演算子であっても良い。例えば<literal>:*:</literal>。字句的な構文はデータ構築子の場合と同じである。
  </para></listitem>
<listitem><para>
  データ型と型シノニムの宣言は中置形でも行える。引数がさらに必要なら括弧を使う。例。
<screen>
  data a :*: b = Foo a b
  type a :+: b = Either a b
  class a :=: b where ...

  data (a :**: b) x = Baz a b x
  type (a :++: b) y = Either (a,b) y
</screen>
  </para></listitem>
<listitem><para>
  型およびクラス制約は中置形で書いても良い。
  <screen>
	x :: Int :*: Bool
        f :: (a :=: b) => a -> b
  </screen>
  </para></listitem>
<listitem><para>
  型変数は(修飾されていない)演算子であっても良い。例えば<literal>+</literal>などである。字句構文は変数演算子の場合と同じであるが、「(.)」、「(!)」、「(*)」は除外される。束縛位置では、演算子は括弧で括らねばならない。以下のように。
<programlisting>
   type T (+) = Int + Int
   f :: T Either
   f = Left 3

   liftA2 :: Arrow (~>)
	  => (a -> b -> c) -> (e ~> a) -> (e ~> b) -> (e ~> c)
   liftA2 = ...
</programlisting>
  </para></listitem>
<listitem><para>
  バッククオートは、型構築子と型変数のどちらについても、式の場合と同様に働く。例えば、<literal>Int `Either` Bool</literal>とか<literal>Int `a` Bool</literal>のように書ける。同様に、括弧も同じように働く。例えば、<literal>(:*:) Int Bool</literal>のようにである。
  </para></listitem>
<listitem><para>
  型構築子やクラスについて、データ構築子の場合と同じように結合性を宣言することができる。しかし、結合性宣言中でこの二つを区別することはできない。一つの結合性宣言で、データ構築子の結合性と型構築子の結合性が同時に設定される。
<screen>
  infixl 7 T, :*:
</screen>
  上記は、型構築子<literal>T</literal>とデータ構築子<literal>T</literal>の両方の結合性を設定している。<literal>:*:</literal>についても同様である。<literal>Int `a` Bool</literal>.
  </para></listitem>
<listitem><para>
  関数の矢印は<literal>infixr</literal>で結合性0である。(これは変わるかもしれない。どうするべきかわからないので)
  </para></listitem>

</itemizedlist>
</para>
</sect2>

<sect2 id="type-synonyms">
<title>型シノニムの制限緩和</title>

<para>
型シノニムは型の世界でのマクロに似ているが、Haskell 98は型シノニムの個々の宣言にたくさんの規則を課している。拡張<option>-XLiberalTypeSynonyms</option>が有効だと、GHCはいろいろな検査を<emphasis>型シノニムを展開した後にしか</emphasis>行わない。つまり、型シノニムについてGHCはHaskell 98よりもずっと制限を緩くすることができる。
<itemizedlist>
<listitem> <para>次のように、型シノニム中に<literal>forall</literal>(多重定義が関係しても良い)を書くことができる。
<programlisting>
  type Discard a = forall b. Show b => a -> b -> (a, String)

  f :: Discard a
  f x y = (x, show y)

  g :: Discard Int -> (Int,String)    -- ランク2の型
  g f = f 3 True
</programlisting>
</para>
</listitem>

<listitem><para>
<option>-XUnboxedTuples</option>も使っているなら、型シノニム中に非ボックス化型を書くことができる。
<programlisting>
  type Pr = (# Int, Int #)

  h :: Int -> Pr
  h x = (# x, x #)
</programlisting>
</para></listitem>

<listitem><para>
型シノニムをforall型に適用できる。
<programlisting>
  type Foo a = a -> a -> Bool

  f :: Foo (forall b. b->b)
</programlisting>
この型シノニムを展開すると、<literal>f</literal>の型は(GHCでは)合法なものになる。
<programlisting>
  f :: (forall b. b->b) -> (forall b. b->b) -> Bool
</programlisting>
</para></listitem>

<listitem><para>
部分適用された型シノニムに型シノニムを適用することができる。
<programlisting>
  type Generic i o = forall x. i x -> o x
  type Id x = x

  foo :: Generic Id []
</programlisting>
この型シノニムを展開すると、<literal>foo</literal>の型は(GHCでは)合法なものになる。
<programlisting>
  foo :: forall x. x -> [x]
</programlisting>
</para></listitem>

</itemizedlist>
</para>

<para>
GHCは現在、型シノニムを展開する前に種検査を行っている。(ただしこれも変えることはできるだろう)
</para>
<para>
型シノニムを展開した後、GHCは、以下のような、種検査では発見できない誤りを見つけるために、型に対して妥当性検査を行う。
<itemizedlist>
<listitem><para>
型構築子がforall付きの型に適用されている。
</para></listitem>
<listitem><para>
矢印の左側に非ボックス化タプルがある。
</para></listitem>
<listitem><para>
部分適用された型シノニムがある。
</para></listitem>
</itemizedlist>
従って、例えば、以下のものは拒絶される。
<programlisting>
  type Pr = (# Int, Int #)

  h :: Pr -> Int
  h x = ...
</programlisting>
これは、関数の矢印の左側に非ボックス化タプルが現れることをGHCが許していないからである。
</para>
</sect2>


<sect2 id="existential-quantification">
<title>存在量化されたデータ構築子
</title>

<para>
データ型の宣言において存在量化を使うという考えはPerryによって提案され、Hope+に実装された。(Nigel Perry, <emphasis>The Implementation of Practical Functional Programming Languages</emphasis>, PhD Thesis, University of London, 1991)。数年の間Lennart Augustssonの<command>hbc</command>というHaskellコンパイラで利用でき、非常に便利なことが明らかになった。ここに考え方を示す。次のような宣言があったとしよう。
</para>

<para>

<programlisting>
  data Foo = forall a. MkFoo a (a -> Bool)
           | Nil
</programlisting>

</para>

<para>
データ型<literal>Foo</literal>は、次のような型を持つ二つの構築子を持っている。
</para>

<para>

<programlisting>
  MkFoo :: forall a. a -> (a -> Bool) -> Foo
  Nil   :: Foo
</programlisting>

</para>

<para>
<function>MkFoo</function>の型において、型変数<literal>a</literal>がデータ型自体(ただの<literal>Foo</literal>である)のなかに現れないことに注意せよ。例えば、以下の式は正しい。
</para>

<para>

<programlisting>
  [MkFoo 3 even, MkFoo 'c' isUpper] :: [Foo]
</programlisting>

</para>

<para>
ここで、<literal>(MkFoo 3 even)</literal>は、一つの整数と、整数を<literal>Bool</literal>に写す関数<function>even</function>を梱包しており、<literal>(MkFoo 'c' isUpper)</literal>は、一つの文字と、対応する関数を梱包している。これらはどちらも<literal>Foo</literal>型のものであり、一つのリストに入れることができる。
</para>

<para>
<literal>Foo</literal>型の値に対してできることは何だろうか？特に、<function>MkFoo</function>に対してパターン照合を行うと何が起きるだろうか？
</para>

<para>

<programlisting>
  f (MkFoo val fn) = ???
</programlisting>

</para>

<para>
ここで、<literal>val</literal>と<function>fn</function>について判っているのは、<literal>val</literal>の型と<function>fn</function>の引数の型が同じだということだけなので、できることは(実質的に)<function>fn</function>を<literal>val</literal>に適用して真偽値を得ることだけである。以下のように。
</para>

<para>

<programlisting>
  f :: Foo -> Bool
  f (MkFoo val fn) = fn val
</programlisting>

</para>

<para>
結局できたことは、不特定の型の値を、それを操作するいくつかの関数と一緒に梱包して、梱包物の集まりを統一的に扱うことである。この方法で、オブジェクト指向っぽいプログラミングのかなりの部分を行うことができる。
</para>

<sect3 id="existential">
<title>どこが存在的か？
</title>

<para>
これが<emphasis>存在</emphasis>量化とどう関係するのだろうか？これは単に、<function>MkFoo</function>が以下の(ほぼ)同型な型を持っているというだけのことである。
</para>

<para>

<programlisting>
  MkFoo :: (exists a . (a, a -> Bool)) -> Foo
</programlisting>

</para>

<para>
しかし、Haskellプログラマは上に挙げた通常の<emphasis>全称</emphasis>量化された型を考えれば十分である。こうすれば、存在量化のための構文要素を新しく加える必要がない。
</para>

</sect3>

<sect3 id="existential-with-context">
<title>存在型と型クラス</title>

<para>
簡単な拡張として、構築子の前に任意の文脈を置くことを可能にするというのがある。
</para>

<para>

<programlisting>
data Baz = forall a. Eq a => Baz1 a a
         | forall b. Show b => Baz2 b (b -> b)
</programlisting>

</para>

<para>
これらの二つの構築子は、予想される通りの型を持つ。
</para>

<para>

<programlisting>
Baz1 :: forall a. Eq a => a -> a -> Baz
Baz2 :: forall b. Show b => b -> (b -> b) -> Baz
</programlisting>

</para>

<para>
ただし、<function>Baz1</function>に関するパターン照合では、照合された値を等値比較できるし、<function>Baz2</function>に関するパターン照合では、照合された最初の値を文字列に変換することができる(関数を適用することもできる)。従って以下のプログラムは合法である。
</para>

<para>

<programlisting>
  f :: Baz -> String
  f (Baz1 p q) | p == q    = "Yes"
               | otherwise = "No"
  f (Baz2 v fn)            = show (fn v)
</programlisting>

</para>

<para>
操作的にいうと、辞書渡し式の実装では、構築子<function>Baz1</function>と<function>Baz2</function>は<literal>Eq</literal>と<literal>Show</literal>の辞書をそれぞれ記憶しておかなければならず、パターン照合の時にはそれを展開する。
</para>

</sect3>

<sect3 id="existential-records">
<title>レコード構築子</title>

<para>
以下のように、存在量化とレコード構文を併用することができる。

<programlisting>
data Counter a = forall self. NewCounter
    { _this    :: self
    , _inc     :: self -> self
    , _display :: self -> IO ()
    , tag      :: a
    }
</programlisting>
ここで<literal>tag</literal>は公開フィールドであり、正しく型のついた選択関数である<literal>tag :: Counter a -&gt; a</literal>が付属している。型<literal>self</literal>は外部からは隠蔽されている。<literal>_this</literal>、<literal>_inc</literal>、<literal>_display</literal>を関数として適用しようとするとコンパイル時エラーになる。言い替えると、<emphasis>GHCは、フィールドの型が、存在量化された型変数に言及していない場合に限り、そのフィールドへの選択関数を定義する</emphasis>。(この例では選択関数が定義されていないフィールドにアンダースコアを用いているが、これは単なるプログラミングの上での様式であり、GHCは関知しない)
</para>

<para>
これらの隠されたフィールドを利用するには、ヘルパ関数をいくつか作らないといけない。

<programlisting>
inc :: Counter a -> Counter a
inc (NewCounter x i d t) = NewCounter
    { _this = i x, _inc = i, _display = d, tag = t }

display :: Counter a -> IO ()
display NewCounter{ _this = x, _display = d } = d x
</programlisting>

ここで、異なる実装を持つ複数のカウンタを定義することができる。

<programlisting>
counterA :: Counter String
counterA = NewCounter
    { _this = 0, _inc = (1+), _display = print, tag = "A" }

counterB :: Counter String
counterB = NewCounter
    { _this = "", _inc = ('#':), _display = putStrLn, tag = "B" }

main = do
    display (inc counterA)         -- "1" と表示する
    display (inc (inc counterB))   -- "##"と表示する
</programlisting>

レコードの更新構文が存在的データ型(およびGADT)に対してサポートされている。

<programlisting>
setTag :: Counter a -> a -> Counter a
setTag obj t = obj{ tag = t }
</programlisting>
レコード更新についての規則はこうである。<emphasis>更新されるフィールドの型は、データ構築子の型変数のうち、全称量化されたものにしか言及してはならない。GADTについては、フィールドは、構築子の結果の型の中で単純な型変数引数として現れるものにしか言及してはならない</emphasis>。例を挙げる。
<programlisting>
data T a b where { T1 { f1::a, f2::b, f3::(b,c) } :: T a b } -- cは存在的
upd1 t x = t { f1=x }   -- 正:   upd1 :: T a b -> a' -> T a' b
upd2 t x = t { f3=x }   -- 誤    (f3の型はcに言及するが、これは存在量化されている)

data G a b where { G1 { g1::a, g2::c } :: G a [c] }
upd3 g x = g { g1=x }   -- 正:   upd3 :: G a b -> c -> G c b
upd4 g x = g { g2=x }   -- 誤  (f2の型はcに言及するが、これはG1の結果の型において
                        --      単純な型変数の形の引数でない)
</programlisting>

</para>

</sect3>


<sect3>
<title>制約</title>

<para>
存在量化された構築子を使う上で、何種類かの制約がある。
</para>

<para>

<itemizedlist>
<listitem>

<para>
パターン照合では、個々の存在量化された型変数について、新しい、相互に異なる型が導入される。これらの型は他の型と単一化されることはなく、パターン照合のスコープの外に抜け出すこともできない。例えば、以下の断片は正しくない。


<programlisting>
f1 (MkFoo a f) = a
</programlisting>


ここでは、<literal>a</literal>が<function>f1</function>の結果なので、<function>MkFoo</function>で束縛された型が「抜け出して(escape)」いる。なぜこれが間違っているか納得する方法の一つは、<function>f1</function>がどういう型を持つか問うことである。


<programlisting>
  f1 :: Foo -> a             -- おかしい！
</programlisting>


結果型の「<literal>a</literal>」とはなんだ？もちろん次のようなことを言いたい訳ではない。


<programlisting>
  f1 :: forall a. Foo -> a   -- 間違い
</programlisting>


これは、元のプログラムが間違っているというだけのことである。下記はまた別の種類の誤りである。


<programlisting>
  f2 (Baz1 a b) (Baz1 p q) = a==q
</programlisting>


<literal>a==b</literal>とか<literal>p==q</literal>と言うのは構わないが、<literal>a==q</literal>は間違っている。二つの<function>Baz1</function>構築子に由来する異なった型を等値比較しているからである。


</para>
</listitem>
<listitem>

<para> 存在量化された構築子に関するパターン照合を<literal>let</literal>や<literal>where</literal>グループの束縛で行うことはできない。従って次は不正である。


<programlisting>
  f3 x = a==b where { Baz1 a b = x }
</programlisting>

代わりに、<literal>case</literal>式を使うこと。

<programlisting>
  f3 x = case x of Baz1 a b -> a==b
</programlisting>

一般に、存在量化された構築子についてパターン照合できるのは、<literal>case</literal>式においてと、関数定義のパターンにおいてのみである。この制約は実は実装上の理由による。束縛グループを型検査するのは既に悪夢であり、存在型はさらに問題をややこしくする。さらに、モジュールの最上位での存在的パターン束縛には意味がない。存在量化された型が抜け出すのを防ぐ方法がはっきりしないからである。このため、今のところ、述べやすい制約が科せられている。私はこの制約がどれくらい厄介か見定めているところである。

</para>
</listitem>
<listitem>

<para>
<literal>newtype</literal>宣言に存在量化を使うことはできない。よって以下は不正である。


<programlisting>
  newtype T = forall a. Ord a => MkT a
</programlisting>

理由: <literal>T</literal>の値は<literal>Ord t</literal>の辞書と<literal>t</literal>型の値の組で表現されねばならないが、これは<literal>newtype</literal>は具体的な表現形式を持つべきではないという考えに反する。<literal>newtype</literal>の代わりに<literal>data</literal>を使うことで、全く同じ効果・効率を得ることができる。多重定義が関係しないときは、存在量化された<literal>newtype</literal>を許す根拠がある。代わりに<literal>data</literal>を使うと実際に実装コストが掛かるからである。しかし、単一フィールドの存在量化構築子はあまり使い道がない。このため、何か説得力のある理由がない限り、この単純な制約(<literal>newtype</literal>では存在的なもの禁止)が有効である。

</para>
</listitem>
<listitem>

<para>
<literal>deriving</literal>を使って、存在量化されたデータ構築子のあるデータ型のインスタンスを定義することはできない。

理由: 大抵の場合、これは意味をなさない。例。

<programlisting>
data T = forall a. MkT [a] deriving( Eq )
</programlisting>

標準的な方法で<literal>Eq</literal>を導出するには、二つの<function>MkT</function>構築子の内容を等値比較する必要がある。

<programlisting>
instance Eq T where
  (MkT a) == (MkT b) = ???
</programlisting>

しかし<varname>a</varname>と<varname>b</varname>の型は異なるので、比較することができない。導出されたインスタンスが意味をなすような例を考えることも不可能ではないが、このような宣言をまとめて禁止した方が単純だと考えられる。自分でインスタンスを定義しましょう！
</para>
</listitem>

</itemizedlist>

</para>

</sect3>

</sect2>

<!-- ====================== Generalised algebraic data types =======================  -->

<sect2 id="gadt-style">
<title>構築子のシグネチャを明示してデータ型を宣言する</title>

<para><literal>GADTSyntax</literal>拡張が有効な場合、GHCは、構築子の型シグネチャを明示的に与えることで代数的データ型を宣言することを許す。例えば、次のように。
<programlisting>
  data Maybe a where
      Nothing :: Maybe a
      Just    :: a -> Maybe a
</programlisting>
この形式は「GADT様式の宣言」と呼ばれる。これは、一般化代数データ型(<xref linkend="gadt"/>に記述がある)が、この形式でしか宣言できないからである。</para>
<para>GADT様式の構文は存在型(<xref linkend="existential-quantification"/>)の一般化になっていることに注意。例えば、以下の二つの宣言は同等である。
<programlisting>
  data Foo = forall a. MkFoo a (a -> Bool)
  data Foo' where { MKFoo :: a -> (a->Bool) -> Foo' }
</programlisting>
</para>
<para>標準のHaskell-98の構文で宣言できるデータ型は全てGADT様式でも宣言できる。どちらを選ぶかは大部分スタイルの問題だが、GADT様式の宣言が通常と異なる重要な点が一つある。データ構築子に関するクラス制約の扱いが異なるのである。具体的に言うと、構築子に型クラス文脈が与えられたとき、パターン照合によってその文脈が使えるようになる。例を示す。
<programlisting>
  data Set a where
    MkSet :: Eq a => [a] -> Set a

  makeSet :: Eq a => [a] -> Set a
  makeSet xs = MkSet (nub xs)

  insert :: a -> Set a -> Set a
  insert a (MkSet as) | a `elem` as = MkSet as
                      | otherwise   = MkSet (a:as)
</programlisting>
<literal>mkSet</literal>を構築子として使う(例えば<literal>makeSet</literal>の定義)と、期待通り<literal>(Eq a)</literal>の制約が生じる。新機能は、<literal>MkSet</literal>についてのパターン照合(<literal>insert</literal>の定義にあるようなもの)の際、文脈<literal>(Eq a)</literal>が<emphasis>使えるようになる</emphasis>ということである。実装の言葉で言うと、<literal>MkSet</literal>には、渡された<literal>(Eq a)</literal>の辞書を持っておくための隠れたフィールドがある。それで、パターン照合の際には、照合の右辺からその辞書を使うことができる。この例では、こうして得られたEqの辞書を、<literal>elem</literal>の呼び出しによって生成されたEq制約を満足させるのに使うので、<literal>insert</literal>の型自体には<literal>Eq</literal>制約が現れない。</para>
<para>
例えば、応用の一つとして、辞書をオブジェクト化するというのがある。
<programlisting>
   data NumInst a where
     MkNumInst :: Num a => NumInst a

   intInst :: NumInst Int
   intInst = MkNumInst

   plus :: NumInst a -> a -> a -> a
   plus MkNumInst p q = p + q
</programlisting>
ここで、<literal>NumInst a</literal>型の値は、<literal>(Num a)</literal>の辞書を明示的にしたものと同等である。
</para>
<para>これは全て、<xref linkend="existential-with-context"/>の構文を使って宣言された構築子についても当てはまる。例えば、上のデータ型<literal>NumInst</literal>は次のように定義しても同等である。
<programlisting>
   data NumInst a
      = Num a => MkNumInst (NumInst a)
</programlisting>
存在型を定義する場合と違って<literal>forall</literal>がないことに注意。これは、<literal>Num</literal>が、データ型の全称量化された型変数<literal>a</literal>を制約するからである。ひとつの構築子に、全称と存在の両方の型変数があってもよい。例えば、以下の二つの宣言は同等である。
<programlisting>
   data T1 a
	= forall b. (Num a, Eq b) => MkT1 a b
   data T2 a where
	MkT2 :: (Num a, Eq b) => a -> b -> T2 a
</programlisting>
</para>
<para>これらの振る舞いは全て、Haskell 98の、データ型宣言における文脈の奇妙な扱い(Haskell 98レポートの4.2.1節)と対照を為す。Haskell 98では、次の定義によって、上の<literal>MkSet</literal>と同じ型の<literal>MkSet'</literal>が得られる。
<programlisting>
  data Eq a => Set' a = MkSet' [a]
</programlisting>
しかし、<literal>MkSet'</literal>についてのパターン照合では、<literal>(Eq a)</literal>の制約が<emphasis>使えるようになる</emphasis>のでなく、<literal>(Eq a)</literal>の制約を<emphasis>要求する</emphasis>のだ。変な振る舞いだが、GHCはこれを忠実に実装している。しかし、GADT様式の宣言なら、GHCの振る舞いはずっと有用で、同時にずっと直感的である。</para>
<para>
この節の残りの部分では、GADT様式のデータ型宣言について、さらなる詳細を与える。

<itemizedlist>
<listitem><para>
各データ構築子の結果の型は、定義しようとしている型構築子で始まっていなければならない。構築子の結果の型が全て<literal>T a1 ... an</literal>という形(ただし<literal>a1 .. an</literal>は相異なる型変数)なら、それは<emphasis>通常の</emphasis>データ型であり、そうでなければ<emphasis>一般化された</emphasis>データ型(<xref linkend="gadt"/>)である。
</para></listitem>

<listitem><para>
通常の型シグネチャの場合と同様、複数の構築子に一つのシグネチャを与えることができる。この例では、<literal>T1</literal>と<literal>T2</literal>に一つのシグネチャを与えている。
<programlisting>
  data T a where
    T1,T2 :: a -> T a
    T3 :: T a
</programlisting>
</para></listitem>

<listitem><para>
それぞれの構築子の型シグネチャは独立していて、通常通り暗黙に全称量化される。特に、「<literal>data T a where</literal>」のような頭部にある型変数にはスコープがなく、別々の構築子には異なる全称量化の型変数があっても良い。
<programlisting>
  data T a where        -- この「a」にはスコープがない
    T1,T2 :: b -> T b   -- 意味は forall b. b -> T b
    T3 :: T a           -- 意味は forall a. T a
</programlisting>
</para></listitem>

<listitem><para>
構築子のシグネチャは型クラス制約に言及してもよいし、それが構築子間で異なっていてもよい。例えば、これは問題ない。
<programlisting>
  data T a where
    T1 :: Eq b => b -> b -> T b
    T2 :: (Show c, Ix c) => c -> [c] -> T c
</programlisting>
パターン照合の際には、照合の本体における制約を果たす(discharge)ために、これらの制約が利用できるようになる。例を挙げる。
<programlisting>
  f :: T a -> String
  f (T1 x y) | x==y      = "yes"
             | otherwise = "no"
  f (T2 a b)             = show a
</programlisting>
<literal>f</literal>は多重定義されていないことに注意。<literal>==</literal>を使用したことから発生した<literal>Eq</literal>制約は、<literal>T1</literal>上のパターン照合によって果たされている。<literal>show</literal>を使用したことから発生した<literal>Show</literal>制約についても同様である。
</para></listitem>

<listitem><para>
Haskell 98様式のデータ型宣言と異なり、「<literal>data Set a where</literal>」というヘッダに出てくる型変数にはスコープがない。実際、代わりに種シグネチャを書くこともできる。
<programlisting>
  data Set :: * -> * where ...
</programlisting>
あるいは、この二つを混ぜるのでも良い。
<programlisting>
  data Bar a :: (* -> *) -> * where ...
</programlisting>
型変数(与えられるなら)は明示的に種付けされていても良いので、<literal>Foo</literal>のヘッダを以下のように書くこともできる。
<programlisting>
  data Bar a (b :: * -> *) where ...
</programlisting>
</para></listitem>


<listitem><para>
正確性注釈は、構築子の型の中の当然の場所に付けることができる。
<programlisting>
  data Term a where
      Lit    :: !Int -> Term Int
      If     :: Term Bool -> !(Term a) -> !(Term a) -> Term a
      Pair   :: Term a -> Term b -> Term (a,b)
</programlisting>
</para></listitem>

<listitem><para>
GADT様式のデータ型宣言で<literal>deriving</literal>節を使うことができる。例えば、以下の二つの宣言は同等である。
<programlisting>
  data Maybe1 a where {
      Nothing1 :: Maybe1 a ;
      Just1    :: a -> Maybe1 a
    } deriving( Eq, Ord )

  data Maybe2 a = Nothing2 | Just2 a
       deriving( Eq, Ord )
</programlisting>
</para></listitem>

<listitem><para>
型シグネチャには、結果の型に現れない型変数があってもよい。
<programlisting>
  data Foo where
     MkFoo :: a -> (a->Bool) -> Foo
     Nil   :: Foo
</programlisting>
ここで、型変数<literal>a</literal>はどちらの構築子の結果の型にも現れない。構築子の型において全称量化されているが、こういう型変数はよく「存在的」であると言われる。実際、上の宣言は、<xref linkend="existential-quantification"/>の<literal>data Foo</literal>と全く同じ型を宣言している。
</para><para>
もちろん、その型にクラス文脈が含まれていてもよい。
<programlisting>
  data Showable where
    MkShowable :: Show a => a -> Showable
</programlisting>
</para></listitem>

<listitem><para>
GADT様式のデータ型宣言においてレコード構文を使うこともできる。

<programlisting>
  data Person where
      Adult :: { name :: String, children :: [Person] } -> Person
      Child :: Show a => { name :: !String, funny :: a } -> Person
</programlisting>
通常と同じように、<literal>f</literal>というフィールドを持つ全ての構築子に関して、フィールド<literal>f</literal>の型が(α変換を法として)等しくなければならない。上記の<literal>Child</literal>構築子を見ると分かるとおり、シグネチャには、レコードでない場合と同様に、文脈、存在量化された変数、正格性注釈があってもよい。(注意: 二つのコロンの後にある「型」は、レコード構文と正格性注釈を含むので正確には「型」でない。この形の「型」は構築子のシグネチャにのみ現れることができる。)
</para></listitem>

<listitem><para>
レコード更新は、以下の性質を持つフィールドについてのみ、GADT様式の宣言でも許される。「そのフィールドの型が存在的な型変数に言及しないこと」
</para></listitem>

<listitem><para>
Haskell 98風のレコード構文で存在型を宣言する場合(<xref linkend="existential-records"/>)と同様に、レコード選択関数は、選択関数にうまく型が付くフィールドについてのみ生成される。以下は、存在的レコードの節の例をGADT様式にしたものである。
<programlisting>
data Counter a where
    NewCounter { _this    :: self
               , _inc     :: self -> self
               , _display :: self -> IO ()
               , tag      :: a
               }
        :: Counter a
</programlisting>
前と同じように、ここで生成される選択関数は唯一つ、<literal>tag</literal>についてものである。ただし、パターン照合とレコード構築では、相変わらず全てのフィールド名を使うことができる。
</para></listitem>

<listitem><para>
GADT様式のデータ型宣言では、データ構築子が中置であるかを指定する自明な方法が存在しない。これはその型に<literal>Show</literal>を自動導出する際に問題になる。(中置で宣言されたデータ構築子は<literal>show</literal>によって中置で表示される。)そこでGHCは以下の設計を実装している。GADT様式で宣言されたデータ構築子が<literal>Show</literal>によって中置で表示されるのは、(a)演算子記号であり、(b)引数を二つ取り、(c)プログラマによって与えられた結合性宣言を持つ、場合、かつそれに限る。例を挙げる。
<programlisting>
   infix 6 (:--:) 
   data T a where
     (:--:) :: Int -> Bool -> T Int
</programlisting>
</para></listitem>
</itemizedlist></para>

 </sect2>

<sect2 id="gadt">
<title>一般化代数データ型(GADT)</title>

<para>一般化代数データ型は、通常の代数的データ型を拡張して、構築子がより多様な型を持てるようにしたものである。以下は例である。
<programlisting>
  data Term a where
      Lit    :: Int -> Term Int
      Succ   :: Term Int -> Term Int
      IsZero :: Term Int -> Term Bool	
      If     :: Term Bool -> Term a -> Term a -> Term a
      Pair   :: Term a -> Term b -> Term (a,b)
</programlisting>
通常のデータ型の場合と違って、構築子の結果の型が<literal>Term a</literal>だとは限らないことに注意。この一般化のお陰で、<literal>Term</literal>について、正しく型の付いた<literal>eval</literal>関数を書くことができる。
<programlisting>
  eval :: Term a -> a
  eval (Lit i) 	    = i
  eval (Succ t)     = 1 + eval t
  eval (IsZero t)   = eval t == 0
  eval (If b e1 e2) = if eval b then eval e1 else eval e2
  eval (Pair e1 e2) = (eval e1, eval e2)
</programlisting>
GADTの鍵となる点は、<emphasis>パターン照合によって型の精密化が起こる</emphasis>ことである。以下の例を考える。
<programlisting>
  eval :: Term a -> a
  eval (Lit i) =  ...
</programlisting>
等式の右辺では、<literal>a</literal>が精密化されて<literal>Int</literal>になる。これこそが売りである。型付け規則の正確な規定は利用の手引きが目指すところではないが、設計は、<ulink url="http://research.microsoft.com/%7Esimonpj/papers/gadt/">Simple unification-based type inference for GADTs</ulink>, (ICFP 2006)で述べられているものによく倣っている。
一般的な原則はこうである。<emphasis>精密化は、ユーザ供給の型注釈を基にしてのみ起こる</emphasis>。従って、もし<literal>eval</literal>に型シグネチャが与えられなければ、型精密化は起こらず、大量の不明瞭なエラーが発生することだろう。一方、精密化はかなり一般的である。例えば、以下のものがあったとしよう。
<programlisting>
  eval :: Term a -> a -> a
  eval (Lit i) j =  i+j
</programlisting>
このパターン照合で、型<literal>a</literal>が精密化されて(構築子<literal>Lit</literal>の型にしたがって)<literal>Int</literal>になる。この精密化は<literal>j</literal>の型とこの<literal>case</literal>式の結果の型にも及ぶ。だから<literal>i+j</literal>という加算は合法である。
</para>
<para>
これらの例と、他の多くの例が、Hongwei XiとTim Sheardによる論文群で与えられている。<ulink url="http://www.haskell.org/haskellwiki/GADT">wikiには</ulink>もっと長い入門文書があるし、Ralf Hinzeの<ulink url="http://www.informatik.uni-bonn.de/~ralf/publications/With.pdf">Fun with phantom types</ulink>にもいくつか例がある。
これらの論文ではGHCに実装されているのと異なる記法を使っていることがあるので注意。
</para>
<para>
この節の残りの部分では、GADTをサポートするGHCの拡張について概観する。この拡張は<option>-XGADTs</option>で有効になる。<option>-XGADTs</option>フラグを使うと、<option>-XRelaxedPolyRec</option>も同時に設定される。
<itemizedlist>
<listitem><para>
GADTは、GADT様式の構文(<xref linkend="gadt-style"/>)でなければ宣言できない。Haskell 98の古いデータ宣言の構文では、常に通常のデータ型が宣言される。各構築子の結果の型は定義しようとしている型構築子で始まっていなければならないが、GADTについては、その型への引数は任意のmonotypeで良い。例えば、上の<literal>Term</literal>型において、各構築子の型は<literal>Term ty</literal>で終わっていなければならないが、<literal>ty</literal>が型変数である必要はない。(例えば構築子<literal>Lit</literal>)。
</para></listitem>

<listitem><para>
GADT様式の構文を使って通常の代数的データ型を宣言することは可能である。GADTをGADTたらしめるのは構文ではなく、結果の型が単なる<literal>T a b</literal>でないような構築子の存在である。
</para></listitem>

<listitem><para>
GADTについて<literal>deriving</literal>節を使うことはできない。通常のデータ型だけである。
</para></listitem>

<listitem><para>
<xref linkend="gadt-style"/>で述べたように、レコード記法にも対応している。例えば以下のように。
<programlisting>
  data Term a where
      Lit    { val  :: Int }      :: Term Int
      Succ   { num  :: Term Int } :: Term Int
      Pred   { num  :: Term Int } :: Term Int
      IsZero { arg  :: Term Int } :: Term Bool	
      Pair   { arg1 :: Term a
             , arg2 :: Term b
             }                    :: Term (a,b)
      If     { cnd  :: Term Bool
             , tru  :: Term a
             , fls  :: Term a
             }                    :: Term a
</programlisting>
ただし、GADTについては以下の制約が追加される。フィールド<literal>f</literal>を持つ全ての構築子は、(α変換を法として)同じ結果型を持たねばならない。だから、上の例なら、<literal>num</literal>フィールドと<literal>arg</literal>フィールドをまとめて一つの名前にすることはできない。フィールド型はどちらも<literal>Term Int</literal>だが、実は選択関数は異なる型を持っている。

<programlisting>
  num :: Term Int -> Term Int
  arg :: Term Bool -> Term Int
</programlisting>
</para></listitem>

<listitem><para>
GADTから得られたデータ構築子に対してパターン照合を行なう(例えば<literal>case</literal>式で)場合、以下の規則が適用される。
<itemizedlist>
<listitem><para>検査対象(訳注: scrutinee; case式ならcaseとinの間に書かれる式のこと)の型は固い型でなければならない。</para></listitem>
<listitem><para><literal>case</literal>式全体の型は固い型でなければならない。</para></listitem>
<listitem><para><literal>case</literal>の各分岐で言及される自由変数の型はすべて固い型でなければならない。</para></listitem>
</itemizedlist>
型が「固い(rigid)」というのは、それが束縛された地点において、コンパイラにとって完全に既知であることをいう。ある変数の型が固い型であることを確実にしたいなら、もっとも簡単な方法はそれに型シグネチャを与えることである。より精密な詳細については<ulink url="http://research.microsoft.com/%7Esimonpj/papers/gadt">Simple unification-based type inference for GADTs</ulink>を見よ。GHCに実装されている基準はAppendixに載っている。

</para></listitem>

</itemizedlist>
</para>

</sect2>
</sect1>

<!-- ====================== End of Generalised algebraic data types =======================  -->

<sect1 id="deriving">
<title>「deriving」機構への拡張</title>

<sect2 id="deriving-inferred">
<title>deriving節について推論される文脈</title>

<para>
Haskell Reportは、正確にどんな場合に<literal>deriving</literal>節が有効かについてはっきりしない。例を示す。
<programlisting>
  data T0 f a = MkT0 a         deriving( Eq )
  data T1 f a = MkT1 (f a)     deriving( Eq )
  data T2 f a = MkT2 (f (f a)) deriving( Eq )
</programlisting>
自然生成された<literal>Eq</literal>のコードは以下のようなインスタンス宣言になるだろう。
<programlisting>
  instance Eq a         => Eq (T0 f a) where ...
  instance Eq (f a)     => Eq (T1 f a) where ...
  instance Eq (f (f a)) => Eq (T2 f a) where ...
</programlisting>
最初のものは明らかに問題ない。二番目も、それほど明らかではないが、問題ない。三番目はHaskell 98でなく、インスタンスの停止性を損なう危険がある。
</para>
<para>
GHCは保守的な立場を採っている。最初の二つは受け付けるが、三番目は受け付けない。規則はこうである。推論された文脈中の各制約は、型変数のみから成っていなければならず、型変数に重複があってもならない。
</para>
<para>
この規則はフラグに関係なく適用される。もっと風変りな文脈が必要なら、<link linkend="stand-alone-deriving">独立derivingの機構</link>を使って自分で書くことができる。
</para>
</sect2>

<sect2 id="stand-alone-deriving">
<title>独立deriving宣言</title>

<para>
GHCは単独の<literal>deriving</literal>宣言を受け付けるようになった。これは<literal>-XStandaloneDeriving</literal>で有効になる。
<programlisting>
  data Foo a = Bar a | Baz String

  deriving instance Eq a => Eq (Foo a)
</programlisting>
構文は通常のインスタンス宣言と同じであるが、(a)<literal>deriving</literal>キーワードを使うことと、(b)<literal>where</literal>部がないことが異なる。以下の点に注意せよ。
<itemizedlist>
<listitem><para>
通常のインスタンス宣言でするのと全く同じように、文脈(この例では文脈は<literal>(Eq a)</literal>)を明示的に指定しなければならない。(対照的に、データ型宣言に付属したderiving節においては文脈は推論される)。
</para></listitem>

<listitem><para><literal>deriving instance</literal>の宣言は、形式と停止性に関して、通常のインスタンス宣言が従うのと同じ規則に従い、同じフラグで制御される。<xref linkend="instance-decls"/>を見よ。
</para></listitem>

<listitem><para>
<literal>data</literal>宣言に付属する<literal>deriving</literal>宣言と異なり、インスタンスはデータ型よりも限定的になり得る(<literal>-XFlexibleInstances</literal>を使うことを前提にすれば。<xref linkend="instance-rules"/>)。例として以下を考えよ。
<programlisting>
  data Foo a = Bar a | Baz String

  deriving instance Eq a => Eq (Foo [a])
  deriving instance Eq a => Eq (Foo (Maybe a))
</programlisting>
これによって<literal>(Foo [a])</literal>と<literal>(Foo (Maybe a))</literal>についての自動導出インスタンスが生成されるが、それ以外の<literal>(Foo (Int,Bool))</literal>といった型は<literal>Eq</literal>のインスタンスにならない。
</para></listitem>

<listitem><para><literal>data</literal>宣言に付属した<literal>deriving</literal>宣言と異なり、GHCはデータ型の形式を制限しない。その代わり、単純に、GHCは指定されたクラスのための定型コードを生成し、それを型検査する。もし型エラーがあれば、それはあなたの問題である。(型エラーがあるなら、違反のあるコードをGHCが表示するだろう)。この方式の利点は、定型コードさえ型検査に通れば、GADTその他の妙なデータ型に対してインスタンスを自動導出できることである。例を挙げる。
<programlisting>
  data T a where
     T1 :: T Int
     T2 :: T Bool

  deriving instance Show (T a)
</programlisting>
この例では、<literal>T</literal>のデータ型宣言に付属して<literal>... deriving( Show )</literal>とは言えない。<literal>T</literal>はGADTだからである。しかし、独立derivingを使えば、このインスタンスを導出することが<emphasis>できる</emphasis>。
</para></listitem>

<listitem>
<para>この独立deriving構文は、通常の<literal>deriving</literal>がnewtypeに対して一般化された(<xref linkend="newtype-deriving"/>)のと全く同じように一般化される。例えば次のように。
<programlisting>
  newtype Foo a = MkFoo (State Int a)

  deriving instance MonadState Int Foo
</programlisting>
GHCは常に、インスタンスの<literal>最後</literal>のパラメタ(この例では<literal>Foo</literal>)を導出対象の型として扱う。
</para></listitem>
</itemizedlist></para>

</sect2>

<sect2 id="deriving-typeable">
<title>より広範なクラスについてのderiving節(<literal>Typeable</literal>、<literal>Data</literal>など)</title>

<para>
Haskell 98では、プログラマがデータ型宣言に「<literal>deriving( Eq, Ord )</literal>」と付け加えれば、これらのクラスの標準的なインスタンス宣言が生成される。Haskell 98では、<literal>deriving</literal>節に現れることのできるクラスは標準の<literal>Eq</literal>、<literal>Ord</literal>、<literal>Enum</literal>、<literal>Ix</literal>、<literal>Bounded</literal>、<literal>Read</literal>、<literal>Show</literal>だけである。
</para>
<para>
GHCはこれを拡張し、新たにいくつかのクラスが自動的に導出できるようにする。
<itemizedlist>
<listitem><para><option>-XDeriveDataTypeable</option>を使うと、<literal>Typeable</literal>と<literal>Data</literal>の両クラスのインスタンスを自動導出できる。これらのクラスは、ライブラリ中、それぞれ<literal>Data.Typeable</literal>と<literal>Data.Generics</literal>で定義されている。
</para>
<para><literal>Typeable</literal>のインスタンスは、データ型の型パラメタの数が七個以下で、その全てが種<literal>*</literal>を持っているときのみ自動導出できる。これは、<literal>Typeable</literal>クラスが<ulink url="http://research.microsoft.com/%7Esimonpj/papers/hmap/gmap2.ps">Scrap More Boilerplate: Reflection, Zips, and Generalised Casts</ulink>で述べられている形を使って導出されているからである。(この論文の7.4節では、使われる複数の<literal>Typeable</literal>について述べられているが、ライブラリが提供するのは<literal>Typeable1</literal>から<literal>Typeable7</literal>までだけである)。この条件を満たさない場合、プログラマは、そのデータ構築子に合った種を持つ<literal>TypeableX</literal>を書き、そのデータ型についてのインスタンスを手で書くことができる。</para>
</listitem>

<listitem><para><option>-XDeriveGeneric</option>を使うと、<literal>Generic</literal>および<literal>Generic1</literal>クラスのインスタンスを自動導出できる。これらのクラスは<literal>GHC.Generics</literal>で定義されている。<xref linkend="generic-programming"/>にあるように、これらを使って総称的な関数を定義することができる。</para></listitem>

<listitem><para><option>-XDeriveFunctor</option>を使うと、<literal>Functor</literal>クラスのインスタンスを自動導出できる。このクラスは<literal>GHC.Base</literal>で定義されている。</para></listitem>

<listitem><para><option>-XDeriveFoldable</option>を使うと、<literal>Foldable</literal>クラスのインスタンスを自動導出できる。このクラスは<literal>Data.Foldable</literal>で定義されている。</para></listitem>

<listitem><para><option>-XDeriveTraversable</option>を使うと、<literal>Traversable</literal>クラスのインスタンスを自動導出できる。このクラスは<literal>Data.Traversable</literal>で定義されている。</para></listitem>

</itemizedlist>
どの場合でも、クラスを<literal>deriving</literal>節で言及する場合には、それがスコープになければならない。
</para>
</sect2>

<sect2 id="newtype-deriving">
<title>newtypeについての自動導出インスタンスの一般化</title>

<para>
<literal>newtype</literal>を使って抽象型を定義するとき、元の型からインスタンスをいくつか継承させたいと思うことがあるかもしれない。Haskell 98では、<literal>Eq</literal>、<literal>Ord</literal>、<literal>Enum</literal>、<literal>Bounded</literal>に関しては自動導出を使うことでインスタンスを継承させられるが、それ以外の型については明示的なインスタンス宣言を書かなければならない。例えば、次のように定義したとする。

<programlisting>
  newtype Dollars = Dollars Int
</programlisting>

そして、<literal>Dollars</literal>に対して数値演算を使いたいなら、次のようにして明示的に<literal>Num</literal>のインスタンスを書かなければならない。

<programlisting>
  instance Num Dollars where
    Dollars a + Dollars b = Dollars (a+b)
    ...
</programlisting>
このインスタンスは、<literal>newtype</literal>の構築子を適用したり排除したりしているだけである。特にくやしいのは、この構築子は実行時には存在しないので、このインスタンス宣言が定義する辞書は<literal>Int</literal>の辞書と<emphasis>全体を通して同じ</emphasis>で、違いはこちらの方がより遅いことだけだ、という点である。
</para>


<sect3> <title>deriving節の一般化</title>
<para>
このようなことをしなくても、GHCでは、<option>-XGeneralizedNewtypeDeriving</option>を使ってこの種のインスタンスを自動導出できるようになった。従って、次のように書くことができる。
<programlisting>
  newtype Dollars = Dollars Int deriving (Eq,Show,Num)
</programlisting>

そして、実装では、<literal>Dollars</literal>について<literal>Int</literal>のものと<emphasis>同じ</emphasis><literal>Num</literal>用辞書が使われる。概念上は、コンパイラは次のような形のインスタンス宣言を導出している。

<programlisting>
  instance Num Int => Num Dollars
</programlisting>

このインスタンスは、型にしたがって<literal>newtype</literal>構築子を付けたり外したりすることだけを行う。
</para>
<para>

構築子クラスのインスタンスも同様に自動導出することができる。例えば、次のように、状態と失敗を扱うモナド変換子を実装したとしよう。

<programlisting>
  instance Monad m => Monad (State s m)
  instance Monad m => Monad (Failure m)
</programlisting>
Haskell 98では、次のようにしてパーサモナドを定義することができる。
<programlisting>
  type Parser tok m a = State [tok] (Failure m) a
</programlisting>

これは、上記のインスタンス宣言によって自動的にモナドになっている。拡張を使うと、<literal>Monad</literal>クラスのインスタンスを書くことなくパーサの型を抽象型にすることができる。次のようになる。

<programlisting>
  newtype Parser tok m a = Parser (State [tok] (Failure m) a)
                         deriving Monad
</programlisting>
この場合、導出されたインスタンス宣言は次の形になる。
<programlisting>
  instance Monad (State [tok] (Failure m)) => Monad (Parser tok m)
</programlisting>

<literal>Monad</literal>は構築子クラスなので、このインスタンスはこのnewtypeの<emphasis>部分適用</emphasis>であり、左辺全体ではない。インスタンス宣言の文脈を生成するためにこの型宣言が「η変換」されたと考えることができる。
</para>
<para>

多引数型クラスについても、そのnewtypeがクラスの最後の引数であることを条件に、インスタンスを自動導出できる。この場合、<literal>deriving</literal>節に現れるのはクラスの「部分適用」形である。例として、次のようなクラスがあったとする。

<programlisting>
  class StateMonad s m | m -> s where ...
  instance Monad m => StateMonad s (State s m) where ...
</programlisting>
このとき、次のようにして、<literal>Parser</literal>についての<literal>StateMonad</literal>のインスタンスを自動導出できる。
<programlisting>
  newtype Parser tok m a = Parser (State [tok] (Failure m) a)
                         deriving (Monad, StateMonad [tok])
</programlisting>

導出インスタンスは、部分適用されたクラスを最後にnewtypeに適用し、完全に適用された形にすることで得られる。次のようにである。

<programlisting>
  instance StateMonad [tok] (State [tok] (Failure m)) =>
           StateMonad [tok] (Parser tok m)
</programlisting>
</para>
<para>

この拡張の結果、newtype宣言での導出インスタンスは、<literal>Show</literal>と<literal>Read</literal>(これらは元の型とは異なる振る舞いをする)を除いた全てのクラスについて一様に扱われ(、元となった型の辞書を再利用することで実装され)る。
</para>
</sect3>

<sect3> <title>より精密な規定</title>
<para>
自動導出によってインスタンス宣言が構築されるときの規則は以下である。次の宣言(型シノニムを展開した後のもの)を考える。

<programlisting>
  newtype T v1...vn = T' (t vk+1...vn) deriving (c1...cm)
</programlisting>

ここで、
 <itemizedlist>
<listitem><para>
<literal>ci</literal>はクラスの部分適用であり、<literal>C t1'...tj'</literal>という形をとる。ただし<literal>C</literal>の引数の数は<literal>j+1</literal>である。すなわち、<literal>C</literal>はただ一つの引数を欠いている。
</para></listitem>
<listitem><para>
  <literal>k</literal>は、<literal>ci (T v1...vk)</literal>の種が正しくなるように選ばれる。
</para></listitem>
<listitem><para>
  型<literal>t</literal>は任意の型である。
</para></listitem>
<listitem><para>
  型変数<literal>vk+1...vn</literal>は、<literal>t</literal>にも、<literal>ci</literal>にも出現しない。
</para></listitem>
<listitem><para>
  <literal>ci</literal>はどれも、<literal>Read</literal>、<literal>Show</literal>、<literal>Typeable</literal>、<literal>Data</literal>のいずれでもない。これらのクラスは型やその構築子を「素通りする」べきものではない。これらのクラスをnewtypeに自動導出することもできるが、それは通常の方法で行われ、この新しい機構は利用されない。
</para></listitem>
</itemizedlist>
このとき、それぞれの<literal>ci</literal>に対して、自動導出されるインスタンス宣言は以下のようになる。
<programlisting>
  instance ci t => ci (T v1...vk)
</programlisting>
<emphasis>うまくいかない</emphasis>例として、以下のものを考えてみよう。
<programlisting>
  newtype NonMonad m s = NonMonad (State s m s) deriving Monad
</programlisting>
ここで、次のインスタンスを自動導出することはできない。
<programlisting>
  instance Monad (State s m) => Monad (NonMonad m)
</programlisting>

なぜなら、型変数<literal>s</literal>が<literal>State s m</literal>に現れており、「η変換」によって消し去ることができないからである。この<literal>deriving</literal>節が拒絶されるのは良いことである。<literal>NonMonad m</literal>は実際、同じ理由で、モナドではないからである。正しい型を持つ<literal>>>=</literal>を定義しようとしてみよ。できないはずである。
</para>
<para>

また、クラス引数の<emphasis>順序</emphasis>が重要になることに注意。これは、最後の引数についてしかインスタンスの自動導出ができないからである。もし上記の<literal>StateMonad</literal>が次のように定義されていたなら、上のように<literal>Parser</literal>型についてインスタンスを自動導出することは不可能だった。

<programlisting>
  class StateMonad m s | m -> s where ...
</programlisting>

我々は、多引数型クラスには通常ひとつの「主要な」引数があり、それについてのインスタンス自動導出が最も重視される、という仮説を立てている。
</para>
<para>最後に、これら全ては<literal>Read</literal>、<literal>Show</literal>、<literal>Typeable</literal>、<literal>Data</literal>の各クラスには適用されない。これらには、組込みの導出規則(Haskellレポートの4.3.3節)が適用される。(<literal>Eq</literal>、<literal>Ord</literal>、<literal>Ix</literal>、<literal>Bounded</literal>の各標準クラスについては、どちらの方法を使っても関係ない)
</para>
</sect3>

</sect2>

</sect1>


<!-- TYPE SYSTEM EXTENSIONS -->
<sect1 id="type-class-extensions">
<title>クラスおよびインスタンス宣言</title>

<sect2 id="multi-param-type-classes">
<title>クラス宣言</title>

<para>
この節及び次の節では、型クラスに関するGHCの拡張を説明する。論文<ulink url="http://research.microsoft.com/~simonpj/Papers/type-class-design-space/" >Type classes: exploring the design space</ulink> (Simon Peyton Jones, Mark Jones, Erik Meijer)には、多くの背景事項が書かれている。
</para>

<sect3>
<title>多引数の型クラス</title>
<para>
<option>-XMultiParamTypeClasses</option>フラグが有効なら、以下のような、多引数の型クラスが許される。


<programlisting>
  class Collection c a where
    union :: c a -> c a -> c a
    ...etc.
</programlisting>

</para>
</sect3>

<sect3 id="superclass-rules">
<title>クラス宣言のスーパークラス</title>

<para>
Haskell 98では、クラス宣言の文脈(スーパークラスを導入するのはこれである)は単純でなければならない。すなわち、すべての述語が、型変数にクラスを適用した形でなければならない。<option>-XFlexibleContexts</option>フラグ(<xref linkend="flexible-contexts"/>)はこの制限を外し、クラス宣言の文脈には、クラス階層に循環があってはならないという制約のみがかかるようにする。従って、以下のようなクラス宣言が認められる。

<programlisting>
  class Functor (m k) => FiniteMap m k where
    ...

  class (Monad m, Monad (t m)) => Transform t m where
    lift :: m a -> (t m) a
</programlisting>


</para>
<para>
Haskell 98と同様に、クラス階層に循環があってはならない。しかし、「循環があってはならない」というのは、スーパークラスという関係についてのみである。例えば、以下は問題ない。


<programlisting>
  class C a where {
    op :: D b => a -> b -> b
  }

  class C a => D a where { ... }
</programlisting>


この場合、<literal>C</literal>は<literal>D</literal>のスーパークラスであるが、<literal>C</literal>のクラス演算である<literal>op</literal>が<literal>D</literal>に言及するのは問題ない。(<literal>D</literal>を<literal>C</literal>のスーパークラスにするのは駄目である)
</para>
<para><link linkend="constraint-kind">制約の種</link>を追加する拡張を使うと、さらに風変りなスーパークラス定義を書くことができる。この場合、スーパークラス循環の検査はさらに緩和される。たとえばこれは問題ない。

<programlisting>
  class A cls c where
    meth :: cls c => c -> c

  class A B c => B c where
</programlisting>

クラス<literal>C</literal>のスーパークラス文脈が許されるのは、型シノニムをその右辺へと展開し、使われている(<literal>C</literal>以外の)クラスをそれらのスーパークラスへと展開したときに、構文的にその文脈内に<literal>C</literal>が現れない場合である。
</para>
</sect3>




<sect3 id="class-method-types">
<title>クラスメソッドの型</title>

<para>
Haskell 98では、クラスメソッドの型中に、クラス型変数についての制約が現れることを禁止している。次のような場合である。
<programlisting>
  class Seq s a where
    fromList :: [a] -> s a
    elem     :: Eq a => a -> s a -> Bool
</programlisting>
Haskell 98では<literal>elem</literal>の型は不正である。制約<literal>Eq a</literal>がクラス型変数(この場合<literal>a</literal>)のみを拘束しているからである。GHCはこの制限を撤廃する(<option>-XConstrainedClassMethods</option>フラグ)。
</para>


</sect3>


<sect3 id="class-default-signatures">
<title>デフォルトメソッドシグネチャ</title>

<para>
Haskell 98は、クラスを宣言する際にデフォルト実装を定義することを許している。以下のように。
<programlisting>
  class Enum a where
    enum :: [a]
    enum = []
</programlisting>
<literal>enum</literal>メソッドの型は<literal>[a]</literal>であり、これがデフォルトメソッドの型でもある。<option>-XDefaultSignatures</option>というフラグを使うと、この制限を撤廃し、デフォルトメソッドに別の型を与えることができる。例えば、<literal>genum</literal>というメソッドを持つ<literal>GEnum</literal>というクラスに、<literal>GHC.Generics</literal>を使って列挙の総称的な実装を書いたなら、その総称的な実装を使うデフォルトメソッドを次のように指定することができる。
<programlisting>
  class Enum a where
    enum :: [a]
    default enum :: (Generic a, GEnum (Rep a)) => [a]
    enum = map to genum
</programlisting>
<literal>default</literal>キーワードを再利用することで、シグネチャがデフォルトメソッドにのみ適用されることを示している。<literal>Enum</literal>クラスのインスタンスを定義する際には、<literal>enum</literal>の元々の型である<literal>[a]</literal>が変わらず適用される。しかし、空のインスタンスを与えた場合には、デフォルト実装である<literal>map to0 genum</literal>が補充され、<literal>(Generic a, GEnum (Rep a)) => [a]</literal>という型で型検査される。</para>

<para>
我々は、GHCにおける総称プログラミングを単純にするためにデフォルトシグネチャを使っている(<xref linkend="generic-programming"/>)。
</para>


</sect3>
</sect2>

<sect2 id="functional-dependencies">
<title>関数従属
</title>

<para>関数従属は、&ldquo;<ulink url="http://citeseer.ist.psu.edu/jones00type.html">Type Classes with Functional Dependencies</ulink>&rdquo;, Mark P. Jones, In Proceedings of the 9th European Symposium on Programming, ESOP 2000, Berlin, Germany, March 2000, Springer-Verlag LNCS 1782,で述べられている通りに実装されている。
</para>
<para>
関数従属は、クラス宣言の構文中で次のように垂直線を使うことで導入される。
<programlisting>
  class (Monad m) => MonadState s m | m -> s where ...

  class Foo a b c | a b -> c where ...
</programlisting>
本来もっと説明があるべきだが、(まだ)ない。必要なら文句をいってほしい。
</para>

<sect3><title>関数従属に関する諸規則</title>
<para>
クラス宣言では、全てのメソッドについて、そのメソッドの型中の自由変数から、クラス型変数が全て(<xref linkend="flexible-contexts"/>で言われている意味で)到達可能でなければならない。例を挙げる。

<programlisting>
  class Coll s a where
    empty  :: s
    insert :: s -> a -> s
</programlisting>

これは正しくない。<literal>empty</literal>の型が<literal>a</literal>に言及していないからである。関数従属を使ってこの型変数に到達できるようにすることができる。
<programlisting>
  class Coll s a | s -> a where
    empty  :: s
    insert :: s -> a -> s
</programlisting>

あるいは、次のように<literal>Coll</literal>を書き換えても良い。

<programlisting>
  class Coll s a where
    empty  :: s a
    insert :: s a -> a -> s a
</programlisting>


<literal>a</literal>の集積物の型(<literal>(s a)</literal>)と要素の型である<literal>a</literal>との間につながりを作った訳である。
これがうまく行かないこともある。そういうときは、次のようにクラスを分割することができる。


<programlisting>
  class CollE s where
    empty  :: s

  class CollE s => Coll s a where
    insert :: s -> a -> s
</programlisting>
</para>
</sect3>


<sect3>
<title>関数従属の背景</title>

<para>なぜ関数従属が必要か、およびどのようにそれを使うか、についての以下の解説は、Hugsの利用者手引きから採られたものである。Mark Jonesが親切にも許可をくれたので、ここに(多少の改変の上で)転載する。
</para>
<para>

以下のクラスを考えてみよう。これは、何かの集まりを表す型を扱うライブラリの一部という意図である。
<programlisting>
   class Collects e ce where
       empty  :: ce
       insert :: e -> ce -> ce
       member :: e -> ce -> Bool
</programlisting>
型変数eは要素型を表しており、ceはコンテナの型を表している。この枠組みの下で、このクラスのインスタンスとして、リストや特性関数(どちらも、等値比較可能なあらゆる要素型の集まりを表現できる)、ビット集合(文字の集まりを表現できる)、ハッシュ表(ハッシュ関数のあるあらゆる要素型の集まりを表現できる)を持ちたいとしよう。標準的な実装の詳細を省くと、これは次のような宣言になる。
<programlisting>
   instance Eq e => Collects e [e] where ...
   instance Eq e => Collects e (e -> Bool) where ...
   instance Collects Char BitSet where ...
   instance (Hashable e, Collects a ce)
              => Collects e (Array Int ce) where ...
</programlisting>
クラスを定義し、いくつかの有用な実装を定義したわけで、ここまでのところ順調である。残念ながら、このクラス宣言にはいくつかの重大な問題がある。第一に、empty関数の型が曖昧である。
<programlisting>
   empty :: Collects e ce => ce
</programlisting>
「曖昧」だというのは、型変数eが<literal>=&gt;</literal>の左辺に現れるにもかかわらず、右辺には現れないということである。これが問題なのは、Haskellの多重定義の理論的基礎によると、曖昧な型のある項には、明確に定義された意味が与えられることを保証できないからである。
</para>
<para>
この問題を回避するだけなら、クラス宣言からemptyメンバを取り除くだけで良い。しかし、残りのメンバであるinsertとmemberも、型こそ曖昧でないが、使おうとすると問題が発生する。例えば、以下の例を考えてほしい。
<programlisting>
   f x y = insert x . insert y
   g     = f True 'a'
</programlisting>
これに対して、GHCは以下の型を推論する。
<programlisting>
   f :: (Collects a c, Collects b c) => a -> b -> c -> c
   g :: (Collects Bool c, Collects Char c) => c -> c
</programlisting>
fではxとyの値を一つの集まりに対して順番にinsertしようとしているが、fの型は、この二つの変数が異なる型を持つことを許している。我々が
表現しようとしているのが、ただ一つの型の値のみを含む集まりだとすれば、これは明らかに不正確な型である。さらに悪いことに、gの定義は、型エラーを起こすことなくコンパイルを通過する。結果として、このコードの誤りはすぐには明らかにされない。これが発覚するのはgを使おうとしたときで、これは別のモジュールであることさえあり得る。
</para>

<sect4><title>構築子クラスを使ってみる</title>

<para>
上記の問題点に直面して、Haskellプログラマの中には次のようなクラス宣言を使うのはどうかと考える者もいるだろう。
<programlisting>
   class Collects e c where
      empty  :: c e
      insert :: e -> c e -> c e
      member :: e -> c e -> Bool
</programlisting>
決定的な違いは、ここでは、集まりの型(元のクラス宣言のce)ではなく、型構築子cに関して抽象化しているという点である。集まりの型はcを使ってc eと表される。これで、上記の直接的な問題は解決された。emptyの型は<literal>Collects e c => c e</literal>であり、これは曖昧ではない。
</para>
<para>
前節の関数fには、より正確な型が与えられる。
<programlisting>
   f :: (Collects e c) => e -> e -> c e -> c e
</programlisting>
前節の関数gは、意図したとおり、型エラーで拒絶される。これは、fの型が、二つの引数が異なる型を持つことを許していないからである。従って、これは、多引数の型クラスが、曖昧さの問題無しに、実際的にかなりうまく行く例である。しかし欠陥もある。このCollectsクラスは、元々のクラスの意図と比べて著しく一般性に欠ける。上記の<literal>Collects</literal>に対する四つのインスタンスのうち、このCollectsに対して動作するのはリストのインスタンス一つだけである。ある型構築子cと要素型eについてc eという形で書けるのはこれだけだからである。
</para>
</sect4>

<sect4><title>関数従属を加える</title>

<para>
より有用なCollectsクラスを得るために、Hugsでは、多引数の型クラスにおいて引数間の従属関係(依存関係)をプログラマが指定できるようにする機構が提供される。(理論的基礎や先行研究に興味のある読者向け: 従属性情報の利用は、Chen、Hudak、Oderskyの提出した「パラメータ付き型クラス」の提案を一般化した物とも捉えられるし、Mark Jonesによるqualified typeの「improvement」のためのフレームワークの特別な場合とも捉えられる。基礎となる考えは原稿[implparam]で、より理論的で抽象的な土台で考察されている。そこでは、暗黙なパラメタ化のためのシステムの一般的な設計空間の中の一点として扱われている)。抽象的な例として、次のような宣言を考えよう。
<programlisting>
   class C a b where ...
</programlisting>
このようにすると、Cは型(aやbの種によっては型構築子)上の二項関係と捉えられる。次の例のように、クラス定義中に節を追加して、引数間の従属性に関する情報を追加することができる。
<programlisting>
   class D a b | a -> b where ...
   class E a b | a -> b, b -> a where ...
</programlisting>
ここで|とwhereの間に書かれている<literal>a -&gt; b</literal>という記法(関数の型と混同してはならない)は、引数aが引数bをただ一つ定めるということを意味しており、例えば「aがbを決める」と読む。従ってDは単なる関係ではなく、(部分)関数である。同様に、Eの定義中の二つの従属関係から、Eが(部分的な)一対一写像を表していることがわかる。
</para>
<para>
より一般的には、従属関係は<literal>x1 .. xn -&gt; y1 ... ym</literal>という形をとる。ここでx1, ..., xnおよびy1, ..., yn<!-- 訳注: ynでなくym? -->(n&gt;0、m&gt;0)は型変数であり、全てのy引数はx引数によって一意に決定されることを意味する。従属関係のどちらかの辺に複数の変数が現れるなら、<literal>t -&gt; a b</literal>のようにスペースで区切る。上記のEの例のように、一つのクラスについて複数の従属関係をコンマで区切って並べることができる。書き得る従属関係の中には冗長なものもあるが、これらの一部は拒絶される。全く役に立たない上に、プログラム中の誤りを反映しているかもしれないからである。このような従属関係の例として<literal>a -&gt; a</literal>、<literal>a -&gt; a a</literal>、<literal>a -&gt; </literal>などが挙げられる。複数の従属関係が与えられているとき、例えば<literal>a-&gt;b</literal>, <literal>b-&gt;c</literal>, <literal>a-&gt;c</literal>のような場合、複数の従属関係を組み合わせることで残りものが言え、やはり冗長だが、このような場合はエラーとされない。従属関係はクラス宣言にのみ現れ、言語の中のその他の場所には現れないことに注意。特に、インスタンス宣言、クラス制約、型はどれも全く変化を被らない。
</para>
<para>
クラス宣言に従属関係を含めることで、プログラマは多引数の型クラスをより精密に指定できる。一方、コンパイラは、プログラム中のどの一点においても、そこから見えるインスタンスの集合が宣言された従属性に整合していることを保証しなければならない。例えば、以下の二つのインスタンス宣言は一つのスコープに同時に現れてはならない。Dに関する従属性に反するからである。どちらか一方であれば問題ない。
<programlisting>
   instance D Bool Int where ...
   instance D Bool Char where ...
</programlisting>
また、以下のような宣言は単独でも禁止される。
<programlisting>
   instance D [a] b where ...
</programlisting>
ここでの問題は、特定の[a]に対して、複数のbが関連づけられ、結果としてDの定義で指定された従属性に反することである。
<programlisting>
   instance D t s where ...
</programlisting>
より一般的に、上のような宣言があったとすると、sには、tに現れる型変数しか現れてはならない。これで、tの型が既知であれば、sも一意に決定できることになる。
</para>
<para>
従属性情報を書くことの利点は、曖昧性の問題無しに、より一般的な多引数型クラスを書くことができ、より精密な型の恩恵に与ることができることである。これを解り易く示すために、集まりのクラスの例に戻り、<literal>Collects</literal>の定義に単純な従属性注釈を付け加えよう。
<programlisting>
   class Collects e ce | ce -> e where
      empty  :: ce
      insert :: e -> ce -> ce
      member :: e -> ce -> Bool
</programlisting>
ここで、<literal>ce -&gt; e</literal>という従属関係は、要素の型eが集まりの型ceによって一意に定まることを指定している。引数の種はどちらも*であることに注意してほしい。つまりこれは構築子クラスではない。また、最初に挙げたCollectsのインスタンスは全てこの新しい定義の下で有効である。
</para>
<para>
元々の定義を使ったときに現れた曖昧性の問題はどうだろうか。empty関数の型はCollects e ce => ceのままだが、もはやこれを曖昧だとみなす必要はない。変数eは=>記号の右辺に現れていないが、Collectsクラスの従属関係から、これがceによって一意に決定されることがわかる。ceは=>記号の右側に現れているので、emptyが使われるときの文脈から得られる情報で、ceとeの両方の型を曖昧さなく決定できる。一般的に、ある型が曖昧だとされるのは、=>の左辺に、右辺の変数によって(直接または間接に)一意に決定されない変数が存在するときだけである。
</para>
<para>
利用者定義の関数により正確な型を与えることにも従属性は寄与する。これにより、より早く誤りを見つけることができるようになり、プログラマがぐちゃぐちゃな型と格闘しなくても良いようになる。前に挙げたfの定義を思い出して欲しい。
<programlisting>
   f x y = insert x y = insert x . insert y
</programlisting>
これに対して、最初に得た型は次であった。
<programlisting>
   f :: (Collects a c, Collects b c) => a -> b -> c -> c
</programlisting>
しかし、Collectsについての従属性情報を使うと、aとbが等しくなければならないと推論できる。両者とも、同じように第一引数がcであるCollects制約<!-- 訳注: 引数の順序がおかしい -->の第二引数に現れているからである。これにより、fに対して、より短く、より本性を反映した型を推論することができる。
<programlisting>
   f :: (Collects a c) => a -> a -> c -> c
</programlisting>
同様の方法で、前に挙げたgの定義は型エラーとして処理される。
</para>
<para>
ここでは少しの例しか挙げなかったが、多引数型クラスは、従属性情報を付け加えることで、より実用的になり、曖昧さの問題が排除され、より一般的なインスタンスの集合を受け入れられるようになった、ということが明らかだろう。
</para>
</sect4>
</sect3>
</sect2>

<sect2 id="instance-decls">
<title>インスタンス宣言</title>

<para>インスタンス宣言は以下のような形をとる
<screen>
  instance ( <replaceable>assertion</replaceable><subscript>1</subscript>, ..., <replaceable>assertion</replaceable><subscript>n</subscript>) =&gt; <replaceable>class</replaceable> <replaceable>type</replaceable><subscript>1</subscript> ... <replaceable>type</replaceable><subscript>m</subscript> where ...
</screen>
「<literal>=&gt;</literal>」より前の部分は<emphasis>文脈</emphasis>であり、「<literal>=&gt;</literal>」より後の部分はこのインスタンス宣言の<emphasis>頭部</emphasis>と呼ばれる。
</para>

<sect3 id="flexible-instance-head">
<title>インスタンス頭部に関する規則の緩和</title>

<para>
Haskell 98では、インスタンス宣言の頭部は<literal>C (T a1 ... an)</literal>という形でなければならない。ここで、<literal>C</literal>はクラス、<literal>T</literal>はデータ型構築子、<literal>a1 ... an</literal>は相異なる型変数である。GHCはこれを二通りの方向に緩和する。
<itemizedlist>
<listitem><para>
<option>-XTypeSynonymInstances</option>フラグが有効なら、インスタンスの頭部が型シノニムを使ってもよい。他の場合と同様、型シノニムは、その定義の右辺の型を書くための略記法に過ぎない。例えば、以下は合法である。
<programlisting>
  type Point a = (a,a)
  instance C (Point a)   where ...
</programlisting>
このインスタンス宣言は以下と同等である。
<programlisting>
  instance C (Int,Int) where ...
</programlisting>
他の場合と同様に、型シノニムは完全に適用されていなければならない。例えば、以下のように書くことはできない。
<programlisting>
  instance Monad Point where ...
</programlisting>
</para></listitem>

<listitem>
<para>
<option>-XFlexibleInstances</option>フラグは、インスタンス宣言の頭部が任意のネストした型に言及するのを許す。例として、これが合法なインスタンス宣言になる。
<programlisting>
  instance C (Maybe Int) where ...
</programlisting>
<link linkend="instance-overlap">重複に関する規則</link>も見よ。
</para>
<para>
<option>-XFlexibleInstances</option>フラグは<option>-XTypeSynonymInstances</option>も有効にする。
</para></listitem>
</itemizedlist>
</para>
</sect3>

<sect3 id="instance-rules">
<title>インスタンス文脈に関する規則の緩和</title>

<para>Haskell 98では、インスタンス宣言中の文脈における表明は<literal>C a</literal>という形でなければならない。ここで<literal>a</literal>は頭部に出現する型変数である。
</para>

<para>
<option>-XFlexibleContexts</option>フラグは、この規則を緩め、さらに型シグネチャについての同様の規則も緩める(<xref linkend="flexible-contexts"/>を見よ)。このフラグが有効なら、インスタンス宣言の文脈は、下記の規則に従う限り、(種の正しい)任意の表明<literal>(C t1 ... tn)</literal>から成っていてよい。
<orderedlist>
<listitem><para>
Paterson条件: 文脈中の各表明に対して、次が求められる。
<orderedlist>
<listitem><para>その表明に、頭部よりも多く出現する型変数があってはならない</para></listitem>
<listitem><para>その表明中の構築子と変数の数の合計(同じ物でも複数回数える)が、頭部中のそれよりも少なくなければならない。</para></listitem>
</orderedlist>
</para></listitem>

<listitem><para>対応範囲条件(Coverage Condition)。クラス中のそれぞれの関数従属<replaceable>tvs</replaceable><subscript>left</subscript> <literal>-&gt;</literal> <replaceable>tvs</replaceable><subscript>right</subscript>に対して、S(<replaceable>tvs</replaceable><subscript>right</subscript>)中の型変数は全てS(<replaceable>tvs</replaceable><subscript>left</subscript>)にも現れなければならない。ただし、Sは、クラス宣言中の型変数を対応するインスタンス宣言中の型に対応させる置換写像である。
</para></listitem>
</orderedlist>
これらの制約により、文脈の簡約に終わりがあることが保証される。一回簡約するごとに最悪でも構築子一つ分問題が小さくなるからである。<option>-XUndecidableInstances</option>フラグ(<xref linkend="undecidable-instances"/>)を与えれば、Paterson条件と対応範囲条件の両方が撤廃される。これらの制限がある理由についての沢山の背景資料が、論文<ulink  url="http://research.microsoft.com/%7Esimonpj/papers/fd%2Dchr/">Understanding functional dependencies via Constraint Handling Rules</ulink>に見つかる。</para>

<para>
例を挙げると、以下のものは問題ない。
<programlisting>
  instance C Int [a]          -- 多引数
  instance Eq (S [a])         -- 頭部に構造のある型

      -- 頭部に同じ型変数が複数回出現
  instance C4 a a => C4 [a] [a]
  instance Stateful (ST s) (MutVar s)

      -- 頭部は型変数のみから成っていても良い
  instance C a
  instance (Eq a, Show b) => C2 a b

      -- 文脈中に型変数以外のものがあっても良い
  instance Show (s a) => Show (Sized s a)
  instance C2 Int a => C3 Bool [a]
  instance C2 Int a => C3 [a] b
</programlisting>
一方で、下記は禁止される。
<programlisting>
      -- 文脈の表明が頭部より小さくない
  instance C a => C a where ...
      -- (C b b)に頭部よりも多くのbの出現がある
  instance C b b => Foo [b] where ...
</programlisting>
</para>

<para>
これと同じ制約が、<literal>deriving</literal>節で生成されたインスタンスにも適用される。従って、下記のものは許される。
<programlisting>
  data MinHeap h a = H a (h a)
    deriving (Show)
</programlisting>
これは、自動導出された以下のインスタンスが上記の規則に整合するからである。
<programlisting>
  instance (Show a, Show (h a)) => Show (MinHeap h a)
</programlisting>
</para>

<para>
上記の規則によって、ある便利なイディオムが可能になる。重複インスタンス宣言を許すとき、より特化したインスタンスが当てはまらないときに適用される「デフォルトのインスタンス」があると非常に便利である。
<programlisting>
  instance C a where
    op = ... -- デフォルト
</programlisting>
</para>
</sect3>

<sect3 id="undecidable-instances">
<title>決定不能インスタンス</title>

<para>
<xref linkend="instance-rules"/>の規則でさえも厄介なことがある。例えば、次のようにして「クラスシノニム」のような効果を得たいと思うかもしれない。
<programlisting>
  class (C1 a, C2 a, C3 a) => C a where { }

  instance (C1 a, C2 a, C3 a) => C a where { }
</programlisting>
次のようなシグネチャがあったとする。
<programlisting>
  f :: (C1 a, C2 a, C3 a) => ...
</programlisting>
これは上記のものを使えば次のように書ける。
<programlisting>
  f :: C a => ...
</programlisting>
関数従属(<xref linkend="functional-dependencies"/>)についての制約は特に面倒である。通常の規則では禁止されているものの、頭部に現れない型変数を文脈中で使いたいと思うことがあるだろう。以下のような場合である。
<programlisting>
  class HasConverter a b | a -> b where
     convert :: a -> b

  data Foo a = MkFoo a

  instance (HasConverter a b,Show b) => Show (Foo a) where
     show (MkFoo value) = show (convert value)
</programlisting>
しかし、これは危険な領域である。例えば、以下のものは、型検査器をループさせる。
<programlisting>
  class D a
  class F a b | a->b
  instance F [a] [[a]]
  instance (D c, F a c) => D [a]   -- 「c」は頭部で言及されていない
</programlisting>
同様に、対応範囲条件を撤廃したいと思うかもしれない。
<programlisting>
  class Mul a b c | a b -> c where
  	(.*.) :: a -> b -> c

  instance Mul Int Int Int where (.*.) = (*)
  instance Mul Int Float Float where x .*. y = fromIntegral x * y
  instance Mul a b c => Mul a [b] [c] where x .*. v = map (x.*.) v
</programlisting>
三番目のインスタンス宣言は対応範囲条件に従っていない。実際、以下の(やや奇妙な)例では、型推論がループに陥る。これは、<literal>(Mul a [b] b)</literal>という制約を要求するからである。
<programlisting>
  f = \ b x y -> if b then x .*. [y] else y
</programlisting>
</para>
<para>
これにもかかわらず、GHCは、より自由な規則の下で実験することを許している。<option>-XUndecidableInstances</option> <indexterm><primary>-XUndecidableInstances option</primary></indexterm>という実験的なフラグを使えば、Paterson条件と対応範囲条件(<xref linkend="instance-rules"/>に記述がある)の両方が撤廃される。停止性は、深さ固定の再帰スタックを使うことで保証される。スタックの深さを超過した場合、バックトレースのようなものが表示される。この時、<option>-fcontext-stack=</option><emphasis>N</emphasis>で、スタックをより深くすることもできる。
</para>

</sect3>


<sect3 id="instance-overlap">
<title>重複インスタンス</title>
<para>
一般に、<emphasis>GHCでは、型クラス制約を解決するのにどのインスタンス宣言を使えば良いかが曖昧さなく決まることが要求される</emphasis>。この挙動を変更するフラグが二つある。<option>-XOverlappingInstances</option> <indexterm><primary>-XOverlappingInstances </primary></indexterm>と<option>-XIncoherentInstances</option> <indexterm><primary>-XIncoherentInstances </primary></indexterm>である。この節ではこれらを扱う。これらは両方とも動的フラグであり、(望むなら<literal>OPTIONS_GHC</literal>プラグマを使って)モジュール単位で設定することができる。(<xref linkend="source-file-options"/>)</para>
<para>
例えば、<literal>C Int Bool</literal>という制約を解決しようとするときは、全てのインスタンス宣言について、その頭部を具体化して、この制約と照合しようと試みられる。例として、以下のようなインスタンス宣言があったとしよう。
<programlisting>
  instance context1 => C Int a     where ...  -- (A)
  instance context2 => C a   Bool  where ...  -- (B)
  instance context3 => C Int [a]   where ...  -- (C)
  instance context4 => C Int [Int] where ...  -- (D)
</programlisting>
インスタンス(A)および(B)は制約<literal>C Int Bool</literal>に適合するが、(C)や(D)は適合しない。照合の際、インスタンス宣言の文脈(<literal>context1</literal>など)は無視される。GHCのデフォルトの振る舞いは、<emphasis>解決中の制約に適合するインスタンスがただ一つ存在しなければならない</emphasis>というものである。<emphasis>潜在的な</emphasis>重複(例えば(A)と(B)の両方がスコープにある場合)があっても問題はない。特定の制約に複数のインスタンスが適合して初めてエラーが報告される。
</para>

<para>
<option>-XOverlappingInstances</option>フラグは、最も特殊性の高いインスタンスが存在することを条件に、複数のインスタンスの適合を認めるものである。例えば、<literal>C Int [Int]</literal>には(A)、(C)、(D)の各インスタンスが適合するが、最後のものの特殊性が最も高いので、これが選ばれる。最も特殊性の高いものがない場合は、プログラムが拒絶される。
</para>
<para>
ただし、GHCは重複インスタンスから特定のものを選ぶことに関しては保守的である。例。
<programlisting>
  f :: [b] -> [b]
  f x = ...
</programlisting>
<literal>f</literal>の右辺から、<literal>C Int [b]</literal>という制約を得たとしよう。しかし、GHCはインスタンス(C)を使うことはない。なぜなら、<literal>f</literal>の呼び出しによっては、<literal>b</literal>が<literal>Int</literal>に実体化するかも知れず、その場合は(D)が最も特殊性の高いインスタンスになるからである。よって、GHCはこのプログラムを拒絶する。(<option>-XIncoherentInstances</option>フラグを追加すると、GHCは、後々のインスタンス化についての問題を指摘することなく、(C)を選ぶようになる)。
</para>
<para>
<literal>f</literal>に型シグネチャを与えたので、<literal>f</literal>が指定した型を持っていることをGHCが<emphasis>検査</emphasis>せねばならなかったことに注意。そうでなく、型シグネチャを与えず、GHCに<emphasis>推論</emphasis>してもらったとしよう。この場合、GHCは<literal>C Int [b]</literal>という制約を単純化することは避ける(前と同じ理由)が、プログラムを拒絶することはなく、以下の型を推論する。
<programlisting>
  f :: C Int [b] => [b] -> [b]
</programlisting>
これは、どのインスタンスを選ぶかの問題を<literal>f</literal>の呼び出し側まで遅延する。その時には、型<literal>b</literal>についてより多くが知られているだろう。
<link linkend="flexible-contexts"><option>-XFlexibleContexts</option></link>フラグを使えば、この型シグネチャを自分で書くことができる。
</para>
<para>
インスタンス宣言自体についても、まったく同じ状況が発生し得る。以下のものがあるとしよう。
<programlisting>
  class Foo a where
     f :: a -> a
  instance Foo [b] where
     f x = ...
</programlisting>
さらに、前と同じように、制約<literal>C Int [b]</literal>が<literal>f</literal>の右辺から発生するとする。制約<literal>C Int [b]</literal>は複数のインスタンス宣言に適合するので、前と同様にGHCはこの制約を解決する方法が分からないとしてこのインスタンスを拒絶する。解決策は、インスタンス宣言の文脈にこの制約を加えて、選択を後回しにすることである。次のように。
<programlisting>
  instance C Int [b] => Foo [b] where
     f x = ...
</programlisting>
(これをするには<link linkend="instance-rules"><option>-XFlexibleInstances</option></link>が必要である)
</para>
<para>
警告: 重複インスタンスを使うときは気を付けないといけない。一貫性が失われる(つまり、プログラムの部分部分で異なるインスタンスが選ばれる)可能性があるからである。これは<option>-XIncoherentInstances</option>を使っていない場合ですらそうである。以下を考えよ。
<programlisting>
{-# LANGUAGE OverlappingInstances #-}
module Help where

    class MyShow a where
      myshow :: a -> String

    instance MyShow a => MyShow [a] where
      myshow xs = concatMap myshow xs

    showHelp :: MyShow a => [a] -> String
    showHelp xs = myshow xs

{-# LANGUAGE FlexibleInstances, OverlappingInstances #-}
module Main where
    import Help

    data T = MkT

    instance MyShow T where
      myshow x = "Used generic instance"

    instance MyShow [T] where
      myshow xs = "Used more specific instance"

    main = do { print (myshow [MkT]); print (showHelp [MkT]) }
</programlisting>
<literal>showHelp</literal>関数では、GHCから重複のあるインスタンスが見えないので、GHCは文句を言うことなく<literal>MyShow [a]</literal>インスタンスを使う。<literal>main</literal>中の<literal>myshow</literal>の呼び出しでは、GHCは、制約<literal>MyShow [T]</literal>を解決するに際して<literal>Main</literal>モジュールの重複インスタンス宣言を使う。結果として、このプログラムは次のように表示する。
<programlisting>
  "Used more specific instance"
  "Used generic instance"
</programlisting>
(実装されていないが、他にあり得る振る舞いとして、後のインスタンス宣言が局所的なものと重複するかもしれないという理由で<literal>Help</literal>モジュールを拒絶するというものがある。)
</para>
<para>
重複インスタンスや非整合(incoherent)インスタンスになるかどうかは、<emphasis>インスタンス宣言</emphasis>の性質であり、そのモジュールがコンパイルされるときに<option>-XOverlappingInstances</option>と<option>-XIncoherentInstances</option>が有効になっていたかどうかで決まる。より精密には、インスタンス発見の過程では、以下が成り立つ。
<itemizedlist>
<listitem><para>
問題となっている制約にIA、IBという二つのインスタンス宣言が適合し、かつ、
<itemizedlist>
<listitem><para>IBはIAの置換例である(がその逆ではない)。つまり、IBがIAよりも厳密に特殊性が高い。</para></listitem>
<listitem><para>IAかIBの少なくともいずれかが<option>-XOverlappingInstances</option>付きでコンパイルされている。</para></listitem>
</itemizedlist>
なら、特殊性が低いインスタンスであるIAは無視される。
</para></listitem>
<listitem><para>
問題となっている制約に対して、あるインスタンス宣言が、適合はしないものの<emphasis>単一化する</emphasis>場合を考えてみよう。この場合、制約がさらに具体化すると、そのインスタンス宣言が適合する可能性がある。通常、GHCは、これを理由として、他の制約<!-- 訳注: インスタンスの誤り? -->を採用しない。しかし、もしそのインスタンス宣言が<option>-XIncoherentInstances</option>付きでコンパイルされているなら、GHCはこの「単一化するか？」の検査を行わない。
</para></listitem>
</itemizedlist>
これらの規則によって、ライブラリの作者は、重複インスタンスに依存したライブラリを、利用者がそれについて知らなくても良いように設計することができる。
</para>
<para><option>-XIncoherentInstances</option>フラグを使うと、<option>-XOverlappingInstances</option>フラグは自動的に有効になる。逆は真でない。
</para>
</sect3>

<sect3 id="instance-sigs">
<title>インスタンス宣言中の型シグネチャ</title>
<para>Haskellでは、インスタンス宣言に型シグネチャを書くことはできない。しかしこれができると便利なことがあるので、言語拡張<option>-XInstanceSigs</option>がこれを許す。例を示す。
<programlisting>
  data T a = MkT a a
  instance Eq a => Eq (T a) where
    (==) :: T a -> T a -> Bool   -- シグネチャ
    (==) (MkT x1 x2) (MkTy y1 y2) = x1==y1 &amp;&amp; x2==y2
</programlisting>
インスタンス宣言における型シグネチャは、クラス宣言内のものにインスタンスの型をあてはめたものと全く同じでなければならない。
</para>
<para>
型シグネチャを書きたいと思うスタイル上の理由の一つは、単純なドキュメントとしてである。もう一つは、スコープを持つ型変数をスコープに導入したいかもしれないからである。例。
<programlisting>
class C a where
  foo :: b -> a -> (a, [b])
 
instance C a => C (T a) where
  foo :: forall b. b -> T a -> (T a, [b])
  foo x (T y) = (T y, xs)
     where
       xs :: [b]
       xs = [x,x,x]
</programlisting>
<option>-XScopedTypeVariables</option>(<xref linkend="scoped-type-variables"/>)も指定しているなら、<literal>forall b</literal>のスコープは<literal>foo</literal>の定義にわたる。特に<literal>xs</literal>の型シグネチャもこれに含まれる。
</para>
</sect3>
</sect2>

<sect2 id="overloaded-strings">
<title>文字列リテラルの多重定義</title>

<para>
GHCは<emphasis>文字列リテラルの多重定義</emphasis>に対応している。通常、文字列リテラルは型<literal>String</literal>を持つが、文字列リテラルの多重定義を有効にする(<literal>-XOverloadedStrings</literal>で)と、文字列リテラルが<literal>(IsString a) => a</literal>という型を持つようになる。
</para>
<para>
これは、通常の文字列構文を使って、例えば<literal>ByteString</literal>、<literal>Text</literal>その他の文字列的な型を書くことができるということである。文字列リテラルは整数リテラルとほとんど同じように振る舞う。つまり、式とパターンの両方で使うことができる。リテラルがパターンで使われた場合、整数リテラルと同じ方法で、等値性のテストに置き換えられる。
</para>
<para>
クラス<literal>IsString</literal>は次のように定義されている。
<programlisting>
class IsString a where
    fromString :: String -> a
</programlisting>
定義済みのインスタンスは一つだけで、文字列が通常通りに使えるようにする、自明なものである。
<programlisting>
instance IsString [Char] where
    fromString cs = cs
</programlisting>
<literal>IsString</literal>クラスはデフォルトでスコープに無い。明示的に言及したい(例えば、インスタンス宣言のために)なら、<literal>GHC.Exts</literal>モジュールからインポートすることができる。
</para>
<para>
<option>-XOverloadedStrings</option>が指定されたときは、Haskellのデフォルト化機構が拡張されて、文字列リテラルにも対応するようになる。具体的には以下の通り。
<itemizedlist>
<listitem><para>
デフォルト宣言におけるそれぞれの型は、<literal>Num</literal><emphasis>または</emphasis><literal>IsString</literal>のインスタンスでなければならない。
</para></listitem>

<listitem><para>
標準のデフォルト化規則(<ulink url="http://www.haskell.org/onlinereport/decls.html#sect4.3.4">Haskell Report, Section 4.3.4</ulink>)は次のように拡張される。デフォルト化は、全ての未解決の制約が標準のクラス<emphasis>または</emphasis><literal>IsString</literal>についてであって、少くとも一つが数値クラス<emphasis>または</emphasis><literal>IsString</literal>である場合に適用される。
</para></listitem>
</itemizedlist>
</para>
<para>
小さい例を示す。
<programlisting>
module Main where

import GHC.Exts( IsString(..) )

newtype MyString = MyString String deriving (Eq, Show)
instance IsString MyString where
    fromString = MyString

greet :: MyString -> MyString
greet "hello" = "world"
greet other = other

main = do
    print $ greet "hello"
    print $ greet "fool"
</programlisting>
</para>
<para>
パターン照合は等値比較に翻訳されるので、パターン照合のためには<literal>Eq</literal>を自動導出することが必要だということに注意。
</para>
</sect2>
</sect1>

<sect1 id="type-families">
<title>型の族</title>

<para><firstterm>添字付けされた型の族</firstterm>は、型水準のプログラミングを容易にするための新しいGHC拡張である。型の族は、<firstterm>関連データ型</firstterm>(&ldquo;<ulink url="http://www.cse.unsw.edu.au/~chak/papers/CKPM05.html">Associated Types with Class</ulink>&rdquo;, M. Chakravarty, G. Keller, S. Peyton Jones, and S. Marlow. In Proceedings of &ldquo;The 32nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL'05)&rdquo;, pages 1-13, ACM Press, 2005)および<firstterm>関連型シノニム</firstterm>(&ldquo;<ulink url="http://www.cse.unsw.edu.au/~chak/papers/CKP05.html">Type Associated Type Synonyms</ulink>&rdquo;. M. Chakravarty, G. Keller, and S. Peyton Jones. In Proceedings of &ldquo;The Tenth ACM SIGPLAN International Conference on Functional Programming&rdquo;, ACM Press, pages 241-253, 2005)の一般化である。型の族自体は論文&ldquo;<ulink url="http://www.cse.unsw.edu.au/~chak/papers/SPCS08.html">Type Checking with Open Type Functions</ulink>&rdquo;, T. Schrijvers, S. Peyton-Jones, M. Chakravarty, and M. Sulzmann, in Proceedings of &ldquo;ICFP 2008: The 13th ACM SIGPLAN International Conference on Functional Programming&rdquo;, ACM Press, pages 51-62, 2008 Functional Programming&rdquo;, ACM Press, pages 241-253, 2005)に記述されている。型の族は、要するに、型で添字付けされたデータ型と、型についての名前の付いた関数を提供する。これらは、総称(generic)プログラミングや高度にパラメタ化されたライブラリインタフェース、さらには、依存型と同様に、インタフェースにより多くの静的な情報を与えるのに有用である。また、型の族は関数従属の代わりとなるものとも見なされている。関数従属では型水準のプログラミングを関係的に行うのに対して、型の族はより関数的な様式を可能にする。
</para>
<para>添字付けされた型の族(indexed type family)、短くいうと型族(type family)は、型の集合を表すような型構築子である。集合の要素は、型族構築子に型引数(<firstterm>型添字</firstterm>と呼ぶ)を与えることで記述される。通常のパラメタ付きの型構築子と族構築子との違いは、パラメタ多相な関数と型クラスの(アドホック多相な)メソッドとの違いによく似ている。パラメタ多相な関数はあらゆる具体的な型に対して等しく振る舞うのに対し、クラスのメソッドはクラスの型パラメタに依存して振る舞いを変える。同様に、通常の型構築子はあらゆる具体的な型に対して同じデータ表現を使うことになるが、型族構築子は異なる型添字に対して異なる表現型を持つことができる。</para>
<para>添字付けされた型の族には二つの系統がある。<firstterm>データ族</firstterm>と<firstterm>型シノニム族</firstterm>である。これらは、それぞれ代数的データ型と型シノニムを添字付けされた型の族にしたものである。データの族のインスタンスとしてはデータ型とnewtypeがありえる。
</para>
<para>型の族は<option>-XTypeFamilies</option>フラグによって有効になる。GHCで型の族を使うことについてのさらなる情報が<ulink url="http://www.haskell.org/haskellwiki/GHC/Indexed_types">型の族についてのHaskell wikiのページ</ulink>にある。
</para>

<sect2 id="data-families">
  <title>データ族</title>

  <para>データ族には次の二つの系統がある。(1)最上位で定義されるもの (2)型クラスの中に現れるもの(この場合、これは関連型と言われる)。前者の方が一般性の高い系統である。なぜなら、型添字がクラスのパラメタと一致する必要がないからである。一方、後者の方が明確に構造化されたコードにつながりやすく、なんらかの型インスタンスが(もしかすると意図せずに)省略された場合、コンパイラが警告を発する。以下では常に、まず一般的な最上位の形式について議論し、その後で関連型に課せられる追加の制約を扱う。
  </para>

  <sect3 id="data-family-declarations">
    <title>データ族宣言</title>

    <para>添字付けされたデータ族は次のようなシグネチャによって導入される。
<programlisting>
data family GMap k :: * -> *
</programlisting>
この特別な<literal>family</literal>が、族を標準的なデータ宣言から区別する。結果の種注釈は省略可能であり、省かれた場合は通常同様に<literal>*</literal>が使われる。例を示す。
<programlisting>
data family Array e
</programlisting>
名前の付いた引数にも必要なら明示的な種シグネチャを与えることができる。[http://www.haskell.org/ghc/docs/latest/html/users_guide/gadt.html GADT宣言]の場合と同様、名前付き引数は完全に省略可能なので、<literal>Array</literal>を次のように宣言することもできる。
<programlisting>
data family Array :: * -> *
</programlisting>
    </para>

  </sect3>

  <sect3 id="data-instance-declarations">
    <title>データインスタンス宣言</title>

    <para>データとnewtypeの族についてのインスタンス宣言は、通常のデータおよびnewtypeの宣言と良く似ている。違いが二つだけあって、<literal>data</literal>あるいは<literal>newtype</literal>キーワードの後に<literal>instance</literal>が書かれることと、型引数の一部または全てが変数でない型であってもよいということである。ただし、これにforall型や型シノニム族が含まれていてはいけない。しかし、一般にデータ族が型パラメタ中にあってもよく、型シノニムも、それが完全に適用されていて、しかも展開結果が合法であるなら、認められる。これはクラスインスタンスのパラメタにおいて型シノニムが現れてよい条件と全く同じである。例として、<literal>GMap</literal>の<literal>Either</literal>インスタンスは次のようになる。
<programlisting>
data instance GMap (Either a b) v = GMapEither (GMap a v) (GMap b v)
</programlisting>
この例では、宣言にただ一つのvariantしかないが、一般にはいくつあってもよい(訳注: データ構築子が複数あってもいいということ？)。
    </para>
    <para>データインスタンス宣言およびnewtypeインスタンス宣言は適切な族宣言がスコープにある場合のみ認められる。これはちょうど、クラスインスタンス宣言にクラス宣言が可視であることが必要なのと同じである。さらに、各インスタンス宣言は、その族宣言によって決まる種に準拠していなければならない。つまり、インスタンス宣言のパラメタの個数は、その族の種から決まるアリティと一致するということである。
    </para>
    <para>データ族インスタンス宣言は、通常の<literal>data</literal>や<literal>newtype</literal>宣言が持つ表現力を完全に利用できる。
      <itemizedlist>
      <listitem><para>データ族は「<literal>data</literal>」キーワードを使って<emphasis>導入される</emphasis>が、族の<emphasis>インスタンス</emphasis>は<literal>data</literal>であっても<literal>newtype</literal>であってもよく、両者の混合であってもよい。例を示す。
<programlisting>
data family T a
data    instance T Int  = T1 Int | T2 Bool
newtype instance T Char = TC Bool
</programlisting>
      </para></listitem>
      <listitem><para><literal>data instance</literal>はデータ構築子にGADT構文を使うことができ、また実際にGADTを定義することができる。例。
<programlisting>
data family G a b
data instance G [a] b where
   G1 :: c -> G [Int] b
   G2 :: G [a] Bool
</programlisting>
      </para></listitem>
      <listitem><para><literal>data instance</literal>や<literal>newtype instance</literal>宣言に<literal>deriving</literal>節を使うことができる。
      </para></listitem>
      </itemizedlist>
    </para>

    <para>
型族が最上位の宣言によって定義されている場合でも、異なる族インスタンスに対して異なる計算を行う関数は相変らず型クラスのメソッドとして定義されねばならないことがある。特に、以下は不可能である。
<programlisting>
data family T a
data instance T Int  = A
data instance T Char = B
foo :: T a -> Int
foo A = 1             -- 間違い: この二つの等式をいっしょにすると...
foo B = 2             -- ...型エラーが発生する
</programlisting>
代わりに、<literal>foo</literal>をクラスの演算として書かなければならないだろう。
<programlisting>
class Foo a where
  foo :: T a -> Int
instance Foo Int where
  foo A = 1
instance Foo Char where
  foo B = 2
</programlisting>
(GADT(一般化代数的データ型)の提供する機能を見ると、上のような定義が可能であるべきだと思えるかもしれない。しかし、型族は、GADTとは対照的に、<emphasis>開かれて</emphasis>いる。つまり、常に新しいインスタンスを加えることが可能な(しかも別モジュールでかもしれない)のである。異なるデータインスタンスに跨がるパターン照合に対応するには、一種の拡張可能なcase構造が必要になることだろう。)
    </para>
    </sect3>

    <sect3 id="data-family-overlap">
      <title>データインスタンスの重複</title>
      <para>一つのプログラムの中で、あるデータ族のインスタンス宣言に少しでも重複部分があってはならない。このことは関連族であるかそうでないかによらない。型クラスのインスタンスの場合と異なり、これは単なる整合性の問題ではなく、型安全性の問題である。
      </para>

  </sect3>

</sect2>

<sect2 id="synonym-families">
  <title>シノニム族</title>

  <para>型族が出現する方法には二通りの系統がある。(1)最上位で定義されるか、(2)型クラスの内部に出現する(この場合、これは関連型シノニムと言われる)かである。前者の系統は、型添字がクラスパラメタと一致しなければならないという制限がないので、より一般性が高い。一方、後者の方が明確に構造化されたコードにつながりやすく、なんらかの型インスタンスが(もしかしたら意図せず)省略された場合、コンパイラが警告を発する。以下では常に、まず一般的な最上位の形式について議論し、その後で関連型に課せられる追加の制約を扱う。
  </para>

  <sect3 id="type-family-declarations">
    <title>型族宣言</title>

    <para>添字付けされた型族は次のようなシグネチャによって導入される。
<programlisting>
type family Elem c :: *
</programlisting>
この特別な<literal>family</literal>によって、通常の型宣言と族宣言が区別される。結果の種注釈は省略可能であり、通常と同様に、省略された場合は<literal>*</literal>が使われる。例えば次のようになる。
<programlisting>
type family Elem c
</programlisting>
必要ならパラメタにも明示的な種シグネチャを付けることができる。型族宣言におけるパラメタの数をその族のアリティと呼び、その型族の適用は全てそのアリティに対して完全に飽和していなければ(訳注: つまり部分適用であっては)ならない。この制限は通常の型シノニムにはないものである<!-- 訳注: ほんとか？ -->。これにより、型族の種を知っただけではその族のアリティを決定できないので、型族の適用が正しいものかどうかも一般的には判断できない。例として、次の宣言を考える。
<programlisting>
type family F a b :: * -> *   -- Fの種は全体として見れば * -> * -> * -> *
                              -- しかし、アリティは2である
</programlisting>
この宣言のもとで、以下に正しい型と間違った型の例を示す。
<programlisting>
F Char [Int]       -- 正 種: * -> *
F Char [Int] Bool  -- 正 種: *
F IO Bool          -- 誤 最初の引数で種が不一致
F Bool             -- 誤 適用が飽和していない
</programlisting>
      </para>
  </sect3>

  <sect3 id="type-instance-declarations">
    <title>型インスタンス宣言</title>
    <para>型族のインスタンス宣言は通常の型シノニム宣言によく似ている。違いは、<literal>type</literal>キーワードの後に<literal>instance</literal>が書かれることと、型引数の一部または全部が変数でなくてもよいことの二点だけである。ただし、型引数は、forall型や型シノニム族を含んでいてはならない。一方、一般にデータ族はあってもよく、型シノニムも、完全に適用されており、かつ展開結果が合法であるなら認められる。これらはデータインスタンスの場合と全く同じ制限である。例として、<literal>[e]</literal>の<literal>Elem</literal>インスタンスは次のようになる。
<programlisting>
type instance Elem [e] = e
</programlisting>
    </para>
    <para>型族インスタンス宣言は、適切な族宣言がスコープにあるときのみ認められる。これはちょうど、クラスインスタンスにはクラス宣言が可視であることが必要なのと同じである。さらに、個々のインスタンス宣言は、その族宣言によって決まる種に準拠していなければならず、インスタンス宣言の型パラメタの数は族宣言の型パラメタの数と一致していなければならない。最後に、型インスタンスの右辺は単相型でなければ(つまり、forallを含んでいては)ならず、また飽和した通常の(訳注: vanilla; 型シノニム族でない)型シノニムを全て展開した時点で、族シノニム以外のシノニムが残っていてはならない。許される型インスタンスとそうでない型インスタンスの例をいくつか挙げる。
<programlisting>
type family F a :: *
type instance F [Int]              = Int         -- OK!
type instance F String             = Char        -- OK!
type instance F (F a)              = a           -- 誤: 型パラメタが型族に言及している
type instance F (forall a. (a, b)) = b           -- 誤: 型パラメタの中にforall型がある
type instance F Float              = forall a.a  -- 誤: 右辺がforall型であってはならない

type family G a b :: * -> *
type instance G Int            = (,)     -- 誤: 引数は二つでないといけない
type instance G Int Char Float = Double  -- 誤: 引数は二つでないといけない
</programlisting>
    </para>
    </sect3>

    <sect3 id="type-family-overlap">
      <title>型シノニムインスタンスの重複</title>
      <para>
ある一つのプログラム内で使われる型族のインスタンス宣言に関して、重複が許されるのは、重複するインスタンスの右辺が共通部分の型に対しては一致する場合だけである。より形式的に言うと、二つのインスタンス宣言が重複するとは、インスタンスの左辺を構文的に一致させるような代入(substitution)が存在するときである。これに該当する場合は必ず、この同じ代入のもとでインスタンスの右辺も構文的に同じにならなければならない。この条件は族が関連族であるかどうかに拠らない。また、これは単なる整合性の問題ではなく、型安全性の問題である。
      </para>
      <para>
重複が許される条件を説明するために二つの例を用意した。
<programlisting>
type instance F (a, Int) = [a]
type instance F (Int, b) = [b]   -- 重複が許される

type instance G (a, Int)  = [a]
type instance G (Char, a) = [a]  -- 非合法な重複、[Char] /= [Int]であるため
</programlisting>
      </para>
    </sect3>

    <sect3 id="type-family-decidability">
      <title>型シノニムインスタンスの決定可能性</title>
      <para>
	      型族の存在下での型推論が決定可能であることを保証するため、型インスタンス宣言の形式に追加で制限を課す必要がある。(&ldquo;<ulink url="http://www.cse.unsw.edu.au/~chak/papers/SPCS08.html">Type Checking with Open Type Functions</ulink>&rdquo;のDefinition 5 (Relaxed Condition)も参照)。インスタンス宣言の一般形式は次の通りである。
<programlisting>
type instance F t1 .. tn = t
</programlisting>
ここで、<literal>t</literal>中のすべての型族適用<literal>(G s1 .. sm)</literal>に対して、以下のことを要求する。
	<orderedlist>
	  <listitem>
		  <para><literal>s1 .. sm</literal>に、型族構築子が一つも含まれない。</para>
	  </listitem>
	  <listitem>
		  <para><literal>s1 .. sm</literal>中のシンボル(データ型構築子および型変数)の数が、<literal>t1 .. tn</literal>における数よりも厳密に小さい。</para>
	  </listitem>
	  <listitem>
		  <para>全ての型変数<literal>a</literal>について、aが<literal>s1 .. sm</literal>に現れる回数が、<literal>t1 .. tn</literal>に現れる回数を超えない。</para>
	  </listitem>
	</orderedlist>
これらの制限は容易に検査することができ、型インスタンスが停止することを保証する。しかし、<literal>a ~ [F a]</literal>のように、型構築子が族適用とデータ構築子適用の下にある、いわゆる「ループ的同値」の存在下では、型推論の完全性を保証するのに足りない。詳細については上で挙げた論文を参照のこと。</para>
      <para><option>-XUndecidableInstances</option>オプションがコンパイラに渡されると、上記の制約は強制されず、型推論中に型族の正規化が停止することを保証するのはプログラマの責任になる。
      </para>
    </sect3>
  </sect2>


<sect2 id="assoc-decl">
<title>関連データ族と関連型族</title>
<para>
データまたは型シノニムを型クラスの一部として宣言することができる。次にように。
<programlisting>
class GMapKey k where
  data GMap k :: * -> *
  ...

class Collects ce where
  type Elem ce :: *
  ...
</programlisting>
このようにするとき、「<literal>family</literal>」キーワードは使わない。
</para>
<para>型パラメタはもちろん全て型変数でなければならない。そして、そのうちのいくつか(全部でなくてよい)はクラスパラメタであってよい。個々のクラスパラメタは関連型一個につき高々一回しか使われてはならないが、使われないものがあっても良いし、クラス頭部とは違う順番であっても良い。よって、次の不自然な例は許容される。
<programlisting>
  class C a b c where
    type T c a x :: *
</programlisting>
        ここで<literal>c</literal>と<literal>a</literal>はクラスパラメタであるが、この型は第三のパラメタ<literal>x</literal>によっても添字付けされている。
      </para>

    <sect3 id="assoc-data-inst">
      <title>関連インスタンス</title>
      <para>関連データ族インスタンスや関連型シノニムインスタンスが型クラスインスタンスの中で宣言される場合、族インスタンスにおける<literal>instance</literal>キーワードは使わない。
<programlisting>
instance (GMapKey a, GMapKey b) => GMapKey (Either a b) where
  data GMap (Either a b) v = GMapEither (GMap a v) (GMap b v)
  ...

instance (Eq (Elem [e])) => Collects ([e]) where
  type Elem [e] = e
  ...
</programlisting>
関連族インスタンスに関して最も重要な点は、クラスパラメタに対応する型添字が、インスタンス頭部で与えられる型と同一でなければならないということである。この例ではこれは<literal>GMap</literal>の第一引数である<literal>Either a b</literal>であるが、これは(一つしかない)クラスパラメタと同じになっている。
</para>
      <para>関連族のインスタンスは、その族が宣言されたクラスのインスタンス宣言の一部としてしか現れることができない。これはクラスのメソッドの等式と同じである。また、これもメソッドの扱いと対応するが、クラスインスタンスにおいて関連型の宣言を省略することができる。関連族インスタンスが省略された場合、それに対応するインスタンス型は無内容(not inhabited)になる。すなわち、<literal>undefined</literal>などの発散する式のみがその型を持てる。</para>
      <para>珍しいことだが、単一のインスタンス宣言の中に、ある関連族のインスタンスが<emphasis>複数</emphasis>あってもよい。たとえば、次のものは合法である。
<programlisting>
instance GMapKey Flob where
  data GMap Flob [v] = G1 v
  data GMap Flob Int = G2 Int
  ...
</programlisting>
ここでは二つのデータインスタンス宣言を与えている。片方では最後のパラメタが<literal>[v]</literal>であり、もう片方では<literal>Int</literal>である。<emphasis>これ以降に</emphasis><literal>(GMap Flob ...)</literal>のインスタンスを与えることができないので、この機能は、自由な添字変数の種が(<literal>*</literal>とは違って)有限個の選択肢から成る場合に最も便利である。
      </para>
    </sect3>

    <sect3 id="assoc-decl-defs">
    <title>関連型シノニムのデフォルト</title>
      <para>関連型を定義するクラスは、関連型インスタンスのためにデフォルトを指定することができる。よってこれは問題ない。
<programlisting>
class IsBoolMap v where
  type Key v
  type Key v = Int

  lookupKey :: Key v -> v -> Maybe Bool

instance IsBoolMap [(Int, Bool)] where
  lookupKey = lookup
</programlisting>

重複部分がない限り、一つの型に複数のデフォルトがあっても良い。
<programlisting>
class C a where
  type F a b
  type F a Int  = Bool
  type F a Bool = Int
</programlisting>

関連<emphasis>データ</emphasis>型についてはデフォルト宣言は認められない。
      </para>
    </sect3>

    <sect3 id="scoping-class-params">
      <title>クラスパラメタのスコープ規則</title>
      <para>クラスパラメタが関連族インスタンスの右辺から可視かどうかは、そのデータ族のパラメタ<emphasis>のみ</emphasis>によって決まる。例として、次の単純なクラス宣言を考える。
<programlisting>
class C a b where
  data T a
</programlisting>
二つのクラスパラメタのうち一つだけがデータ族のパラメタになっている。このため、次のインスタンス宣言は不正である。
<programlisting>
instance C [c] d where
  data T [c] = MkT (c, d)    -- 間違ってるよ!!  「d」はスコープにない
</programlisting>
ここでは、データインスタンスの左辺に現れない型変数<literal>d</literal>が右辺で言及されている。このようなデータインスタンスを認めると型安全性を犠牲にすることになるので、これは認められていない。
      </para>
    </sect3>
  </sect2>

  <sect2 id="data-family-import-export">
    <title>インポートとエクスポート</title>

    <para>エクスポートリストのための規則(Haskell Reportの<ulink url="http://www.haskell.org/onlinereport/modules.html#sect5.2">5.2節</ulink>)は、型族を扱えるように調整する必要がある。
<itemizedlist>
<listitem><para><literal>T(..)</literal>という形、ただし<literal>T</literal>はデータ族。これは<literal>T</literal>と、<literal>T</literal>のデータインスタンスである構築子のうち(修飾形であれ非修飾形であれ)スコープにあるもの全てを指名する。
  </para></listitem>
<listitem><para>
<literal>T(.., ci, .., fj, ..)</literal>という形、ただし<literal>T</literal>はデータ族。これは通常と同様に、<literal>T</literal>と、指定された構築子<literal>ci</literal>およびフィールド<literal>fj</literal>を指名する。構築子とフィールドは<literal>T</literal>のデータインスタンスのいずれかに属していなければならないが、<emphasis>同じもの</emphasis>に属している必要はない。
  </para></listitem>
<listitem><para>
<literal>C(..)</literal>という形、ただし<literal>C</literal>はクラス。これは、クラス<literal>C</literal>と、そのメソッド全てと、<emphasis>その関連型</emphasis>を指名する。
  </para></listitem>
<listitem><para>
<literal>C(.., mi, .., type Tj, ..)</literal>という形、ただし<literal>C</literal>はクラス。これは、クラス<literal>C</literal>と、指定されたメソッド<literal>mi</literal>および関連型<literal>Tj</literal>を指名する。データ構築子と区別するために、型には「<literal>type</literal>」キーワードが必要である。
  </para></listitem>
</itemizedlist>
</para>

    <sect3 id="data-family-impexp-examples">
      <title>例</title>
      <para>ここまで使ってきた<literal>GMapKey</literal>クラスの例を思い出して欲しい。
<programlisting>
class GMapKey k where
  data GMap k :: * -> *
  insert :: GMap k v -> k -> v -> GMap k v
  lookup :: GMap k v -> k -> Maybe v
  empty  :: GMap k v

instance (GMapKey a, GMapKey b) => GMapKey (Either a b) where
  data GMap (Either a b) v = GMapEither (GMap a v) (GMap b v)
  ...method declarations...
</programlisting>
以下に、エクスポートリストいくつかと、その意味を記す。
	<itemizedlist>
	  <listitem>
	    <para><literal>module GMap( GMapKey )</literal>: クラス名のみをエクスポートする。</para>
	  </listitem>
	  <listitem>
	    <para><literal>module GMap( GMapKey(..) )</literal>: クラス、関連型<literal>GMap</literal>、メンバ関数<literal>empty</literal>、<literal>lookup</literal>、<literal>insert</literal>をエクスポートする。<literal>GMap</literal>のデータ構築子(この場合は<literal>GMapEither</literal>)はエクスポートされない。</para>
	  </listitem>
	  <listitem>
	    <para><literal>module GMap( GMapKey( type GMap, empty, lookup, insert ) )</literal>: 前項と同じ。「<literal>type</literal>」キーワードに注意。</para>
	  </listitem>
	  <listitem>
	    <para><literal>module GMap( GMapKey(..), GMap(..) )</literal>:
              前項と同じだが、<literal>GMap</literal>の全ての構築子、つまり<literal>GMapEither</literal>もエクスポートする。</para>
	  </listitem>
	  <listitem>
	    <para><literal>module GMap ( GMapKey( empty, lookup, insert), GMap(..) )</literal>:
              前項と同じ</para>
	  </listitem>
	  <listitem>
	    <para><literal>module GMap ( GMapKey, empty, lookup, insert, GMap(..) )</literal>:
              前項と同じ</para>
	  </listitem>
	</itemizedlist>
      </para>
      <para>
注意点を二つ。
  <itemizedlist>
      <listitem><para>
        <literal>GMapKey(type GMap(..))</literal>と書くことはできない。つまり、内容指定は入れ子にできない。<literal>GMap</literal>のデータ構築子を指定するなら、それを別に書かねばならない。
      </para></listitem>
      <listitem><para>
  次の例を考えよ
<programlisting>
  module X where
    data family D

  module Y where
    import X
    data instance D Int = D1 | D2
</programlisting>
    モジュールYは、Yで定義された全ての実体をエクスポートする。つまりデータ構築子<literal>D1</literal>および<literal>D2</literal>をエクスポートするが、<emphasis>データ型族<literal>D</literal>はエクスポートしない</emphasis>。これは(うっとおしいことに)「<literal>import Y( D(D1,D2) )</literal>」としてYを選択的にインポートすることができないこをと意味する。Yが<literal>D</literal>をエクスポートしていないからである。こうする代わりに、エクスポートリストを明示的に指定するべきである。次のように。
<programlisting>
        module Y( D(..) ) where ...
または  module Y( module Y, D ) where ...
</programlisting>
      </para></listitem>
  </itemizedlist>
</para>
</sect3>

    <sect3 id="data-family-impexp-instances">
      <title>インスタンス</title>
      <para>クラスインスタンスと同様に、族インスタンスは暗黙にインポートされる。ただし、これはインスタンスの頭部についてだけ適用される。インスタンスが定義するデータ構築子には適用されない。
      </para>
    </sect3>

  </sect2>

  <sect2 id="ty-fams-in-instances">
    <title>型族とインスタンス宣言</title>

    <para>型族のもとでは、インスタンス頭部の形式についての規則(<xref linkend="flexible-instance-head"/>で与えられている)を拡張する必要がある。特に、
<itemizedlist>
 <listitem><para>データ型族はインスタンス頭部に現れてもよい</para></listitem>
 <listitem><para>型シノニム族はインスタンス頭部に(全く)現われてはいけない</para></listitem>
</itemizedlist>
後者の制約があるのは、インスタンスが適合しているか検査する方法がないからである。次の例を考えよ。
<programlisting>
   type family F a
   type instance F Bool = Int

   class C a

   instance C Int
   instance C (F a)
</programlisting>
ここで、<literal>(C (F Bool))</literal>という制約は両方のインスタンスに適合する。<literal>F Bool</literal>の型インスタンスは別のモジュールにあるかもしれず、さらにはまだ書かれていないモジュールにあることさえあり得るので、この状況は特にまずい。
</para>
<para>
一方、データ族のインスタンスについての型クラスインスタンスは、通常のデータ型とほとんど同じに書ける。例えば次のように言うことができる。
<programlisting>
data instance T Int = T1 Int | T2 Bool
instance Eq (T Int) where
  (T1 i) == (T1 j) = i==j
  (T2 i) == (T2 j) = i==j
  _      == _      = False
</programlisting>クラスのインスタンスになるのは常にデータ族の特定の<emphasis>インスタンス</emphasis>であって、族全体ではないのに注意。これは要するに、一つの型族の<emphasis>異なる</emphasis>構築子に対してパターン照合を行う最上位関数を定義できないのと同じ理由による。これをするには拡張可能なcase構造が必要になるだろう。</para>
<para>データインスタンス宣言はまた、<literal>deriving</literal>節を持っていても良い。例えば次のように書くことができる。
<programlisting>
data GMap () v = GMapUnit (Maybe v)
               deriving Show
</programlisting>
これは次の形のインスタンスを暗黙に定義する。
<programlisting>
instance Show v => Show (GMap () v) where ...
</programlisting>
      </para>

</sect2>

</sect1>

<sect1 id="kind-polymorphism">
<title>種多相</title>

<para>
この節では、<emphasis>種多相性</emphasis>と、<option>-XPolyKinds</option>によって有効になる拡張について記述する。これはTLDI 2012に現れた論文<ulink url="http://dreixel.net/research/pdf/ghp.pdf">Giving Haskell a Promotion</ulink>により詳しく記述されている。
</para>

<sect2> <title>種多相の概観</title>

<para>
現在、Typeableの実装にはコードの重複が沢山ある(<xref linkend="deriving-typeable"/>)。
<programlisting>
class Typeable (t :: *) where
  typeOf :: t -> TypeRep

class Typeable1 (t :: * -> *) where
  typeOf1 :: t a -> TypeRep

class Typeable2 (t :: * -> * -> *) where
  typeOf2 :: t a b -> TypeRep
</programlisting>
</para>

<para>
種多相(<option>-XPolyKinds</option>で)は、これらのクラスを一つにまとめることを可能にする。
<programlisting>
data Proxy t = Proxy

class Typeable t where
  typeOf :: Proxy t -> TypeRep

instance Typeable Int  where typeOf _ = TypeRep
instance Typeable []   where typeOf _ = TypeRep
</programlisting>
データ型<literal>Proxy</literal>は<literal>forall k. k -> *</literal>という種を持っていることに注意(GHCによって推論される)。またこの新しい<literal>Typeable</literal>クラスの種は<literal>forall k. k -> Constraint</literal>である。
</para>

</sect2>

<sect2> <title>概観</title>
 
<para>一般的に言って、<option>-XPolyKinds</option>の下では、GHCは装飾のないものについて可能な限り多相的な種を推論する。例えば、

<programlisting>
data T m a = MkT (m a)
-- GHCが推論する種は T :: forall k. (k -> *) -> k -> *
</programlisting>
項の世界と同様に、シグネチャを使うことで多相性に制限を加えることができる
(<option>-XPolyKinds</option>は<option>-XKindSignatures</option>も有効にする)
<programlisting>
data T m (a :: *) = MkT (m a)
-- GHCが推論する種は T :: (* -> *) -> * -> * になる
</programlisting>
種変数についての"forall"はない。代わりに、種シグネチャでは単に種変数に言及することができる。次のように。
<programlisting>
data T (m :: k -> *) a = MkT (m a)
-- GHCが推論する種は T :: forall k. (k -> *) -> k -> * になる
</programlisting>
</para>
</sect2>

<sect2> <title>多相種再帰と完全な種シグネチャ</title>

<para>
型推論の場合と同様に、再帰的な型についての種推論は<emphasis>単相</emphasis>再帰しか扱えない。以下の(人為的な)例を考えよ。
<programlisting>
data T m a = MkT (m a) (T Maybe (m a))
-- GHCが推論する種は T :: (* -> *) -> * -> *
</programlisting>
<literal>T</literal>が再帰的に使われることによって、第二引数の種が<literal>*</literal>に固定されている。しかし、型推論の場合と同様に、<literal>T</literal>に<emphasis>完全な種シグネチャ</emphasis>を付けることで多相再帰を実現できる。データ型に完全な種シグネチャを与えるには、次のようにGADT様式の宣言を使い、明示的な種シグネチャを付ける。
<programlisting>
data T :: (k -> *) -> k -> * where
  MkT :: m a -> T Maybe (m a) -> T m a
</programlisting>
このユーザ指定の完全な種シグネチャが<literal>T</literal>について多相的な種を指定しており、再帰的なものを含めた<literal>T</literal>の呼び出し全てに利用される。特に、<literal>T</literal>の再帰呼び出しは種<literal>*</literal>においてである。
</para>

<para>
型構築子の「ユーザ指定の完全な種シグネチャ」とみなされるのは正確に何か？以下のものである。
 <itemizedlist>
<listitem><para>
ヘッダに明示的な「<literal>::</literal>」を含むGADT様式のデータ型宣言
 <programlisting>
data T1 :: (k -> *) -> k -> *       where ...   -- 可  T1 :: forall k. (k->*) -> k -> *
data T2 (a :: k -> *) :: k -> *     where ...   -- 可  T2 :: forall k. (k->*) -> k -> *
data T3 (a :: k -> *) (b :: k) :: * where ...   -- 可  T3 :: forall k. (k->*) -> k -> *
data T4 a (b :: k)             :: * where ...   -- 可  T4 :: forall k. * -> k -> *

data T5 a b                         where ...   -- 非  種は推論されない
data T4 (a :: k -> *) (b :: k)      where ...   -- 非  種は推論されない
</programlisting>
「<literal>::</literal>」を置くのはどこでもいいが、どこかには置かなければならない。Haskell98様式のデータ型宣言を使って完全な種シグネチャを与えることはできない。GADT構文を使う必要がある。
</para></listitem>
 
<listitem><para>
型族やデータ族宣言は、<emphasis>常に</emphasis>ユーザ指定の完全な種シグネチャを持つ。「<literal>::</literal>」は必要ない。
 <programlisting>
data family D1 a           	-- D1 :: * -> *
data family D2 (a :: k)    	-- D2 :: forall k. k -> *
data family D3 (a :: k) :: *    -- D3 :: forall k. k -> *
type family S1 a :: k -> *      -- S1 :: forall k. * -> k -> *
</programlisting>
</para></listitem>
 </itemizedlist>
ユーザ指定の完全な種シグネチャにおいて、「<literal>::</literal>」の左側の装飾のない型変数はすべて種「<literal>*</literal>」を持つとみなされる。種多相性が必要なら種変数を指定しなければならない。
 </para>

</sect2>
</sect1>

<sect1 id="promotion">
<title>データ型の昇格</title>

<para>
この節では<emphasis>データ型の昇格</emphasis>を記述する。これは、型多相性を補う型システムへの拡張である。これは<option>-XDataKinds</option>によって有効になり、TLDI 2012に現れた論文<ulink url="http://dreixel.net/research/pdf/ghp.pdf">Giving Haskell a Promotion</ulink>により詳しく記述されている。</para>

<sect2> <title>動機</title>

<para>
標準のHaskellには豊かな型言語が備わっている。型は式を分類し、多くのよくあるプログラミング上の間違いを避けるのに役立つ。一方で、Haskellの種言語(訳注: kind language; 型の型の言語)は比較的単純であり、持ち上げられた型(種<literal>*</literal>)と型構築子(たとえば種<literal>* -> * -> *</literal>)と持ち上げられていない型(<xref linkend="glasgow-unboxed"/>)を区別するのみである。特に型族(<xref linkend="type-families"/>)やGADT(<xref linkend="gadt"/>)などの高度な型システムの機能を使う場合、この単純な種システムでは不十分であり、単純な間違いを防ぐことができない。例として、型水準の自然数と、長さによって添字付けられたベクトルを考えよ。
<programlisting>
data Ze
data Su n

data Vec :: * -> * -> * where
  Nil  :: Vec a Ze
  Cons :: a -> Vec a n -> Vec a (Su n)
</programlisting>
<literal>Vec</literal>の種は<literal>* -> * -> *</literal>である。これば、例えば<literal>Vec Int Char</literal>が種の正しい型であることを意味する。長さによって添字付けられたベクトルを定義するときにこれを意図している訳ではないにもかかわらずである。
</para>

<para>
<option>-XDataKinds</option>を使うと、上の例は次のように書き直せる。
<programlisting>
data Nat = Ze | Su Nat

data Vec :: * -> Nat -> * where
  Nil  :: Vec a Ze
  Cons :: a -> Vec a n -> Vec a (Su n)
</programlisting>
この改善された<literal>Vec</literal>の種のもとでは、<literal>Vec Int Char</literal>のようなものは今や種が間違っており、GHCはエラーを報告するだろう。
</para>
</sect2>

<sect2><title>概観</title>
<para>
<option>-XDataKinds</option>を使うと、GHCは全ての適したデータ型を種へと昇格させ、その(値)構築子を型構築子へと昇格させる。以下の型は、
<programlisting>
data Nat = Ze | Su Nat

data List a = Nil | Cons a (List a)

data Pair a b = Pair a b
 
data Sum a b = L a | R b
</programlisting>
以下の種と型構築子を生み出す。
<programlisting>
Nat :: BOX
Ze :: Nat
Su :: Nat -> Nat

List k :: BOX
Nil  :: List k
Cons :: k -> List k -> List k

Pair k1 k2 :: BOX
Pair :: k1 -> k2 -> Pair k1 k2

Sum k1 k2 :: BOX
L :: k1 -> Sum k1 k2
R :: k2 -> Sum k1 k2
</programlisting>
ここで、<literal>BOX</literal>は種を分類する(唯一の)ソートである。例えば<literal>List</literal>が<literal>BOX -> BOX</literal>という種を得ないことに注意。種はそれ以上区別されないからである。全ての種は<literal>BOX</literal>というソートを持つ。
</para>

<para>
昇格には以下の制約が適用される。
<itemizedlist>
 <listitem><para>我々は<literal>* -> ... -> * -> *</literal>という形の種を持つデータ型しか昇格させない。特に、<literal>data Fix f = In (f (Fix f))</literal>のような高階の種を持つデータ型や、<literal>Vec :: * -> Nat -> *</literal>のように昇格後の型が関わっている種を持つデータ型を昇格させることはしない。</para></listitem>
 <listitem><para>構築子が種多相であったり、制約が関わっていたり、存在量化を使っていたりするデータ型は昇格させない。
 </para></listitem>
 <listitem><para>データ族インスタンス(<xref linkend="data-families"/>)は昇格させない。
 </para></listitem>
</itemizedlist>
</para>
</sect2>

<sect2 id="promotion-syntax">
<title>型と構築子の区別</title>
<para>
昇格があると、構築子と型が同じ名前空間を共有するので、型名が曖昧になることがある。
<programlisting>
data P          -- 1

data Prom = P   -- 2

type T = P      -- 1か、それとも昇格した2か？
</programlisting>
このような場合には、昇格した構築子に言及したい場合、名前に引用符を前置する必要がある。
<programlisting>
type T1 = P     -- 1

type T2 = 'P    -- 昇格した2
</programlisting>
昇格したデータ型は名前の付いた種を生み出すことに注意。これらが曖昧になることはないので、種名に引用符を付けることは認めていない。
</para>
<para>Template Haskell(<xref linkend="th-syntax"/>)の場合と同様に、二文字目が一重引用符であるようなデータ構築子や型構築子をクォートする方法はない。</para>
</sect2>

<sect2 id="promoted-lists-and-tuples">
<title>昇格したリスト型とタプル型</title>
<para>
Haskellのリストおよびタプル型は言語レベルで種へと昇格されており、引用符を前置する必要があるものの型水準でも同じ便利な記法が使える。
<programlisting>
data HList :: [*] -> * where
  HNil  :: HList '[]
  HCons :: a -> HList t -> HList (a ': t)

data Tuple :: (*,*) -> * where
  Tuple :: a -> b -> Tuple '(a,b)
</programlisting>
これは<option>-XTypeOperators</option>を必要とすることに注意。
</para>
</sect2>

<sect2 id="promoted-literals">
<title>昇格したリテラル</title>
<para>数値リテラルと文字列リテラルは型水準に昇格され、定義済みの大量の型水準の定数へのアクセスを容易にする。数値リテラルの種は<literal>Nat</literal>であり、文字列リテラルの種は<literal>Symbol</literal>である。これらの種は<literal>GHC.TypeLits</literal>モジュールで定義されている。
</para>

<para>
低水準の関数に安全なインタフェースを与えるために型水準の数値リテラルを使う例を示す。
<programlisting>
import GHC.TypeLits
import Data.Word
import Foreign

newtype ArrPtr (n :: Nat) a = ArrPtr (Ptr a)

clearPage :: ArrPtr 4096 Word8 -> IO ()
clearPage (ArrPtr p) = ...
</programlisting>
</para>

<para>
単純なレコード操作をシミュレートするために型水準の文字列リテラルを使う例を示す。
<programlisting>
data Label (l :: Symbol) = Get

class Has a l b | a l -> b where
  from :: a -> Label l -> b

data Point = Point Int Int deriving Show

instance Has Point "x" Int where from (Point x _) _ = x
instance Has Point "y" Int where from (Point _ y) _ = y

example = from (Point 1 2) (Get :: Label "x")
</programlisting>
</para>
</sect2>

</sect1>
<sect1 id="equality-constraints">
  <title>同値性制約</title>
  <para>型文脈には<literal>t1 ~ t2</literal>という形の同値性制約を含めることができる。これは、<literal>t1</literal>と<literal>t2</literal>の二つの型が同じでなければならないということを示す。型族の存在下では、一般に二つの型が等しいかどうかを局所的に決めることは出来ない。このため、次の例のように、関数のシグネチャの文脈に同値性制約が使われることがある。
<programlisting>
sumCollects :: (Collects c1, Collects c2, Elem c1 ~ Elem c2) => c1 -> c2 -> c2
</programlisting>
ここでは、<literal>c1</literal>と<literal>c2</literal>の要素の型が同じであることを要求している。一般に、同値性制約における<literal>t1</literal>と<literal>t2</literal>は任意の単相型であってよい。単相型であるというのは、ランクの高い型が有効になっているかどうかにかかわらず、量化子を含んでいてはならないということである。
  </para>
  <para>
同値性制約は、クラスとインスタンスの文脈でも使うことができる。前者によって、関数従属を使うプログラムから、代わりに族シノニムを使うプログラムへの、単純な翻訳が出来るようになる。一般的な考え方として、次のような形のクラス宣言があったとする。
<programlisting>
class C a b | a -> b
</programlisting>
これを、以下のように書き換える。
<programlisting>
class (F a ~ b) => C a b where
type F a
</programlisting>
つまり、すべての<literal>a1 .. an -> b</literal>という関数従属性(FD)について、これを<literal>F a1 .. an</literal>というFD型族と<literal>F a1 .. an ~ b</literal>というスーパークラス文脈の同値性で表現することで、実質的に関数従属性に名前を与えている。クラスインスタンスでは、FD族の型インスタンスをクラス頭部に沿った形で定義する。この過程でメソッドのシグネチャは影響を受けない。
  </para>
</sect1>

<sect1 id="constraint-kind">
<title><literal>Constraint</literal>という種</title>

<para>通常、<emphasis>制約</emphasis>(型中で<literal>=></literal>の左に出現するもの)の構文は極めて強く制限されている。次のものにしかなれない。
	<itemizedlist>
		<listitem>
			<para>クラス制約、たとえば<literal>Show a</literal></para>
		</listitem>
		<listitem>
			<para><link linkend="implicit-parameters">暗黙パラメタ</link>制約、たとえば<literal>?x::Int</literal> (<option>-XImplicitParams</option>フラグがあれば)</para>
		</listitem>
		<listitem>
			<para><link linkend="equality-constraints">等値制約</link>、たとえば<literal>a ~ Int</literal> (<option>-XTypeFamilies</option>または<option>-XGADTs</option>フラグがあれば)</para>
		</listitem>
	</itemizedlist>
</para>

<para><option>-XConstraintKinds</option>フラグを使うと、プログラム内で制約としてより幅広い範囲ものもを受け付けるようになる。正確にいうと、このフラグのもとでは新しい種<literal>Constraint</literal>を持つあらゆる<emphasis>型</emphasis>を制約として使える。以下のものが種<literal>Contraint</literal>を持つ。

	<itemizedlist>
		<listitem>このフラグなしでも制約として正しいもの全て。すなわち型クラスの完全な適用、暗黙パラメタ制約および等値制約。
		</listitem>
		<listitem>全ての要素が種<literal>Constraint</literal>を持つようなタプル。よって、たとえば型<literal>(Show a, Ord a)</literal>の種は<literal>Constraint</literal>になる。
		</listitem>
		<listitem>形はまだ分かっていないが、ユーザが種<literal>Constraint</literal>を持つとして宣言したもの全て。よって例えば<literal>type Foo (f :: * -> Constraint) = forall b. f b => b -> b</literal>は許される。また次の型族を使った例も許される。
<programlisting>
type family Typ a b :: Constraint
type instance Typ Int  b = Show b
type instance Typ Bool b = Num b

func :: Typ a b => a -> b -> b
func = ...
</programlisting>
		</listitem>
	</itemizedlist>
</para>

<para>制約は特定の種を持った単なる型として扱われるので、この拡張によって制約シノニムが可能になる。
</para>

<programlisting>
type Stringy a = (Read a, Show a)
foo :: Stringy a => a -> (String, String -> a)
foo x = (show x, read)
</programlisting>

<para>現在、標準的な制約とタプルおよびこれら二種類の制約のシノニムのみがインスタンス文脈とスーパークラス文脈で(別のフラグなしで)使用できる。この理由は、もっと一般的な制約を許すと型検査のループを引き起し得るからである。以下の二つのプログラムはそのような例である。
</para>

<programlisting>
type family Clsish u a
type instance Clsish () a = Cls a
class Clsish () a => Cls a where
</programlisting>

<programlisting>
class OkCls a where

type family OkClsish u a
type instance OkClsish () a = OkCls a
instance OkClsish () a => OkCls a where
</programlisting>

<para>インスタンス文脈やスーパークラスに変わった種類の制約を使うプログラムを書くことはできるが、それには<option>-XUndecidableInstances</option>を使って、型検査器が終了しなくても気にしないことを示す必要がある。</para>

</sect1>

<sect1 id="other-type-extensions">
<title>型システムへのその他の拡張</title>

<sect2 id="explicit-foralls"><title>明示的な全称量化(forall)</title>
<para>
Haskellの型シグネチャは暗黙に量化される。言語オプション<option>-XExplicitForAll</option>が使われている場合、これが正確にどういう意味なのかを<literal>forall</literal>キーワードを使って言うことができる。例えば、
</para>
<para>
<programlisting>
        g :: b -> b
</programlisting>
は、次のものを意味している。
<programlisting>
        g :: forall b. (b -> b)
</programlisting>
この二つは同じものとして扱われる。
</para>
<para>
もちろん、<literal>forall</literal>はキーワードになる。型変数として<literal>forall</literal>を使うことはもはやできないのである。
</para>
</sect2>

<sect2 id="flexible-contexts"><title>型シグネチャの文脈</title>
<para>
<option>-XFlexibleContexts</option>フラグを使うと、型シグネチャ中の型クラス制約が<emphasis>(class type-variable)</emphasis>または<emphasis>(class (type-variable type-variable ...))</emphasis>という形でなければならないという、Haskell 98の制限を撤廃する。<option>-XFlexibleContexts</option>が有効な場合、以下のような型シグネチャは完全に正しい。
<programlisting>
  g :: Eq [a] => ...
  g :: Ord (T a ()) => ...
</programlisting>
<option>-XFlexibleContexts</option>フラグは、クラス宣言(<xref linkend="superclass-rules"/>)およびインスタンス宣言(<xref linkend="instance-rules"/>)における同様の制約も撤廃する。
</para>

<para>
GHCは、型シグネチャに関して以下の制限を課す。次の型を考える。

<programlisting>
  forall tv1..tvn (c1, ...,cn) => type
</programlisting>

(ここでは「forall」を明示的に書いたが、Haskellソース言語では省略される。Haskell 98では、ソース言語中の明示的な型シグネチャにおける型変数は全て全称量化される(クラス宣言中のクラス型変数の場合を除く)。ただし、GHCでは、望むならforallを与えても良い。<xref linkend="explicit-foralls"/>を見よ)
</para>

<para>

<orderedlist>
<listitem>

<para>
 <emphasis>全ての全称量化された型変数<literal>tvi</literal>は<literal>type</literal>から到達可能でなければならない</emphasis>。型変数<literal>a</literal>が「到達可能」なのは、<literal>type</literal>に現れる型変数または別の到達可能な型変数と、その型変数が、同じ制約の中に現れるときである。この到達可能性制限に従わない型を持つ値は、曖昧性を導入することなく使うことができない。これがこういう型が禁止される理由である。例えば、以下の型は許されない。


<programlisting>
  forall a. Eq a => Int
</programlisting>


この型の値が使われるとき、<literal>tv</literal>を新しい型変数として、<literal>Eq tv</literal>という制約が導入され、(辞書渡し実装では)この値が<literal>Eq tv</literal>の辞書に適用される。問題は、<literal>tv</literal>についてこれ以上情報を得ることができないため、どの<literal>Eq</literal>のインスタンスを使うべきか決して知ることがきないということである。
</para>
<para>
この到達可能条件は「<literal>a</literal>が<literal>type</literal>中の型変数に関数従属している(<xref linkend="functional-dependencies"/>を見よ)」という条件よりも弱いことに注意。これは、場合によっては、スーパークラスに「隠された」従属性があり得るからである。従って、到達可能性は関数従属性に対する保守的な近似である。例えば、以下の例を考えてみよう。
<programlisting>
  class C a b | a -> b where ...
  class C a b => D a b where ...
  f :: forall a b. D a b => a -> a
</programlisting>
これは問題ない。実際、<literal>a</literal>は関数的に<literal>b</literal>を決定する。しかし、このことは<literal>f</literal>の型だけからは明らかでない。
</para>
</listitem>
<listitem>

<para>
 <emphasis>制約<literal>ci</literal>は全て、少なくとも一つの全称量化された型変数<literal>tvi</literal>に言及せねばならない</emphasis>。例えば、以下の型は、<literal>C a b</literal>が、全称量化された型変数<literal>b</literal>に言及しているので問題ない。


<programlisting>
  forall a. C a b => burble
</programlisting>


次に示す型は、制約<literal>Eq b</literal>が<literal>a</literal>に言及していないので不正である。


<programlisting>
  forall a. Eq b => burble
</programlisting>

この制限がある理由は、上のものほど深刻ではない。この制限によって排除されるのは、有用でも必要でもない型だけである。(この制約に反する文脈は、その位置にある必要がなく、より外側に移動させることができるからである)。さらに、これらを外側に移すことで共有が促進される。最後に、これを除外するというのは保守的な選択であり、後で必要になるかもしれない領域を取っておくことになる。

</para>
</listitem>

</orderedlist>

</para>

</sect2>

<sect2 id="implicit-parameters">
<title>暗黙パラメタ</title>

<para>
暗黙パラメタは、"Implicit parameters: dynamic scoping with static types", J Lewis, MB Shields, E Meijer, J Launchbury, 27th ACM Symposium on Principles of Programming Languages (POPL'00), Boston, Jan 2000に述べられている通りに実装されている。
</para>

<para>(以下の文書(まだかなり不完全だが)はJeff Lweisによる)</para>

<para>暗黙パラメタのサポートは<option>-XImplicitParams</option>オプションで有効になる。</para>

<para>
変数は、それが関数の呼び出し元の文脈によって束縛されているとき<emphasis>動的に束縛されている</emphasis>と言い、呼ばれた関数の文脈によって束縛されているとき<emphasis>静的に束縛されている</emphasis>と言う。Haskellでは全ての変数が静的に束縛される。変数の動的束縛の概念はLispにまで遡るが、Schemeのような現代的な現れにおいては捨てられることとなった。動的束縛は型のない言語においては非常に混乱的であるし、残念なことに、型のある言語においてもそうである。特に、HaskellのようにHindley-Milterの型システムの付けられた言語は、変数について静的スコープしか認めない。
</para>
<para>
ところが、Haskellの型クラスの構造に単純な拡張を施すことで、動的束縛を手に入れることができる。基本的には、動的に束縛された変数を使うということを、型への制約として表現するのである。このような制約を使うと、型は<literal>(?x::t') => t</literal>という形になるが、これは「この関数は動的に束縛された型<literal>t'</literal>の変数<literal>?x</literal>を使っている」という意味である。例えば、以下に示すのは、<literal>cmp</literal>という名前の比較関数で暗黙にパラメタ化されたソート関数の型である。
<programlisting>
  sort :: (?cmp :: a -> a -> Bool) => [a] -> [a]
</programlisting>
動的束縛制約は、型クラス機構に追加された、一つの新しい形の述語に過ぎない。
</para>
<para>
暗黙パラメタは<literal>?x</literal>という特殊形式を使った式に現れる。ここで<literal>x</literal>は有効な識別子である。(例えば、<literal>ord ?x</literal>は正しい式である)。この要素を使うことで、式の型も影響され、新しい動的束縛制約が導入される。例えば、以下では、明示的にパラメタ化された<literal>sortBy</literal>関数を基にして暗黙にパラメタ化されたソート関数を定義している。
<programlisting>
  sortBy :: (a -> a -> Bool) -> [a] -> [a]

  sort   :: (?cmp :: a -> a -> Bool) => [a] -> [a]
  sort    = sortBy ?cmp
</programlisting>
</para>

<sect3>
<title>暗黙パラメタ型制約</title>
<para>
動的束縛制約は自動的に伝播される。この点で、型クラス制約と同じ振る舞いである。つまり、ある関数が使われるとき、その関数の暗黙パラメタはその関数を呼んだ関数に受け継がれる。例えば、上記の<literal>sort</literal>関数は、リストの最小要素を得るのに使うことができる。
<programlisting>
  least   :: (?cmp :: a -> a -> Bool) => [a] -> a
  least xs = head (sort xs)
</programlisting>
特に何もしなくても、<literal>?cmp</literal>パラメタは伝播され、<literal>least</literal>のパラメタにもなっている。明示的なパラメタでは、パラメタを明示的に受け渡さなければならないのがデフォルトであるのに対し、暗黙パラメタでは、常に伝播するのがデフォルトである。
</para>
<para>
暗黙パラメタ型制約と通常のクラス制約の違いは以下の通りである。特定の暗黙パラメタは、何回使われようと、同じ型を持っていなければならない。つまり、<literal>(?x, ?x)</literal>の型は<literal>(?x::a) => (a, a)</literal>であり、クラス制約の場合のように<literal>(?x::a, ?x::b) => (a, b)</literal>となることはない。
</para>

<para>クラス宣言やインスタンス宣言の文脈で暗黙パラメタを使うことはできない。例えば、以下の宣言はどちらも不正である。
<programlisting>
  class (?x::Int) => C a where ...
  instance (?x::a) => Foo [a] where ...
</programlisting>
理由: 暗黙パラメタとしてどれを選ぶかはどこで関数を呼ぶかに依存する。しかし、インスタンス宣言を「呼ぶ」のはコンパイラによって裏で行われることであり、それがどこで行われているか正確なことを決めるのは難しい。最も簡単なのは、これに違反する型を非合法化することである。</para>
<para>
暗黙パラメタ制約は曖昧性を引き起こさない。以下の例を考えてみよう。
<programlisting>
   f :: (?x :: [a]) => Int -> Int
   f n = n + length ?x

   g :: (Read a, Show a) => String -> String
   g s = show (read s)
</programlisting>
ここで、<literal>g</literal>の型は曖昧であり、受け付けられない。一方、<literal>f</literal>は問題ない。<literal>f</literal>の呼び出し地点での<literal>?x</literal>の束縛は全く曖昧でなく、<literal>a</literal>の型を固定する。
</para>
</sect3>

<sect3>
<title>暗黙パラメタの束縛</title>

<para>
暗黙パラメタは通常の<literal>let</literal>や<literal>where</literal>束縛形式を使って<emphasis>束縛する</emphasis>ことができる。例として、<literal>cmp</literal>を束縛することで<literal>min</literal>関数を定義する。
<programlisting>
  min :: [a] -> a
  min  = let ?cmp = (&lt;=) in least
</programlisting>
</para>
<para>
暗黙パラメタの束縛グループは、通常のHaskellの束縛グループが出現できるところなら、最上位を除いてどこに現れても良い。つまり、<literal>let</literal>(リスト内包表記、do記法、パターンガード中のものも含む)または<literal>where</literal>節に現れることができる。以下のことに注意。
<itemizedlist>
<listitem><para>
暗黙パラメタの束縛グループは暗黙形式の変数への単純束縛の集まり(関数形式は禁止。型シグネチャも禁止)でなければならない。これらの束縛は多相的であってはならず、再帰的であってもならない。
</para></listitem>
<listitem><para>
一つの<literal>let</literal>式に暗黙パラメタ束縛と通常の束縛を混ぜることはできない。代わりに入れ子になった<literal>let</literal>を使うこと。(<literal>where</literal>の場合はどうしようもない。<literal>where</literal>節を入れ子にすることはできないので)
</para></listitem>

<listitem><para>
単一の束縛グループに複数の暗黙パラメタ束縛を配置することは可能だが、それらは(通常の<literal>let</literal>束縛のような)相互再帰的なグループとはみなされない。それらは、非再帰的なグループで、全ての暗黙引数を同時に束縛するものとして扱われる。束縛は入れ子になっておらず、順番を入れ替えてもプログラムの意味は変わらない。例として以下の例を考えよ。
<programlisting>
  f t = let { ?x = t; ?y = ?x+(1::Int) } in ?x + ?y
</programlisting>
<literal>?y</literal>の束縛中で<literal>?x</literal>が使われているが、直前の<literal>?x</literal>の束縛はそこからは「見え」ないので、<literal>f</literal>の型は以下のようになる。
<programlisting>
  f :: (?x::Int) => Int -> Int
</programlisting>
</para></listitem>
</itemizedlist>
</para>

</sect3>

<sect3><title>暗黙パラメタと多相再帰</title>

<para>
次の二つの定義を考えてみよう。
<programlisting>
  len1 :: [a] -> Int
  len1 xs = let ?acc = 0 in len_acc1 xs

  len_acc1 [] = ?acc
  len_acc1 (x:xs) = let ?acc = ?acc + (1::Int) in len_acc1 xs

  ------------

  len2 :: [a] -> Int
  len2 xs = let ?acc = 0 in len_acc2 xs

  len_acc2 :: (?acc :: Int) => [a] -> Int
  len_acc2 [] = ?acc
  len_acc2 (x:xs) = let ?acc = ?acc + (1::Int) in len_acc2 xs
</programlisting>
この二つのグループの違いは、二番目のグループでは<literal>len_acc</literal>に型シグネチャが与えられているという点だけである。前者では、<literal>len_acc1</literal>はその右辺について単相的であり、再帰呼び出しでは暗黙パラメタ<literal>?acc</literal>が渡されない。後者では、<literal>len_acc2</literal>に型シグネチャがあるので、再帰呼び出しは<emphasis>多相的</emphasis>になり、<literal>?acc</literal>を暗黙パラメタとして取る。よって、GHCiで試してみると、以下の結果が得られる。
<programlisting>
  Prog> len1 "hello"
  0
  Prog> len2 "hello"
  5
</programlisting>
型シグネチャを追加することで結果が劇的に変わってしまった。これはかなり直観に反する現象であり、注意するに値する。
</para>
</sect3>

<sect3><title>暗黙パラメタと単相性</title>

<para>GHCは、例の恐るべき単相性限定(Haskellレポートの4.5.5節)を暗黙パラメタにも適用する。例として以下を考えよう。
<programlisting>
 f :: Int -> Int
  f v = let ?x = 0     in
        let y = ?x + v in
        let ?x = 5     in
        y
</programlisting>
<literal>y</literal>の束縛は単相性限定の適用下にあり、一般化されないので、<literal>y</literal>の型は単なる<literal>Int</literal>であり、<literal>(?x::Int) => Int</literal>ではない。従って、<literal>(f 9)</literal>は結果<literal>9</literal>を返す。<literal>y</literal>に型シグネチャを追加すると、<literal>y</literal>の型は<literal>(?x::Int) => Int</literal>になり、<literal>let</literal>の本体における<literal>y</literal>の出現は内側の<literal>?x</literal>の束縛を見ることになるので、<literal>(f 9)</literal>は<literal>14</literal>を返す。
</para>
</sect3>
</sect2>

    <!--   ======================= COMMENTED OUT ========================

    We intend to remove linear implicit parameters, so I'm at least removing
    them from the 6.6 user manual

<sect2 id="linear-implicit-parameters">
<title>Linear implicit parameters</title>
<para>
Linear implicit parameters are an idea developed by Koen Claessen,
Mark Shields, and Simon PJ.  They address the long-standing
problem that monads seem over-kill for certain sorts of problem, notably:
</para>
<itemizedlist>
<listitem> <para> distributing a supply of unique names </para> </listitem>
<listitem> <para> distributing a supply of random numbers </para> </listitem>
<listitem> <para> distributing an oracle (as in QuickCheck) </para> </listitem>
</itemizedlist>

<para>
Linear implicit parameters are just like ordinary implicit parameters,
except that they are "linear"; that is, they cannot be copied, and
must be explicitly "split" instead.  Linear implicit parameters are
written '<literal>%x</literal>' instead of '<literal>?x</literal>'.
(The '/' in the '%' suggests the split!)
</para>
<para>
For example:
<programlisting>
    import GHC.Exts( Splittable )

    data NameSupply = ...

    splitNS :: NameSupply -> (NameSupply, NameSupply)
    newName :: NameSupply -> Name

    instance Splittable NameSupply where
	split = splitNS


    f :: (%ns :: NameSupply) => Env -> Expr -> Expr
    f env (Lam x e) = Lam x' (f env e)
		    where
		      x'   = newName %ns
		      env' = extend env x x'
    ...more equations for f...
</programlisting>
Notice that the implicit parameter %ns is consumed
<itemizedlist>
<listitem> <para> once by the call to <literal>newName</literal> </para> </listitem>
<listitem> <para> once by the recursive call to <literal>f</literal> </para></listitem>
</itemizedlist>
</para>
<para>
So the translation done by the type checker makes
the parameter explicit:
<programlisting>
    f :: NameSupply -> Env -> Expr -> Expr
    f ns env (Lam x e) = Lam x' (f ns1 env e)
		       where
	 		 (ns1,ns2) = splitNS ns
			 x' = newName ns2
			 env = extend env x x'
</programlisting>
Notice the call to 'split' introduced by the type checker.
How did it know to use 'splitNS'?  Because what it really did
was to introduce a call to the overloaded function 'split',
defined by the class <literal>Splittable</literal>:
<programlisting>
	class Splittable a where
	  split :: a -> (a,a)
</programlisting>
The instance for <literal>Splittable NameSupply</literal> tells GHC how to implement
split for name supplies.  But we can simply write
<programlisting>
	g x = (x, %ns, %ns)
</programlisting>
and GHC will infer
<programlisting>
	g :: (Splittable a, %ns :: a) => b -> (b,a,a)
</programlisting>
The <literal>Splittable</literal> class is built into GHC.  It's exported by module
<literal>GHC.Exts</literal>.
</para>
<para>
Other points:
<itemizedlist>
<listitem> <para> '<literal>?x</literal>' and '<literal>%x</literal>'
are entirely distinct implicit parameters: you
  can use them together and they won't intefere with each other. </para>
</listitem>

<listitem> <para> You can bind linear implicit parameters in 'with' clauses. </para> </listitem>

<listitem> <para>You cannot have implicit parameters (whether linear or not)
  in the context of a class or instance declaration. </para></listitem>
</itemizedlist>
</para>

<sect3><title>Warnings</title>

<para>
The monomorphism restriction is even more important than usual.
Consider the example above:
<programlisting>
    f :: (%ns :: NameSupply) => Env -> Expr -> Expr
    f env (Lam x e) = Lam x' (f env e)
		    where
		      x'   = newName %ns
		      env' = extend env x x'
</programlisting>
If we replaced the two occurrences of x' by (newName %ns), which is
usually a harmless thing to do, we get:
<programlisting>
    f :: (%ns :: NameSupply) => Env -> Expr -> Expr
    f env (Lam x e) = Lam (newName %ns) (f env e)
		    where
		      env' = extend env x (newName %ns)
</programlisting>
But now the name supply is consumed in <emphasis>three</emphasis> places
(the two calls to newName,and the recursive call to f), so
the result is utterly different.  Urk!  We don't even have
the beta rule.
</para>
<para>
Well, this is an experimental change.  With implicit
parameters we have already lost beta reduction anyway, and
(as John Launchbury puts it) we can't sensibly reason about
Haskell programs without knowing their typing.
</para>

</sect3>

<sect3><title>Recursive functions</title>
<para>Linear implicit parameters can be particularly tricky when you have a recursive function
Consider
<programlisting>
        foo :: %x::T => Int -> [Int]
        foo 0 = []
        foo n = %x : foo (n-1)
</programlisting>
where T is some type in class Splittable.</para>
<para>
Do you get a list of all the same T's or all different T's
(assuming that split gives two distinct T's back)?
</para><para>
If you supply the type signature, taking advantage of polymorphic
recursion, you get what you'd probably expect.  Here's the
translated term, where the implicit param is made explicit:
<programlisting>
        foo x 0 = []
        foo x n = let (x1,x2) = split x
                  in x1 : foo x2 (n-1)
</programlisting>
But if you don't supply a type signature, GHC uses the Hindley
Milner trick of using a single monomorphic instance of the function
for the recursive calls. That is what makes Hindley Milner type inference
work.  So the translation becomes
<programlisting>
        foo x = let
                  foom 0 = []
                  foom n = x : foom (n-1)
                in
                foom
</programlisting>
Result: 'x' is not split, and you get a list of identical T's.  So the
semantics of the program depends on whether or not foo has a type signature.
Yikes!
</para><para>
You may say that this is a good reason to dislike linear implicit parameters
and you'd be right.  That is why they are an experimental feature.
</para>
</sect3>

</sect2>

================ END OF Linear Implicit Parameters commented out -->

<sect2 id="kinding">
<title>明示的に種付けされた量化</title>

<para>
Haskellでは全ての型変数の種は推論される。(機械で検査できる)文書化のために、種を明示的に与えるのが良いことがある。これは関数に型シグネチャを与えると良いのと同様である。場合によっては、これが本質的に必要になることもある。例えば、John Hughesは、彼の論文"Restricted Data Types in Haskell" (Haskell Workshop 1999)のなかで、次のようにデータ型を定義しなければならなかった。
<screen>
     data Set cxt a = Set [a]
                    | Unused (cxt a -> ())
</screen>
構築子<literal>Unused</literal>は、型変数<literal>cxt</literal>が正しい種を与えられるようにするためだけに存在する。
</para>
<para>
GHCでは、このようなことをしなくても、<option>-XKindSignatures</option>を使えば、型変数が明示的に束縛されるときはいつでも、その型変数の種を直接指定できるようになった。</para>
<para>
このフラグによって、以下の場所で種シグネチャを使えるようになる。
<itemizedlist>
<listitem><para><literal>data</literal>宣言。
<screen>
  data Set (cxt :: * -> *) a = Set [a]
</screen></para></listitem>
<listitem><para><literal>type</literal>宣言。
<screen>
  type T (f :: * -> *) = f Int
</screen></para></listitem>
<listitem><para><literal>class</literal>宣言。
<screen>
  class (Eq a) => C (f :: * -> *) a where ...
</screen></para></listitem>
<listitem><para>型シグネチャ中の<literal>forall</literal>。
<screen>
  f :: forall (cxt :: * -> *). Set cxt Int
</screen></para></listitem>
</itemizedlist>
</para>

<para>
括弧は必須である。いくつかのスペースも、字句要素を分離するために必要である。<literal>(f::*->*)</literal>と書いたとすると、「<literal>::*->*</literal>」はHaskellでは一つの字句要素なので、パースエラーになる。
</para>

<para>
この拡張の一部として、型に種注釈を加えることもできる。
<screen>
   f :: (Int :: *) -> Int
   g :: forall a. a -> (a :: *)
</screen>
構文は以下のとおり。
<screen>
   atype ::= '(' ctype '::' kind ')
</screen>
括弧は必須である。
</para>
</sect2>


<sect2 id="universal-quantification">
<title>任意ランク多相
</title>

<para>
GHCの型システムでは、型に対して<emphasis>任意ランク</emphasis>の明示的な量化が認められる。例えば、以下の例は全て合法である。
<programlisting>
    f1 :: forall a b. a -> b -> a
    g1 :: forall a b. (Ord a, Eq  b) => a -> b -> a

    f2 :: (forall a. a->a) -> Int -> Int
    g2 :: (forall a. Eq a => [a] -> a -> Bool) -> Int -> Int

    f3 :: ((forall a. a->a) -> Int) -> Bool -> Bool

    f4 :: Int -> (forall a. a -> a)
</programlisting>
ここで、<literal>f1</literal>と<literal>g1</literal>はランク1の型で、標準のHaskellで書くことができる。(例えば、<literal>f1 :: a->b->a</literal>)。これらの<literal>forall</literal>は、Haskellが暗黙に加える全称量化を明示的なものにしている。
</para>
<para>
関数<literal>f2</literal>と<literal>g2</literal>の型はランク2である。<literal>forall</literal>が関数矢印の左にあるからである。<literal>g2</literal>を見れば分かるとおり、関数矢印の左の多相型は多重定義されていても良い。
</para>
<para>
関数<literal>f3</literal>はランク3の型を持っている。関数矢印の左にランク2の型があるからである。
</para>
<para>
GHCには、ランクの高い型を制御するための三つのフラグがある。
<itemizedlist>
<listitem><para>
 <option>-XPolymorphicComponents</option>: データ構築子(だけ)が、多相的な引数の型を持てる。
</para></listitem>
<listitem><para>
 <option>-XRank2Types</option>: あらゆる関数(データ構築子を含む)が、ランク2の型を持てる。
</para></listitem>
<listitem><para>
 <option>-XRankNTypes</option>: あらゆる関数(データ構築子を含む)が、任意のランクの型を持てる。つまり、関数矢印に必要なだけ深く<literal>forall</literal>を入れ子にすることができる。特に、forallの付いた型(「型スキーム」とも呼ばれる)は、<!-- 訳注: including operational type class context -->型クラス文脈も含めて、以下の場所で使える。
<itemizedlist>
<listitem> <para>関数矢印の左側または右側(例えば<literal>f4</literal>を見よ)</para> </listitem>
<listitem> <para>データ型宣言で、構築子の引数として、またはフィールドの型として。例えば、上記の<literal>f1,f2,f3,g1,g2</literal>はどれも、フィールドの型シグネチャとして合法である。</para> </listitem>
<listitem> <para>暗黙パラメタの型として</para> </listitem>
<listitem> <para>パターン型シグネチャ(<xref linkend="scoped-type-variables"/>を見よ)の中 </para> </listitem>
</itemizedlist>
</para></listitem>
</itemizedlist>
</para>


<sect3 id="univ">
<title>例
</title>

<para>
<literal>data</literal>宣言や<literal>newtype</literal>宣言において、構築子の引数の型を量化することができる。いくつか例を挙げる。
</para>

<para>

<programlisting>
data T a = T1 (forall b. b -> b -> b) a

data MonadT m = MkMonad { return :: forall a. a -> m a,
                          bind   :: forall a b. m a -> (a -> m b) -> m b
                        }

newtype Swizzle = MkSwizzle (Ord a => [a] -> [a])
</programlisting>

</para>

<para>
これらの構築子は、以下のように、ランク2の型を持つ。
</para>

<para>

<programlisting>
T1 :: forall a. (forall b. b -> b -> b) -> a -> T a
MkMonad :: forall m. (forall a. a -> m a)
                  -> (forall a b. m a -> (a -> m b) -> m b)
                  -> MonadT m
MkSwizzle :: (Ord a => [a] -> [a]) -> Swizzle
</programlisting>

</para>

<para>
明示的な文脈があるなら<literal>forall</literal>を使う必要はないということに注意。例えば、構築子<function>MkSwizzle</function>の第一引数について、引数の型には暗黙に「<literal>forall a.</literal>」が付いているとみなされる。このような暗黙の<literal>forall</literal>は、問題の型に言及されているもののスコープにない型変数全てを量化する。
</para>

<para>
型シグネチャと同様に、多重定義されていない型についても暗黙の量化は発生する。次のように書いたとする。

<programlisting>
  data T a = MkT (Either a b) (b -> b)
</programlisting>

これは、次のように書いたのと同じである。

<programlisting>
  data T a = MkT (forall b. Either a b) (forall b. b -> b)
</programlisting>

つまり、型変数<literal>b</literal>はスコープにないので、暗黙に全称量化される。(もしかしたら、必要な場合には構築子引数についての明示的な量化を<emphasis>必須</emphasis>にした方が良いのかもしれない。フィードバック歓迎)
</para>

<para>
型<literal>T1, MonadT, Swizzle</literal>の値を構築するには、通常と同じように、構築子を適切な値に適用すれば良い。例を示す。
</para>

<para>

<programlisting>
    a1 :: T Int
    a1 = T1 (\xy->x) 3

    a2, a3 :: Swizzle
    a2 = MkSwizzle sort
    a3 = MkSwizzle reverse

    a4 :: MonadT Maybe
    a4 = let r x = Just x
	     b m k = case m of
		       Just y -> k y
		       Nothing -> Nothing
         in
         MkMonad r b

    mkTs :: (forall b. b -> b -> b) -> a -> [T a]
    mkTs f x y = [T1 f x, T1 f y]
</programlisting>

</para>

<para>
<literal>(MkSwizze reverse)</literal>の例から分かるように、構築子の引数は、通常と同じく、必要以上に一般的な型をもっていても良い。(<function>reverse</function>は<literal>Ord</literal>制約を必要としない)
</para>

<para>
パターン照合を使うとき、束縛される変数が多相型を持つことがあり得る。例を示す。
</para>

<para>

<programlisting>
    f :: T a -> a -> (a, Char)
    f (T1 w k) x = (w k x, w 'c' 'd')

    g :: (Ord a, Ord b) => Swizzle -> [a] -> (a -> b) -> [b]
    g (MkSwizzle s) xs f = s (map f (s xs))

    h :: MonadT m -> [m a] -> m [a]
    h m [] = return m []
    h m (x:xs) = bind m x          $ \y ->
                 bind m (h m xs)   $ \ys ->
                 return m (y:ys)
</programlisting>

</para>

<para>
関数<function>h</function>では、<literal>MonadT</literal>データ構造から多相的なbindとreturn関数を抽出するのに、パターン照合ではなく、レコード選択関数である<literal>return</literal>と<literal>bind</literal>を使っている。
</para>
</sect3>

<sect3>
<title>型推論</title>

<para>
一般に、任意ランクの型に対する型推論は決定不能である。GHCでは、OderskyとLauferによって提案されたアルゴリズム("Putting type annotations to work", POPL'96)を使って、プログラマの助けを当てにすることでアルゴリズムを決定可能にしている。「プログラマの助け」についての形式的な仕様はまだないが、規則はこうである。
</para>
<para>
<emphasis>ラムダ束縛された、あるいはcase束縛された変数xについて、プログラマがxに多相的な型を明示的に与えない限り、GHCの型推論は、xの型にforallが含まれないとみなす</emphasis>。
</para>
<para>
xに明示的な型を「与える」とはどういう意味か。まず、xに直接型シグネチャを与えることができる。これにはパターン型シグネチャ(<xref linkend="scoped-type-variables"/>を見よ)を使う。
<programlisting>
     \ f :: (forall a. a->a) -> (f True, f 'c')
</programlisting>
別の方法として、これを取り巻く文脈に型シグネチャを与えることもできる。GHCはこれを「押し進め」て、その変数の型を知ることができる。
<programlisting>
     (\ f -> (f True, f 'c')) :: (forall a. a->a) -> (Bool,Char)
</programlisting>
この例では、式の型シグネチャを内側に押し進めることで、fの型シグネチャを得ることができる。同様に、(こちらの方が良く使われるが)関数自体に型シグネチャを与えても良い。
<programlisting>
     h :: (forall a. a->a) -> (Bool,Char)
     h f = (f True, f 'c')
</programlisting>
ラムダ束縛された変数が構築子の引数なら型シグネチャは必要ない。以下は既に見た例である。
<programlisting>
    f :: T a -> a -> (a, Char)
    f (T1 w k) x = (w k x, w 'c' 'd')
</programlisting>
ここで<literal>w</literal>に型シグネチャを与える必要はない。これは構築子<literal>T1</literal>の引数であり、必要なことは全てこのことから分かる。
</para>

</sect3>


<sect3 id="implicit-quant">
<title>暗黙の量化</title>

<para>
GHCが暗黙の量化を行う手順は次のとおり。<emphasis>ユーザが書いた型の最上位(のみ)において、明示的な<literal>forall</literal>がないなら、またその時に限り、その型で言及されているもののスコープにない型変数を調べ上げ、それらを全称量化する。</emphasis>例えば、以下の組は互いに同等である。
<programlisting>
  f :: a -> a
  f :: forall a. a -> a

  g (x::a) = let
                h :: a -> b -> b
                h x y = y
             in ...
  g (x::a) = let
                h :: forall b. a -> b -> b
                h x y = y
             in ...
</programlisting>
</para>
<para>
GHCは、可能な最も内側の量化点を探したり<emphasis>しない</emphasis>ことに注意。例を示す。
<programlisting>
  f :: (a -> a) -> Int
           -- は
  f :: forall a. (a -> a) -> Int
           -- のことであり
  f :: (forall a. a -> a) -> Int
           -- ではない


  g :: (Ord a => a -> a) -> Int
           -- は
  g :: forall a. (Ord a => a -> a) -> Int
           -- という不正な型のことであり
  g :: (forall a. Ord a => a -> a) -> Int
           -- ではない
</programlisting>
後者は不正な型になる。これは馬鹿げていると思うかもしれないが、少なくとも規則は単純である。後者の型が欲しいなら、明示的にforallを書けば良い。実際、ランク2型についてはそうすることが強く推奨される。
</para>
</sect3>
</sect2>


<sect2 id="impredicative-polymorphism">
<title>非叙述的多相
</title>
<para>GHCは<emphasis>非叙述的多相</emphasis>(impredicative polymorphism)を扱え、<option>-XImpredicativeTypes</option>で有効になる。これは、多相的関数を多相型で呼ぶことができ、データ構造に多相的な型をパラメタとして与えることができるということである。例を挙げる。
<programlisting>
  f :: Maybe (forall a. [a] -> [a]) -> Maybe ([Int], [Char])
  f (Just g) = Just (g [3], g "hello")
  f Nothing  = Nothing
</programlisting>
<literal>Maybe</literal>に<emphasis>多相的</emphasis>な型である<literal>(forall a. [a] -> [a])</literal>が与えられていることに注意。</para>
<para>この拡張についての技術的な詳細は、論文<ulink url="http://research.microsoft.com/%7Esimonpj/papers/boxy/">Boxy types: type inference for higher-rank types and impredicativity</ulink>にある。これはICFP 2006に現れた。
</para>
</sect2>

<sect2 id="scoped-type-variables">
<title>字句的スコープを持つ型変数
</title>

<para>
GHCは<emphasis>字句的スコープを持つ型変数</emphasis>をサポートしている。これがないと、ある種の型シグネチャは書く方法が全くない。例を挙げる。
<programlisting>
f :: forall a. [a] -> [a]
f xs = ys ++ ys
     where
       ys :: [a]
       ys = reverse xs
</programlisting>
<literal>f</literal>の型シグネチャには明示的な<literal>forall</literal>があるので、型変数<literal>a</literal>がスコープに導入されている(<xref linkend="decl-type-sigs"/>)。<literal>forall</literal>で束縛された型変数のスコープは、それが付属している値の宣言の全体にわたる。この例では、型変数<literal>a</literal>のスコープは<literal>f</literal>の定義全体であり、<varname>ys</varname>の型シグネチャも含む。Haskell 98では、<varname>ys</varname>の型を宣言するのは不可能であった。これが可能になったことは、型変数が字句的スコープを持つことの重要な利点の一つである。
</para>
<para>字句的スコープを持つ型変数は<option>-XScopedTypeVariables</option>で有効になる。このフラグを指定すると、<option>-XRelaxedPolyRec</option>も有効になる。</para>
<para>注意: GHC 6.6では、字句的スコープを持つ型変数の挙動について大幅な変更が加えられた。この節を注意深く読んでほしい。</para>

<sect3>
<title>概観</title>
<para>以下の原則に沿って設計されている。
<itemizedlist>
<listitem><para>スコープを持つ型変数は型<emphasis>変数</emphasis>を表すものであり、<emphasis>型</emphasis>を表すものではない。(これはGHCの以前の設計との相異点である)</para></listitem>
<listitem><para>さらに、異なる字句的な型変数は異なる型変数を表す。従って、プログラマの書いた型シグネチャ(スコープを持つ型変数を含む物も)は<emphasis>固い</emphasis>(rigid)型を表す。つまり、その型は型検査器にとって完全に既知であり、推論は関与しない。</para></listitem>
<listitem><para>字句的スコープを持つ型変数は、プログラムの意味を変えることなく、自由にα改名できる。</para></listitem>
</itemizedlist>
</para>
<para>
<emphasis>字句的スコープを持つ型変数</emphasis>は以下の方法で束縛できる。
<itemizedlist>
<listitem><para>宣言型シグネチャ(<xref linkend="decl-type-sigs"/>)</para></listitem>
<listitem><para>式型シグネチャ(<xref linkend="exp-type-sigs"/>)</para></listitem>
<listitem><para>パターン型シグネチャ(<xref linkend="pattern-type-sigs"/>)</para></listitem>
<listitem><para>クラス宣言およびインスタンス宣言(<xref linkend="cls-inst-scoped-tyvars"/>)</para></listitem>
</itemizedlist>
</para>
<para>
Haskellでは、プログラマの書いた型シグネチャは、その自由変数について暗黙に量化される(Haskellレポートの<ulink url="http://www.haskell.org/onlinereport/decls.html#sect4.1.2">4.1.2節</ulink>(<ulink url="http://www.sampou.org/haskell/report-revised-j/decls.html#sect4.1.2">和訳</ulink>))。字句的スコープを持つ型変数がこの暗黙量化規則に与える影響として、スコープにある型変数は全称量化されない。例えば、型変数<literal>a</literal>がスコープにあるとすると、
<programlisting>
  (e :: a -> a)     は     (e :: a -> a)          を意味する
  (e :: b -> b)     は     (e :: forall b. b->b)  を意味する
  (e :: a -> b)     は     (e :: forall b. a->b)  を意味する
</programlisting>
</para>


</sect3>


<sect3 id="decl-type-sigs">
<title>宣言型シグネチャ</title>
<para><emphasis>明示的な</emphasis>量化(<literal>forall</literal>を使ったもの)を伴う型シグネチャがあると、その明示的に量化された型変数は、その関数の定義内において、スコープに導入される。例を挙げる。
<programlisting>
  f :: forall a. [a] -> [a]
  f (x:xs) = xs ++ [ x :: a ]
</programlisting>
<literal>forall a</literal>によって、<literal>a</literal>が<literal>f</literal>の定義内でスコープに導入されている。
</para>
<para>これは、以下の場合にのみ発生する。
<itemizedlist>
<listitem><para><literal>f</literal>の型シグネチャにおける量化が明示的である。例えば、
<programlisting>
  g :: [a] -> [a]
  g (x:xs) = xs ++ [ x :: a ]
</programlisting>
このプログラムは拒絶される。<literal>a</literal>は<literal>f</literal>の定義においてスコープにないので、<literal>x::a</literal>は、通常のHaskellの暗黙量化規則に従って、<literal>x::forall a. a</literal>と解釈される。
</para></listitem>
<listitem><para>シグネチャの対象とする束縛が関数束縛または裸の変数束縛であって、パターン束縛でない。例えば、
<programlisting>
  f1 :: forall a. [a] -> [a]
  f1 (x:xs) = xs ++ [ x :: a ]   -- 良い

  f2 :: forall a. [a] -> [a]
  f2 = \(x:xs) -> xs ++ [ x :: a ]   -- 良い

  f3 :: forall a. [a] -> [a]
  Just f3 = Just (\(x:xs) -> xs ++ [ x :: a ])   -- これは駄目！
</programlisting>
<literal>f3</literal>の束縛はパターン束縛なので、この型シグネチャは<literal>a</literal>をスコープに導入しない。一方、<literal>f1</literal>は関数束縛で、<literal>f2</literal>は裸の変数を束縛している。したがって、これらでは両方ともシグネチャが<literal>a</literal>をスコープに導入している。
</para></listitem>
</itemizedlist>
</para>
</sect3>

<sect3 id="exp-type-sigs">
<title>式型シグネチャ</title>

<para><emphasis>明示的な</emphasis>(forallを使った)量化を伴った式型シグネチャがあると、それらの型変数は、その型シグネチャの付いた式の内部において、スコープに導入される。例を挙げる。
<programlisting>
  f = runST ( (op >>= \(x :: STRef s Int) -> g x) :: forall s. ST s Bool )
</programlisting>
この場合、<literal>forall s. ST s Bool</literal>という型シグネチャによって、型変数<literal>s</literal>が、シグネチャの付いた式<literal>(op >>= \(x :: STRef s Int) -> g x)</literal>の内部においてスコープに導入される。</para>
</sect3>

<sect3 id="pattern-type-sigs">
<title>パターン型シグネチャ</title>
<para>
型シグネチャは任意のパターンの中に現れても良い。これは<emphasis>パターン型シグネチャ</emphasis>と呼ばれる。例を挙げる。
<programlisting>
  -- f と g では、'a'が既にスコープにあることを期待している
  f = \(x::Int, y::a) -> x
  g (x::a) = x
  h ((x,y) :: (Int,Bool)) = (y,x)
</programlisting>
パターン型シグネチャに現れる型変数がすべて既にスコープにある場合(つまり、外側の文脈で束縛されている場合)、事態は簡単である。そのシグネチャは、パターンの型を当たり前の方法で制限するだけのものである。
</para>
<para>
式型シグネチャや宣言型シグネチャと違って、パターン型シグネチャは暗黙に一般化されることがない。<emphasis>パターン束縛</emphasis>中のパターンは、既にスコープにある型変数にしか言及してはならない。例を示す。
<programlisting>
  f :: forall a. [a] -> (Int, [a])
  f xs = (n, zs)
    where
      (ys::[a], n) = (reverse xs, length xs) -- OK
      zs::[a] = xs ++ ys                     -- OK

      Just (v::b) = ...  -- 駄目。bがスコープにないので。
</programlisting>
ここで、<literal>ys</literal>と<literal>zs</literal>のパターンシグネチャは問題ないが、<literal>v</literal>のパターンシグネチャは、<literal>b</literal>がスコープにないので、不正である。
</para>
<para>
一方、パターン束縛<emphasis>以外</emphasis>の全てのパターンでは、パターン型シグネチャがスコープにない型変数に言及しても良い。この場合、<emphasis>このシグネチャがこの型変数をスコープに導入する</emphasis>。これは、存在的データ構築子の場合に特に重要である。例えば以下のような場合。
<programlisting>
  data T = forall a. MkT [a]

  k :: T -> T
  k (MkT [t::a]) = MkT t3
                 where
                   t3::[a] = [t,t,t]
</programlisting>
ここで、パターン型シグネチャ<literal>(t::a)</literal>は、スコープにない字句的型変数に言及している。実際、これはスコープにあっては<emphasis>ならない</emphasis>。このパターン照合で束縛されるからである。このような状況では(そしてこのような状況でのみ)、パターン型シグネチャがまだスコープにない型変数に言及できる、というのがGHCの規則である。作用として、その型変数はスコープに導入され、存在的に束縛された型変数を表すことになる。
</para>
<para>
パターン型シグネチャがこの方法で型変数を束縛する場合、GHCはその型変数が<emphasis>固い</emphasis>(完全に既知の)型変数に束縛されたと見なす。これによって、ユーザの書いた型シグネチャが全て完全に既知の型を表すことになる。
</para>
<para>
このあたりのことは少し奇妙に思えるかもしれない。我々もそう思う。しかし、このような型変数をスコープに導入する<emphasis>なんらかの</emphasis>方法は必要であり、さもなくば、後続の型シグネチャから存在束縛された型変数を名前で呼ぶことができなくなってしまう。
</para>
<para>
これはパターン型シグネチャがスコープにない字句的型変数に言及できる<emphasis>唯一の</emphasis>状況(になった)である。例えば、<literal>a</literal>がまだスコープにないなら、<literal>f</literal>と<literal>g</literal>は両方とも不正である。
</para>


</sect3>

<!-- ==================== Commented out part about result type signatures

<sect3 id="result-type-sigs">
<title>Result type signatures</title>

<para>
The result type of a function, lambda, or case expression alternative can be given a signature, thus:

<programlisting>
  {- f assumes that 'a' is already in scope -}
  f x y :: [a] = [x,y,x]

  g = \ x :: [Int] -> [3,4]

  h :: forall a. [a] -> a
  h xs = case xs of
	    (y:ys) :: a -> y
</programlisting>
The final <literal>:: [a]</literal> after the patterns of <literal>f</literal> gives the type of
the result of the function.  Similarly, the body of the lambda in the RHS of
<literal>g</literal> is <literal>[Int]</literal>, and the RHS of the case
alternative in <literal>h</literal> is <literal>a</literal>.
</para>
<para> A result type signature never brings new type variables into scope.</para>
<para>
There are a couple of syntactic wrinkles.  First, notice that all three
examples would parse quite differently with parentheses:
<programlisting>
  {- f assumes that 'a' is already in scope -}
  f x (y :: [a]) = [x,y,x]

  g = \ (x :: [Int]) -> [3,4]

  h :: forall a. [a] -> a
  h xs = case xs of
	    ((y:ys) :: a) -> y
</programlisting>
Now the signature is on the <emphasis>pattern</emphasis>; and
<literal>h</literal> would certainly be ill-typed (since the pattern
<literal>(y:ys)</literal> cannot have the type <literal>a</literal>.

Second, to avoid ambiguity, the type after the &ldquo;<literal>::</literal>&rdquo; in a result
pattern signature on a lambda or <literal>case</literal> must be atomic (i.e. a single
token or a parenthesised type of some sort).  To see why,
consider how one would parse this:
<programlisting>
  \ x :: a -> b -> x
</programlisting>
</para>
</sect3>

 -->

<sect3 id="cls-inst-scoped-tyvars">
<title>クラス宣言とインスタンス宣言</title>
<para>
<literal>class</literal>または<literal>instance</literal>宣言の頭部の中の型変数は、対応する<literal>where</literal>部分の全体に渡るスコープを持つ。例。


<programlisting>
  class C a where
    op :: [a] -> a

    op xs = let ys::[a]
                ys = reverse xs
            in
            head ys
</programlisting>
</para>
</sect3>

</sect2>

<sect2 id="typing-binds">
<title>相互再帰的な束縛に対する型付けの一般化</title>

<para>
Haskellレポートでは、束縛のグループ(最上位、または<literal>let</literal>や<literal>where</literal>中のもの)は、まず強連結な成分に分割され、次に依存性の順に型検査されると規定されている(<ulink url="http://www.haskell.org/onlinereport/decls.html#sect4.5.1">Haskellレポートの4.5.1節</ulink>(<ulink url="http://www.sampou.org/haskell/report-revised-j/decls.html#sect4.5.1">和訳</ulink>))。個々のグループが型検査されるとき、グループの中の明示的な型シグネチャのある束縛は、指定された多相型を持つものとして型環境に入れられ、そうでないものは全て、グループが一般化されるまで単相的でありつづける。(<ulink url="http://www.haskell.org/onlinereport/decls.html#sect4.5.2">Haskellレポートの4.5.2節</ulink>(<ulink url="http://www.sampou.org/haskell/report-revised-j/decls.html#sect4.5.2">和訳</ulink>))
</para>

<para>Mark Jonesの論文<ulink url="http://citeseer.ist.psu.edu/424440.html">Typing Haskell in Haskell</ulink>での提案に従って、GHCはより一般的な様式を実装している。<option>-XRelaxedPolyRec</option>が指定されているとき、<emphasis>依存性解析において、明示的な型シグネチャのある変数への参照は無視される</emphasis>。依存性解析がこのように変更される結果、依存性グループは小さくなり、より多くの束縛が型検査を通るようになる。例として以下を考える。
<programlisting>
  f :: Eq a =&gt; a -> Bool
  f x = (x == x) || g True || g "Yes"

  g y = (y &lt;= y) || f True
</programlisting>
Haskell 98ではこれは不正であるが、Jonesの様式の元では、まず<literal>g</literal>の定義の型検査が、<literal>f</literal>とは独立に行われる。これは、<literal>g</literal>の右辺での<literal>f</literal>への参照が依存性解析に無視されるからである。次に<literal>g</literal>の型が一般化され、以下のものが得られる。
<programlisting>
  g :: Ord a =&gt; a -> Bool
</programlisting>
今度は、<literal>g</literal>の型を型環境に置いて、<literal>f</literal>の定義が型検査される。
</para>

<para>
また、この改良された依存性解析によって、相互再帰的な関数のシグネチャが互いに異なる文脈を持つことができるようになった。これはHaskell 98では不正である(4.5.2節の最後の文)。<option>-XRelaxedPolyRec</option>が使われているとき、GHCは<emphasis>改良された</emphasis>グループについてのみ、シグネチャが同じ文脈を持っていることを要求する。これは実際的には、同じ文脈を持たなければならないのは、一つのパターン束縛で束縛された複数の変数だけだということである。例えば、以下のものは問題ない。
<programlisting>
  f :: Eq a =&gt; a -> Bool
  f x = (x == x) || g True

  g :: Ord a =&gt; a -> Bool
  g y = (y &lt;= y) || f True
</programlisting>
</para>
</sect2>

<sect2 id="mono-local-binds">
<title>単相的な局所束縛</title>
<para>我々は、<emphasis>局所的な束縛を一般化しない</emphasis>ことによってGHCの型システムを単純化するという案を、活発に検討している。これについての論拠は論文<ulink url="http://research.microsoft.com/~simonpj/papers/constraints/index.htm">Let should not be generalised</ulink>に記述されている。
</para>
<para>
この実験的な新しい振る舞いは、<option>-XMonoLocalBinds</option>フラグによって有効になる。これの効果は、局所的な(つまり最上位でない)束縛に型シグネチャがない場合、それが全く一般化されなくなるということである。これは、単相性限定を極端に(しかし、ずっと予測可能に)したものだと考えることができる。型シグネチャを与えた場合、このフラグに効果はない。
</para>
</sect2>

</sect1>
<!-- ==================== End of type system extensions =================  -->

<sect1 id="defer-type-errors">
<title>型エラーを実行時まで遅らせる</title>
  <para>開発中、コードに型エラーがあるにもかかわらずコンパイルが成功できるようにするのが望ましいことがある。次の例を考えよ。
<programlisting>
module Main where

a :: Int
a = 'a'

main = print "b"
</programlisting>
<literal>a</literal>の型は間違っているが、最終的には使われていないので、<literal>main</literal>のことしか気にしないなら、<literal>a</literal>についての問題を無視できると便利かもしれない。
  </para>
  <para>さらなる動機付けと詳細については、<ulink
      url="http://hackage.haskell.org/trac/ghc/wiki/DeferErrorsToRuntime">HaskellWiki</ulink>のページか、<ulink
      url="http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/">原論文</ulink>を見よ。
  </para>

<sect2><title>型エラーの遅延を有効にする</title>
  <para><literal>-fdefer-type-errors</literal>フラグは、型エラーを実行時まで遅らせるかどうかを制御する。型エラーはなお警告として出力されるが、コンパイルを止めることはない。
  </para>
  <para>実行時、型エラーのある項を評価する必要が発生すると、そのエラーは実行時例外へと変換される。実行中、型エラーは可能な限り遅らされるが、不正な型変換(coercion)は決して実行されないことに注意。これは、最終的に正しい型を持つ値を生成するような場合でも同様である。例として、以下のコードが与えられたとする。
<programlisting>
x :: Int
x = 0

y :: Char
y = x

z :: Int
z = y
</programlisting>
    <literal>x</literal>を評価すると、実行時型エラーが発生する。
  </para>
</sect2>
<sect2><title>GHCiで型エラーを遅らせる</title>
  <para><literal>-fdefer-type-errors</literal>フラグはGHCiでも動作するが、例外が一つある。プロンプトに入力された「裸の」式については、型エラーは遅らせられない。よって、例えば
<programlisting>
Prelude> fst (True, 1 == 'a')

&lt;interactive&gt;:2:12:
    No instance for (Num Char) arising from the literal `1'
    Possible fix: add an instance declaration for (Num Char)
    In the first argument of `(==)', namely `1'
    In the expression: 1 == 'a'
    In the first argument of `fst', namely `(True, 1 == 'a')'
</programlisting>
こうなっていなければ、<literal>reverse True</literal>のような単純な型エラーのある式をプロンプトに入力したようなよくある場合に、警告がまず表示され、次にすぐさま式が評価されて型エラーが表示されることになる。
  </para>
  <para>
    この例外は文には適用されない。以下の例がこれを実演する。
<programlisting>
Prelude> let x = (True, 1 == 'a')

&lt;interactive&gt;:3:16: Warning:
    No instance for (Num Char) arising from the literal `1'
    Possible fix: add an instance declaration for (Num Char)
    In the first argument of `(==)', namely `1'
    In the expression: 1 == 'a'
    In the expression: (True, 1 == 'a')
Prelude> fst x
True
</programlisting>
  </para>
</sect2>
</sect1>

<!-- ====================== TEMPLATE HASKELL =======================  -->

<sect1 id="template-haskell">
<title>Template Haskell</title>

<para>Template HaskellはHaskellでコンパイル時メタプログラミングをすることを可能にする。主要な技術的革新の背景は"<ulink url="http://research.microsoft.com/~simonpj/papers/meta-haskell/">Template Meta-programming for Haskell</ulink>" (Proc Haskell Workshop 2002)で議論されている。
</para>
<para>
Template Haskellに関するwikiページが<ulink url="http://www.haskell.org/haskellwiki/Template_Haskell">http://www.haskell.org/haskellwiki/Template_Haskell/</ulink>にある。また、<ulink url="http://www.haskell.org/ghc/docs/latest/html/libraries/index.html">オンラインHaskellライブラリリファレンス</ulink>を参照することもできる(<literal>Language.Haskell.TH</literal>というモジュールを探すと良い)。元の設計からの多くの変更点が<ulink url="http://research.microsoft.com/~simonpj/tmp/notes2.ps">Notes on Template Haskell version 2</ulink>に記されている。しかし、これらの変更点が全てGHCにある訳ではない。
</para>

<para>下(<xref linkend="th-example"/>)では、入門用の例として、論文の最初の例を使っている。
</para>

<para>
この文書は、GHCにおいてTemplate Haskellがどういう形で実現されているかを述べるものであり、Template Haskellを理解できるほど詳細ではない。<ulink url="http://haskell.org/haskellwiki/Template_Haskell">Wikiページ</ulink>を見よ。
</para>

    <sect2 id="th-syntax">
      <title>構文</title>

      <para>Template Haskellには以下に述べる新しい構文要素がある。これらの構文的拡張を有効にするにはフラグ<option>-XTemplateHaskell</option><indexterm><primary><option>-XTemplateHaskell</option></primary></indexterm>を使う必要がある。(<option>-XTemplateHaskell</option>は、<option>-fglasgow-exts</option>を使っていても、もはや自動的に有効にならない)</para>

	<itemizedlist>
	      <listitem><para>接合は、<literal>$x</literal>(「<literal>x</literal>」は識別子)または<literal>$(...)</literal>(「...」は任意の式)と書く。「$」と識別子や括弧の間には空白があってはならない。「$」のこの使いかたは中置演算子としての意味より優先される。「MM.x」が中置演算子としての「.」よりも優先されるのと同じである。中置演算子が必要なら、周りにスペースを置くこと。
		  </para>
	      <para>接合は次の場所に現れ得る。
		  <itemizedlist>
		    <listitem><para>式。接合される式の型は<literal>Q Exp</literal>でなければならない。</para></listitem>
		    <listitem><para>型。接合される式の型は<literal>Q Typ</literal>でなければならない。</para></listitem>
		    <listitem><para>トップレベル宣言のリスト。接合される式の型は<literal>Q [Dec]</literal>でなければならない。</para></listitem>
		    </itemizedlist>
パターン接合には対応していないことに注意。接合の中ではインポートしたモジュールで定義された関数しか呼ぶことができず、同じモジュールの別の場所で定義された関数は呼ぶことが出来ない。</para></listitem>


	      <listitem><para>
                  式クォートは次のようにオックスフォード角括弧で囲んで書かれる。
		  <itemizedlist>
		    <listitem><para> <literal>[| ... |]</literal>または<literal>[e| ... |]</literal>、ただし「...」は式。このクォートの型は<literal>Q Exp</literal>である。</para></listitem>
		    <listitem><para> <literal>[d| ... |]</literal>、ただし「...」は最上位の宣言の列。このクォートの型は<literal>Q [Dec]</literal>である。</para></listitem>
		    <listitem><para> <literal>[t| ... |]</literal>、ただし「...」は型。このクォートの型は<literal>Q Type</literal>である。</para></listitem>
		    <listitem><para> <literal>[p| ... |]</literal>、ただし「...」はパターン。このクォートの型は<literal>Q Pat</literal>である。</para></listitem>
		  </itemizedlist></para></listitem>

	      <listitem><para>
準クォートはパターン文脈または式文脈に出現可能で、これもオックスフォード括弧を使って書く。
		  <itemizedlist>
		    <listitem><para> <literal>[<replaceable>varid</replaceable>| ... |]</literal>、
ただし「...」は任意の文字列である。準クォート機能の完全な記述は<xref linkend="th-quasiquotation"/>にある。</para></listitem>
		  </itemizedlist></para></listitem>

	      <listitem><para>
名前は、一つか二つの一重引用符を前置することで、クォートすることができる。
		  <itemizedlist>
		    <listitem><para> <literal>'f</literal>の型は<literal>Name</literal>であり、関数<literal>f</literal>を指す。同様に<literal>'C</literal>の型は<literal>Name</literal>であり、データ構築子<literal>C</literal>を指す。一般に、<literal>'</literal><replaceable>thing</replaceable>は<replaceable>thing</replaceable>を式文脈の中で解釈する。</para>
                    <para>二文字目が一重引用符である名前は、(残念なことに)この方法でクォートすることができない。例えば、<literal>f'7</literal>という名前(これは合法なHaskellの識別子である)の関数があったとして、それをクォートしようとして<literal>'f'7</literal>と書くと、文字リテラル<literal>'f'</literal>の後に数値リテラル<literal>7</literal>が続いたものとしてパースされる。この(珍しい)状況の回避手段は今のところない。
		     </para></listitem>
		    <listitem><para> <literal>''T</literal>の型は<literal>Name</literal>であり、型構築子<literal>T</literal>を指す。つまり、<literal>''</literal><replaceable>thing</replaceable>は<replaceable>thing</replaceable>を型文脈の中で解釈する。
		     </para></listitem>
		  </itemizedlist>
	          これらの<literal>Name</literal>は、Template Haskellの式やパターンや宣言などを構築するのに使うことができる。また、関数<literal>reify</literal>へ引数として与えることもできる。
	         </para>
		</listitem>

	      <listitem><para>最上位の宣言接合においては、<literal>$(...)</literal>を省略してもよい。単に(宣言でなく)式を書けば、それが接合を意味する。例えば、以下のように書くことができる。
<programlisting>
module Foo where
import Bar

f x = x

$(deriveStuff 'f)   -- $(...)記法を使う

g y = y+1

deriveStuff 'g      -- $(...)を省略する

h z = z-1
</programlisting>
この省略によって、最上位の宣言接合がうるさくなくなり、怖い印象を与えないで済む。
	    </para></listitem>

		
	</itemizedlist>
(元の論文と比較すると、細部に多くの違いがある。宣言接合では「<literal>splice</literal>」でなく「<literal>$</literal>」が使われる。中身の式の型は<literal>[Q Dec]</literal>でなく<literal>Q [Dec]</literal>でなければならない。パターン接合とクォーテーションは実装されていない。)
</sect2>

<sect2 id="th-example">  <title>Template Haskellを使う</title>
<para>
<itemizedlist>
    <listitem><para>Template Haskell用のデータ型とモナド構築関数はライブラリ<literal>Language.Haskell.THSyntax</literal>にある。
    </para></listitem>

    <listitem><para>ある関数をコンパイル時に走らせることができるのは、その関数が別のモジュールからインポートされているときだけである。言い替えると、あるモジュールで関数を定義し、同じモジュールの接合でその関数を呼ぶということはできない。(そうすることに意味がない訳ではない。ただ実装が難しい)
   </para></listitem>

    <listitem><para>ある関数をコンパイル時に走らせることができるのは、その関数のインポート元モジュールが、<emphasis>コンパイル中のモジュールと同じ相互再帰グループに属していない</emphasis>場合だけである。さらに、その相互再帰グループの全てのモジュールが、接合が実行されるモジュールから非SOURCEなインポートを介して到達可能でなければならない。</para>
    <para>例として、Aというモジュールをコンパイルしているとき、BからインポートされたTemplate Haskellの関数を走らせることができるのは、BがAを(直接または間接に)インポートしていない場合だけである。理由は明白なはずである。Bを走らせるにはAをコンパイルして走らせねばならないが、我々は今まさにAを型検査しているのだから。</para></listitem>

    <listitem><para>
            <literal>-ddump-splices</literal>フラグを使うと、最上位の接合が展開されるたびにそれが表示される。
   </para></listitem>
    <listitem><para>
            GHCをソースからビルドしているなら、Template Haskellを使うには少なくともstage-2のブートストラップコンパイラが必要である。stage-1コンパイラはTHの要素を受け付けない。これは次のような理由による。THコンパイラはプログラムを実行し、その結果を見る。そのため、コンパイルされるプログラムの出力がコンパイラのものと同じ表現を持っていることが重要である。
   </para></listitem>
</itemizedlist>
</para>
<para>Template Haskellはどのモード(<literal>--make</literal>、<literal>--interactive</literal>、ファイル毎)でも動作する。過去には前者二つについて制限があったが、これは撤廃された。
</para>
</sect2>

<sect2>  <title>Template Haskellの実例</title>
<para>自信障壁(confidence barrier)を乗り越えるために、以下の、枠組を理解してもらうための例を試してみてほしい。まず、下の二つのモジュールを「Main.hs」と「Printf.hs」とにコピペする。</para>

<programlisting>

{- Main.hs -}
module Main where

-- 後で定義する「pr」というテンプレートをインポートする。
import Printf ( pr )

-- 接合演算子$は、prによってコンパイル時に生成された
-- Haskellのソースコードをとり、これをputStrLnの引数とし
-- て接合する。
main = putStrLn ( $(pr "Hello") )


{- Printf.hs -}
module Printf where

-- printfの枠組。論文より。
-- 使うモジュールとは別の場所で定義されていなければなら
-- ない。

-- Template Haskellの構文をインポートする
import Language.Haskell.TH

-- 書式文字列を記述する
data Format = D | S | L String

-- 書式文字列をパースする。ここでの目的は我々の最初の
-- Template Haskellのプログラムを組み上げることであり、
-- printfを組むことではないので、大部分未実装のまま残し
-- てある。
parse :: String -> [Format]
parse s   = [ L s ]

-- パースされた書式文字列の表現からHaskellのソースコー
-- ドを生成する。生成されたコードは、「pr」を呼んだモジ
-- ュールにコンパイル時に接合される。
gen :: [Format] -> Q Exp
gen [D]   = [| \n -> show n |]
gen [S]   = [| \s -> s |]
gen [L s] = stringE s

-- 入力の書式文字列から、接合するHaskellコードを生成する。
pr :: String -> Q Exp
pr s = gen (parse s)
</programlisting>

<para>次にコンパイラを走らせる。(これはWindows上のCygwinプロンプトである)
</para>
<programlisting>
$ ghc --make -XTemplateHaskell main.hs -o main.exe
</programlisting>

<para>「main.exe」を走らせれば出力が得られる。</para>

<programlisting>
$ ./main
Hello
</programlisting>

</sect2>

<sect2>
<title>Template Haskellをプロファイルと併用する</title>
<indexterm><primary>profiling</primary><secondary>with Template Haskell</secondary></indexterm>

<para>Template Haskellは、接合する式を走らせるのに、GHCの組込みのバイトコードコンパイラと解釈実行器に依存している。バイトコードの解釈実行器は、コンパイルされた式を実行する際、GHC自身が土台としているのと同じランタイムを使う。従って、解釈される式から参照されるコンパイル済みコードは、このランタイムと互換性がなければならない。特に、プロファイルのためにコンパイルされたオブジェクトコードを接合式からロードして実行することは<emphasis>できない</emphasis>。プロファイル版のオブジェクトコードはプロファイル版のランタイムとしか互換性がないからである。</para>

<para>Template Haskellのコードを含む、複数のモジュールからなるプログラムがあって、それをプロファイル用にコンパイルする必要があるとき、このことが問題になる。接合を実行するときにプロファイル用オブジェクトコードをロードして用いることができないからである。幸運にも、GHCは回避策を提供している。基本的な考え方は、プログラムを二回コンパイルするというものである。</para>

<orderedlist>
<listitem>
  <para><option>-prof</option><indexterm><primary><option>-prof</option></primary></indexterm>なしで、通常の方法でそのプログラムまたはライブラリをコンパイルする。</para>
</listitem>
<listitem>
  <para><option>-pdof</option>付きで、さらにオブジェクトファイルの名前を別のものにするために<option>-osuf p_o</option><indexterm><primary><option>-osuf</option></primary></indexterm>(通常の接尾辞以外なら何を使っても良い)も付けて、もう一度コンパイルする。GHCは、接合式を実行する際、最初の手順で構築されたオブジェクトファイルを自動的にロードする。<option>-prof</option>付きでコンパイルするとき、<option>-osuf</option>を使わず、かつTemplate Haskellが使われているなら、GHCはエラーメッセージを出力する。</para>

</listitem>
</orderedlist>
</sect2>

<sect2 id="th-quasiquotation">  <title>Template Haskellの準クォート</title>
<para>準クォートは、パターンおよび式をプログラマが定義した具象構文を使って書くことを可能にする。この拡張の背後にある動機といくつかの例が"<ulink url="http://www.eecs.harvard.edu/~mainland/ghc-quasiquoting/">Why It's Nice to be Quoted: Quasiquoting for Haskell</ulink>" (Proc Haskell Workshop 2007)に述べられている。以下の例では、単純な式言語のための準クォータをどうやって書くかを紹介する。</para>

<para>
目立つ特徴を挙げる。
<itemizedlist>
<listitem><para>
準クォートは<literal>[<replaceable>quoter</replaceable>| <replaceable>string</replaceable> |]</literal>の形をとる。
<itemizedlist>
<listitem><para>
<replaceable>quoter</replaceable>は、インポートされたクォート子(quoter)の(修飾なしの)名前でなければならない。任意の式を置ける訳ではない。
</para></listitem>
<listitem><para>
<replaceable>quoter</replaceable>は、"<literal>e</literal>"、"<literal>t</literal>"、"<literal>d</literal>"、 "<literal>p</literal>"であってはならない。これらはTemplate Haskellのクォートと重なるからである。
</para></listitem>
<listitem><para>
トークン<literal>[<replaceable>quoter</replaceable>|</literal>の間にスペースがあってはいけない。
</para></listitem>
<listitem><para>
クォートされる<replaceable>string</replaceable>は任意であり、改行を含んでもよい。
</para></listitem>
<listitem><para>
クォートされる<replaceable>string</replaceable>は、<literal>"|]"</literal>という二文字の並びが最初に出現したところで終わる。一切のエスケープは行なわれない。文字列中にこの文字の並びを埋め込みたい場合、自分でエスケープ方式を発明し(たとえば<literal>"|~]"</literal>で代用するなど)、クォート関数が<literal>"|~]"</literal>を<literal>"|]"</literal>と解釈するようにしなければならない。これをする一つの方法は、あなたのエスケープ方式を実行する前処理過程をクォート子に合成することである。詳細は<ulink url="http://hackage.haskell.org/trac/ghc/ticket/5348">Trac上の議論</ulink>を見よ。
</para></listitem>
</itemizedlist>
</para></listitem>

<listitem><para>
準クォートは以下のものが置ける場所に出現できる。
<itemizedlist>
<listitem><para>式</para></listitem>
<listitem><para>パターン</para></listitem>
<listitem><para>型</para></listitem>
<listitem><para>最上位の宣言</para></listitem>
</itemizedlist>
(論文には最初の二つだけが記述されている)
</para></listitem>

<listitem><para>
クォート子は<literal>Language.Haskell.TH.Quote.QuasiQuoter</literal>という型の値である。これは次のように定義されている。
<programlisting>
data QuasiQuoter = QuasiQuoter { quoteExp  :: String -> Q Exp,
                                 quotePat  :: String -> Q Pat,
                                 quoteType :: String -> Q Type,
                                 quoteDec  :: String -> Q [Dec] }
</programlisting>
すなわち、クォート子は四つのパーサからなるタプルである。準クォートが出現できる文脈それぞれに対して一つずつである。
</para></listitem>
<listitem><para>
準クォートを展開する際は、オックスフォード角括弧で囲まれた文字列に、適切なパーサを適用することで行なう。その準クォートの置かれた文脈(式、パターン、型、宣言)によって、どのパーサが呼ばれるかが決まる。
</para></listitem>
</itemizedlist>
</para>
<para>
下の例は、準クォートを実際に使っているところを示すものである。クォート子<literal>expr</literal>は、<literal>Expr</literal>モジュールで定義されており、<literal>QuasiQuoter</literal>型の値に束縛されている。この例では、<literal>'int:n</literal>という構文を使って、変数<literal>n</literal>を逆クォートしたものを表している(逆クォートにこの構文を使うことはこのパーサの作者が決めたことであり、GHCによって決められたことでは<emphasis>ない</emphasis>)。パターン照合の際、これは<literal>n</literal>を構築子<literal>IntExpr</literal>の整数引数に束縛する。逆クォートに関する更なる詳細については参照した論文を見てほしい。この論文には<literal>String -> a</literal>という型の単一のパーサを活用して、<literal>Q Exp</literal>型の値を返す式パーサと、<literal>Q Pat</literal>型の値を返すパターンパーサの両方を生成するためのSYBを使ったテクニックの説明もある。
</para>

<para>
準クォータはTemplate Haskellと同じステージ制限に従わねばならない。たとえば、この例において<literal>expr</literal>は<literal>Main.hs</literal>で使われているので、そこで定義されることはできず、インポートされねばならない。
</para>

<programlisting>
{- ------------- Main.hsというファイル --------------- -}
module Main where

import Expr

main :: IO ()
main = do { print $ eval [expr|1 + 2|]
          ; case IntExpr 1 of
              { [expr|'int:n|] -> print n
              ;  _              -> return ()
              }
          }


{- ------------- Expr.hsというファイル --------------- -}
module Expr where

import qualified Language.Haskell.TH as TH
import Language.Haskell.TH.Quote

data Expr  =  IntExpr Integer
           |  AntiIntExpr String
           |  BinopExpr BinOp Expr Expr
           |  AntiExpr String
    deriving(Show, Typeable, Data)

data BinOp  =  AddOp
            |  SubOp
            |  MulOp
            |  DivOp
    deriving(Show, Typeable, Data)

eval :: Expr -> Integer
eval (IntExpr n)        = n
eval (BinopExpr op x y) = (opToFun op) (eval x) (eval y)
  where
    opToFun AddOp = (+)
    opToFun SubOp = (-)
    opToFun MulOp = (*)
    opToFun DivOp = div

expr = QuasiQuoter { quoteExp = parseExprExp, quotePat =  parseExprPat }

-- Exprをパースし、その表現をQ ExpまたはQ Patとして返す。
-- SYBを使うことによって、二つのパーサを別々に書くことなく
-- 一つのString -> Exprという型のパーサを書くだけで済ます
-- 方法については、参照先の論文を見よ。

parseExprExp :: String -> Q Exp
parseExprExp ...

parseExprPat :: String -> Q Pat
parseExprPat ...
</programlisting>

<para>ではコンパイラを走らせよう。
<programlisting>
$ ghc --make -XQuasiQuotes Main.hs -o main
</programlisting>
</para>

<para>
"main"を走らせれば次のような出力になる。
<programlisting>
$ ./main
3
1
</programlisting>
</para>


</sect2>

</sect1>

<!-- ===================== Arrow notation ===================  -->

<sect1 id="arrow-notation">
<title>アロー記法
</title>

<para>アローはモナドの一般化であり、John Hughesによって導入された。詳細については、以下のものを見よ。
<itemizedlist>

<listitem>
<para>
&ldquo;Generalising Monads to Arrows&rdquo;,
John Hughes, in <citetitle>Science of Computer Programming</citetitle> 37,
pp67&ndash;111, May 2000。アローを導入した論文である。平易な入門であり、動機付けとしてプログラミングの例が使われている。
</para>
</listitem>

<listitem>
<para>
&ldquo;<ulink url="http://www.soi.city.ac.uk/~ross/papers/notation.html">A New Notation for Arrows</ulink>&rdquo;,
Ross Paterson, in <citetitle>ICFP</citetitle>, Sep 2001。
ここで記述されている記法を導入した。
</para>
</listitem>

<listitem>
<para>
&ldquo;<ulink url="http://www.soi.city.ac.uk/~ross/papers/fop.html">Arrows and Computation</ulink>&rdquo;,
Ross Paterson, in <citetitle>The Fun of Programming</citetitle>,
Palgrave, 2003.
</para>
</listitem>

<listitem>
<para>
&ldquo;<ulink url="http://www.cs.chalmers.se/~rjmh/afp-arrows.pdf">Programming with Arrows</ulink>&rdquo;,
John Hughes, in <citetitle>5th International Summer School on
Advanced Functional Programming</citetitle>,
<citetitle>Lecture Notes in Computer Science</citetitle> vol. 3622,
Springer, 2004。
この論文にもこの記法への入門が含まれており、実際的な例もついている。
</para>
</listitem>

<listitem>
<para>
&ldquo;<ulink url="http://www.haskell.org/ghc/docs/papers/arrow-rules.pdf">Type and Translation Rules for Arrow Notation in GHC</ulink>&rdquo;,
Ross Paterson and Simon Peyton Jones, September 16, 2004.
形式的な規則を簡潔に列挙したもの(ソースコード中のコメントから抽出された)。
</para>
</listitem>

<listitem>
<para><ulink url="http://www.haskell.org/arrows/"><literal>http://www.haskell.org/arrows/</literal></ulink>にアローのウェブページがある。</para>
</listitem>

</itemizedlist>
<option>-XArrows</option>フラグが与えられると、GHCは二番目の論文に記述されているアロー記法をサポートする。この記法は、<ulink url="&libraryBaseLocation;/Control-Arrow.html"><literal>Control.Arrow</literal></ulink>モジュールのコンビネータを使って通常のHaskellに翻訳される。以下に示すのは、この記法の短い紹介である。Hughesの論文を読まないとあまり意味が分からないだろう。
</para>

<para>この拡張によって、アローを定義するための新しい種類の式が追加される。
<screen>
<replaceable>exp</replaceable><superscript>10</superscript> ::= ...
       |  proc <replaceable>apat</replaceable> -> <replaceable>cmd</replaceable>
</screen>
ここで、<literal>proc</literal>は新しいキーワードである。パターン中の変数は<literal>proc</literal>式の本体において束縛されている。本体は、<firstterm>コマンド</firstterm>と呼ばれる、新しい種類のものである。コマンドの構文は以下のとおりである。
<screen>
<replaceable>cmd</replaceable>   ::= <replaceable>exp</replaceable><superscript>10</superscript> -&lt;  <replaceable>exp</replaceable>
       |  <replaceable>exp</replaceable><superscript>10</superscript> -&lt;&lt; <replaceable>exp</replaceable>
       |  <replaceable>cmd</replaceable><superscript>0</superscript>
</screen>
加えて、<replaceable>cmd</replaceable><superscript>0</superscript>から<replaceable>cmd</replaceable><superscript>9</superscript>までが、式の場合と同じように、中置演算子を使って定義される。
<screen>
<replaceable>cmd</replaceable><superscript>10</superscript> ::= \ <replaceable>apat</replaceable> ... <replaceable>apat</replaceable> -> <replaceable>cmd</replaceable>
       |  let <replaceable>decls</replaceable> in <replaceable>cmd</replaceable>
       |  if <replaceable>exp</replaceable> then <replaceable>cmd</replaceable> else <replaceable>cmd</replaceable>
       |  case <replaceable>exp</replaceable> of { <replaceable>calts</replaceable> }
       |  do { <replaceable>cstmt</replaceable> ; ... <replaceable>cstmt</replaceable> ; <replaceable>cmd</replaceable> }
       |  <replaceable>fcmd</replaceable>

<replaceable>fcmd</replaceable>  ::= <replaceable>fcmd</replaceable> <replaceable>aexp</replaceable>
       |  ( <replaceable>cmd</replaceable> )
       |  (| <replaceable>aexp</replaceable> <replaceable>cmd</replaceable> ... <replaceable>cmd</replaceable> |)

<replaceable>cstmt</replaceable> ::= let <replaceable>decls</replaceable>
       |  <replaceable>pat</replaceable> &lt;- <replaceable>cmd</replaceable>
       |  rec { <replaceable>cstmt</replaceable> ; ... <replaceable>cstmt</replaceable> [;] }
       |  <replaceable>cmd</replaceable>
</screen>
ここで、<replaceable>calts</replaceable>は<replaceable>alts</replaceable>と同様だが、本体が式ではなくコマンドだという点が異なる。
</para>

<para>
コマンドは値を生み出すが、(モナドな計算と同じく)複数の値を生み出すこともあるし、零個のこともあるし、同時に別のことを行うこともある。大部分において、モナド記法に親しんでいればコマンドを使う上での良い助けになる。ただし、式(モナドなものも含めて)の値は含まれる変数の値によって決定されるのに対し、コマンドでは必ずしもそうではない。
</para>

<para>
次に示すのは、この新しい記法の簡単な例である。
<screen>
proc x -> f -&lt; x+1
</screen>
これを、<firstterm>手続き</firstterm>または<firstterm>アロー抽象</firstterm>と呼ぶ。ラムダ式の場合と同様、変数<literal>x</literal>は<literal>proc</literal>式の内部で束縛される新しい変数である。この変数はアローへの入力を参照する。上の例で、<literal>-&lt;</literal>は識別子ではなく、新しい予約シンボルであり、アロー型の式とそのアローに食わせる式とからコマンドを構築するのに使う。(見た目が変だが、これについてはあとで納得できるだろう)。これはアローの適用に相当するものだと考えることもできる。上の例は次のHaskellの式に等しい。
<screen>
arr (\ x -> x+1) >>> f
</screen>
これは、<literal>-&lt;</literal>の左の式に束縛変数<literal>x</literal>が現れていたらおかしなことになる。一般に、<literal>-&lt;</literal>の左側の式には<firstterm>局所変数</firstterm>(現在のアロー抽象で束縛された変数)が現れてはならない。このような場合のために、<literal>-&lt;&lt;</literal>という変種があり、次のように使える。
<screen>
proc x -> f x -&lt;&lt; x+1
</screen>
これは以下のものと同じである。
<screen>
arr (\ x -> (f x, x+1)) >>> app
</screen>
よってこの場合のアローは<literal>ArrowApply</literal>クラスに属していなければならない。このようなアローはモナドと同等なので、モナドとして定式化した方が便利かも知れない。
</para>

<sect2>
<title>コマンドのdo記法</title>

<para>
コマンドは<literal>do</literal>記法の形をとることもある。例えば次のように書くことができる。
<screen>
proc x -> do
        y &lt;- f -&lt; x+1
        g -&lt; 2*y
        let z = x+y
        t &lt;- h -&lt; x*z
        returnA -&lt; t+z
</screen>
これは通常の<literal>do</literal>記法と大体同じように読むことができる。ただし、モナドな式の代わりにコマンドが使われている。最初の行では、<literal>x+1</literal>の値がアロー<literal>f</literal>に入力として送られ、出力が<literal>y</literal>に対して照合される。次の行では、出力は捨てられている。<function>returnA</function>というアローは、<ulink url="&libraryBaseLocation;/Control-Arrow.html"><literal>Control.Arrow</literal></ulink>モジュールで、<literal>arr id</literal>として定義されている。上の例は次のものの略記として扱われる。
<screen>
arr (\ x -> (x, x)) >>>
        first (arr (\ x -> x+1) >>> f) >>>
        arr (\ (y, x) -> (y, (x, y))) >>>
        first (arr (\ y -> 2*y) >>> g) >>>
        arr snd >>>
        arr (\ (x, y) -> let z = x+y in ((x, z), z)) >>>
        first (arr (\ (x, z) -> x*z) >>> h) >>>
        arr (\ (t, z) -> t+z) >>>
        returnA
</screen>
それ以降使われない変数は射影で捨てられていることに注意。これに<ulink url="&libraryBaseLocation;/Control-Arrow.html"><literal>Control.Arrow</literal></ulink>で定義されている書き換え規則(<xref linkend="rewrite-rules"/>を見よ)を使って単純化を施すと、以下のように簡約される。
<screen>
arr (\ x -> (x+1, x)) >>>
        first f >>>
        arr (\ (y, x) -> (2*y, (x, y))) >>>
        first g >>>
        arr (\ (_, (x, y)) -> let z = x+y in (x*z, z)) >>>
        first h >>>
        arr (\ (t, z) -> t+z)
</screen>
手で書くなら最初からこう書いたであろう。アロー記法を使えば、GHCがあなたの代わりにこれらの変数のタプルたちを管理してくれる。</para>

<para>
なお、上の変換では、<literal>let</literal>束縛された変数(たとえば<literal>z</literal>)が単相的でなければならないように見えるが、実際の変換で生成されるのはcoreなので、変数は多相的であり得る。
</para>

<para>
相互再帰的な束縛を使うこともできる。これには、<literal>rec</literal>という新しいキーワードを使う。以下のようになる。
<programlisting>
counter :: ArrowCircuit a => a Bool Int
counter = proc reset -> do
        rec     output &lt;- returnA -&lt; if reset then 0 else next
                next &lt;- delay 0 -&lt; output+1
        returnA -&lt; output
</programlisting>
このような形式は、変換すると、<function>loop</function>コンビネータを使ったものになるので、その場合のアローは<literal>ArrowLoop</literal>クラスに属していなければならない。
</para>

</sect2>

<sect2>
<title>条件コマンド</title>

<para>
前の例では、アローへの入力を構築するために条件式を使った。場合によっては、以下のように、条件によって異なるコマンドを実行したいことがある。
<screen>
proc (x,y) ->
        if f x y
        then g -&lt; x+1
        else h -&lt; y+2
</screen>
これは次のように変換される。
<screen>
arr (\ (x,y) -> if f x y then Left x else Right y) >>>
        (arr (\x -> x+1) >>> f) ||| (arr (\y -> y+2) >>> g)
</screen>
変換結果で<function>|||</function>が使われているので、この場合のアローは<literal>ArrowChoice</literal>クラスに属していなければならない。
</para>

<para>
以下のような<literal>case</literal>コマンドもある。
<screen>
case input of
    [] -> f -&lt; ()
    [x] -> g -&lt; x+1
    x1:x2:xs -> do
        y &lt;- h -&lt; (x1, x2)
        ys &lt;- k -&lt; xs
        returnA -&lt; y:ys
</screen>
構文は<literal>case</literal>式と同じであるが、選択肢の本体が式でなくコマンドである点が異なる。変換は<literal>if</literal>で行われるものに似ている。
</para>

</sect2>

<sect2>
<title>制御構造を自分で定義する</title>

<para>
既に見たように、アロー記法には、逐次実行、値再帰、および条件分岐について、式のものを手本とした構文要素が提供されている。しかし、適切なコンビネータ(これはHaskellで普通に定義できる)があれば、それを、既存のコマンドから新しいコマンドをつくり出すのに使うこともできる。基本的な考え方としては、コマンドを、環境から値へのアローとみなすのである。環境は、コマンド中の自由な局所変数に値を割り当てる。これにより、アローからアローをつくり出すコンビネータは、コマンドからコマンドを構築するのにも使える。例えば、<literal>ArrowPlus</literal>クラスには次のコンビネータがある。
<programlisting>
ArrowPlus a => (&lt;+>) :: a e c -> a e c -> a e c
</programlisting>
よって、これを使ってコマンドを組み立てることができる。
<programlisting>
expr' = proc x -> do
                returnA -&lt; x
        &lt;+> do
                symbol Plus -&lt; ()
                y &lt;- term -&lt; ()
                expr' -&lt; x + y
        &lt;+> do
                symbol Minus -&lt; ()
                y &lt;- term -&lt; ()
                expr' -&lt; x - y
</programlisting>
(最初の行の<literal>do</literal>は、最初の<literal>&lt;+> ...</literal>が、直前の行の式の一部だとみなされるのを防ぐために必要である)。これは以下のものと同等である。
<programlisting>
expr' = (proc x -> returnA -&lt; x)
        &lt;+> (proc x -> do
                symbol Plus -&lt; ()
                y &lt;- term -&lt; ()
                expr' -&lt; x + y)
        &lt;+> (proc x -> do
                symbol Minus -&lt; ()
                y &lt;- term -&lt; ()
                expr' -&lt; x - y)
</programlisting>
この演算子が<literal>e</literal>(そのコマンドへの環境入力。必然的にそのサブコマンドへの環境入力にもなる)について多相的であって、少なくとも正格な<literal>k</literal>については以下の自然性を満たす、ということが本質的に重要である。
<screen>
arr k >>> (f &lt;+> g) = (arr k >>> f) &lt;+> (arr k >>> g)
</screen>
(<function>seq</function>を使っていないなら自動的にこうなるはずである)。これにより、サブコマンドが見る環境がコマンド全体の環境と同じだということ、および変換において環境のうちの不要な部分を捨てても安全だということが保証される。また、この演算子は、現在のアロー抽象の中で定義された変数を使っていてはならない。
</para>

<para>
次のように自分で演算子を定義し、同様の方法で使うこともできる。
<programlisting>
untilA :: ArrowChoice a => a e () -> a e Bool -> a e ()
untilA body cond = proc x ->
        b &lt;- cond -&lt; x
        if b then returnA -&lt; ()
        else do
                body -&lt; x
                untilA body cond -&lt; x
</programlisting>
もちろん、この中置記法の構文は二項演算子についてしかうまく働かない。特別な括弧を使った、より一般的な構文が存在する。
<screen>
proc x -> do
        y &lt;- f -&lt; x+1
        (|untilA (increment -&lt; x+y) (within 0.5 -&lt; x)|)
</screen>
</para>

</sect2>

<sect2>
<title>プリミティブな構成要素</title>

<para>
演算子によっては、サブコマンドに追加の引数を渡す必要がある。例えば、例外を扱えるアローにおいて、例外ハンドラを付加する演算子では、発生した例外をハンドラに渡したいと思うだろう。このような演算子は次のような型を持っていると考えられる。
<screen>
handleA :: ... => a e c -> a (e,Ex) c -> a e c
</screen>
ここで、<literal>Ex</literal>は扱われる例外の型である。このとき、次のようなコマンドを書くことで、これをアロー記法中で使うことができる。
<screen>
body `handleA` \ ex -> handler
</screen>
意図は、コマンド<literal>body</literal>が例外を発生させたら、変数<literal>ex</literal>がその例外の値に束縛され、コマンド<literal>handler</literal>(通常<literal>ex</literal>を参照する)に進入する、というものである。この構文は関数のラムダに似ているが、ここで扱われているのはコマンドであって、やっていることが異なる。コマンドが表すアローの入力は、コマンド中の自由な局所変数の値に加えて、無名の値のスタックから成る。ここまでの例ではこのスタックは全て空だった。<function>handleA</function>の第二引数では、このスタックは一つの値、すなわち例外の値から成る。コマンド用のラムダはこの値に名前を与えているに過ぎない。
</para>

<para>
より具体的にいうと、このスタック中の値は環境と一緒に対にされる。値は右側である。<function>handleA</function>のような、サブコマンドに追加の入力を渡す演算子は、その値を環境と一緒に対にすることでこの記法で使えるようになる。正確に言うと、演算子のそれぞれの引数(および結果)の型は以下の形をしているべきである。
<screen>
a (...(e,t1), ... tn) t
</screen>
ここで、<replaceable>e</replaceable>は(環境を表す)多相変数であり、<replaceable>ti</replaceable>はスタック中の値の型であり、<replaceable>t1</replaceable>が「先頭」である。多相変数<replaceable>e</replaceable>は<replaceable>a</replaceable>、<replaceable>ti</replaceable>、<replaceable>t</replaceable>に現れてはならない。一方、関係するアローが同じである必要はない。適切な演算子の例をもう少し示す。
<screen>
bracketA :: ... => a e b -> a (e,b) c -> a (e,c) d -> a e d
runReader :: ... => a e c -> a' (e,State) c
runState :: ... => a e c -> a' (e,State) (c,State)
</screen>
後ろ二者で作られたコマンドが必要とする追加の引数は、そのコマンドを通常の式に適用することで与えることができる。次のように。
<screen>
proc x -> do
        s &lt;- ...
        (|runReader (do { ... })|) s
</screen>
これは、<function>runReader</function>を使って作られたコマンドの入力のスタックに<literal>s</literal>を加えている。
</para>

<para>
コマンド版のラムダ抽象と適用は式におけるそれに似ている。特に、β規則とη規則がコマンドの同等性を記述する。これらの三つの機能(演算子、ラムダ抽象、適用)がこの記法の核である。他のものは全てこれらを使って(不格好になるだろうが)構築することができる。例えば、次のように定義することによって<literal>do</literal>記法をシミュレートできる。
<programlisting>
bind :: Arrow a => a e b -> a (e,b) c -> a e c
u `bind` f = returnA &amp;&amp;&amp; u >>> f

bind_ :: Arrow a => a e b -> a e c -> a e c
u `bind_` f = u `bind` (arr fst >>> f)
</programlisting>
次のように定義することで<literal>if</literal>をシミュレートできる。
<programlisting>
cond :: ArrowChoice a => a e b -> a e b -> a (e,Bool) b
cond f g = arr (\ (e,b) -> if b then Left e else Right e) >>> f ||| g
</programlisting>
</para>

</sect2>

<sect2>
<title>論文との差異</title>

<itemizedlist>

<listitem>
<para>一種類のアロー適用(アロー尾部)に二通りの変換を用意する代わりに、実装では二種類、すなわち「<literal>-&lt;</literal>」(一階)と「<literal>-&lt;&lt;</literal>」(高階)が提供されている。
</para>
</listitem>

<listitem>
<para>ユーザ定義の演算子を明示するのに、<literal>form</literal>という新しいキーワードではなく、バナナ括弧を使っている。
</para>
</listitem>

</itemizedlist>

</sect2>

<sect2>
<title>可搬性</title>

<para>
アロー記法を直接実装しているのはGHCだけであるが、アロー記法をHaskell 98に変換することで別のHaskellシステムでも使える前処理器(<ulink url="http://www.haskell.org/arrows/">arrows web page</ulink>から入手可能)もある。それでも、アローを使ったプログラムをGHCで検査したいと思うかもしれない。前処理器の出力から型エラーを追跡するのは簡単ではないからである。モジュールを、GHCとこの前処理器の両方で使えるようにする場合、いくつか余分な制約が科せられる。
<itemizedlist>

<listitem>
<para>
モジュールは<ulink url="&libraryBaseLocation;/Control-Arrow.html"><literal>Control.Arrow</literal></ulink>をインポートしなければならない。
</para>
</listitem>

<listitem>
<para>
前処理器は他のHaskell拡張に対応していないので、そういうものは別のモジュールに置かなければならない。
</para>
</listitem>

<listitem>
<para>
前処理器の出力はHaskell(Coreではなく)なので、<literal>let</literal>束縛された変数は単相的になる。
</para>
</listitem>

</itemizedlist>
</para>

</sect2>

</sect1>

<!-- ==================== BANG PATTERNS =================  -->

<sect1 id="bang-patterns">
<title>びっくりパターン
<indexterm><primary>Bang patterns</primary></indexterm>
</title>
<para>GHCは<emphasis>びっくりパターン</emphasis>と呼ばれるパターン照合の拡張をサポートしている。これは<literal>!<replaceable>pat</replaceable></literal>と書く。びっくりパターンはHaskell Primeへの採用が検討されている。<ulink url="http://hackage.haskell.org/trac/haskell-prime/wiki/BangPatterns">Haskell primeの特徴まとめ</ulink>には、以下にあるのよりも多くの議論と例が載っている。
</para>
<para>
鍵となる変更は、<ulink url="http://haskell.org/onlinereport/exps.html#sect3.17.2">Haskell98レポート中のパターン照合の意味論</ulink>(<ulink url="http://www.sampou.org/haskell/report-revised-j/exps.html#sect3.17.2">和訳</ulink>)に規則を一つ追加するというものである。第十項目として次を付け加える。「パターン<literal>!pat</literal>の値<literal>v</literal>への照合は、次のように振る舞う」
<itemizedlist>
<listitem><para>もし<replaceable>v</replaceable>がボトムなら、照合は発散する</para></listitem>
<listitem><para>そうでなければ、<replaceable>pat</replaceable>が<replaceable>v</replaceable>へと照合される</para></listitem>
</itemizedlist>
</para>
<para>
びっくりパターンはフラグ<option>-XBangPatterns</option>で有効になる。
</para>

<sect2 id="bang-patterns-informal">
<title>びっくりパターンについての非形式的な説明
</title>
<para>この拡張の要点は、パターンの構文に一つの新しい生成規則を追加することである。
<programlisting>
  pat ::= !pat
</programlisting>
式<literal>e</literal>をパターン<literal>!p</literal>に対して照合するとき、まず<literal>e</literal>が(WHNFまで)評価され、その結果が<literal>p</literal>に対して照合される。例を挙げる。
<programlisting>
f1 !x = True
</programlisting>
この定義では、<literal>f1</literal>が<literal>x</literal>について正格になっている。びっくりパターンがなければ遅延であったところだ。もちろん、びっくりパターンは入れ子にすることができる。
<programlisting>
f2 (!x, y) = [x,y]
</programlisting>
ここで、<literal>f2</literal>は<literal>x</literal>について正格だが、<literal>y</literal>については正格でない。びっくりパターンが実質的に効果を持つのは、変数パターンやワイルドカードパターンの前に置かれたときだけである。
<programlisting>
f3 !(x,y) = [x,y]
f4 (x,y)  = [x,y]
</programlisting>
ここでは、<literal>f3</literal>と<literal>f4</literal>は等しい。もともと評価を強制するパターンの前にびっくりマークを置いても何も変わらない。
</para>
<para>
この、「びっくりマークは変数かワイルドカードの前に置かれたときのみ違いがある」という一般的な法則には、(見掛け上の)例外が一つある。<literal>let</literal>または<literal>where</literal>束縛の最上位におけるびっくりマークは、パターンに関係なく、その束縛を正格にする。(「見掛け上の」例外と言ったのは、束縛の最上位にあるびっくりマークは<emphasis>パターン</emphasis>の一部ではないと考えるのが正しいからである。そうではなく、これは<emphasis>束縛</emphasis>の構文の一部であり、「びっくりパターン束縛」を作る。)
例を示す。
<programlisting>
let ![x,y] = e in b
</programlisting>
これはびっくりパターン束縛である。操作的には、これは次のcase式とまったく同様に振る舞う。
<programlisting>
case e of [x,y] -> b
</programlisting>
case式と同様に、びっくりパターン束縛は非再帰的かつ単相的でなければならない。一方、パターン束縛中に入れ子になったびっくりパターンは、他のあらゆる形式のパターンと同様に振る舞う。例を挙げる。
<programlisting>
let (!x,[y]) = e in b
</programlisting>
これは以下と同等である。
<programlisting>
let { t = case e of (x,[y]) -> x `seq` (x,y)
      x = fst t
      y = snd t }
in b
</programlisting>
この束縛は遅延するが、<literal>x</literal>か<literal>y</literal>のいずれかが<literal>b</literal>によって評価されると、パターン全体が照合され、それに伴って<literal>x</literal>の評価が強制される。
</para>
<para>
もちろん、びっくりパターンは<literal>case</literal>式でも使える。
<programlisting>
g5 x = let y = f x in body
g6 x = case f x of { y -&gt; body }
g7 x = case f x of { !y -&gt; body }
</programlisting>
関数<literal>g5</literal>と<literal>g6</literal>は全く同じである。一方、<literal>g7</literal>では<literal>(f x)</literal>が評価され、その結果が<literal>y</literal>に束縛された後、<literal>body</literal>が評価される。
</para>
</sect2>


<sect2 id="bang-patterns-sem">
<title>構文と意味論
</title>
<para>

パターンの構文に一つの新しい生成規則を加える。
<programlisting>
  pat ::= !pat
</programlisting>
これには一つ構文的な曖昧さの問題がある。以下の例を考えよ。
<programlisting>
f !x = 3
</programlisting>
これは中置関数「<literal>(!)</literal>」の定義なのだろうか。それともびっくりパターンを使った「<literal>f</literal>」の定義なのだろうか。GHCは、この曖昧さを、後者を優先することで解決する。びっくりパターンが有効な状態で<literal>(!)</literal>を定義したいなら、前置記法を使わなければならない。
<programlisting>
(!) f x = 3
</programlisting>
Haskellのパターン照合の意味論はHaskellレポートの<ulink url="http://www.haskell.org/onlinereport/exps.html#sect3.17.2">3.17.2節</ulink>(<ulink url="http://www.sampou.org/haskell/report-revised-j/exps.html#sect3.17.2">和訳</ulink>)に書かれている。この記述に、第十項目として以下のものを付け加える。
<itemizedlist><listitem><para>パターン<literal>!pat</literal>の値<literal>v</literal>への照合は、次のように振る舞う:
<itemizedlist><listitem><para>もし、<literal>v</literal>がボトムなら、照合は発散する。</para></listitem>
		<listitem><para>そうでなければ、<literal>pat</literal>は<literal>v</literal>と照合する。</para></listitem>
</itemizedlist>
</para></listitem></itemizedlist>
同様に、<ulink url="http://www.haskell.org/onlinereport/exps.html#sect3.17.3">3.17.3節</ulink>(<ulink url="http://www.sampou.org/haskell/report-revised-j/exps.html#sect3.17.3">和訳</ulink>)の図4に、新しい場合(t)を追加する。
<programlisting>
case v of { !pat -> e; _ -> e' }
   = v `seq` case v of { pat -> e; _ -> e' }
</programlisting>
</para><para>
残りはlet式である。これの変換はHaskellレポートの<ulink url="http://www.haskell.org/onlinereport/exps.html#sect3.12">3.12節</ulink>(<ulink url="http://www.sampou.org/haskell/report-revised-j/exps.html#sect3.12">和訳</ulink>)で与えられている。そこにある変換の箱において、まず以下の変換を施す。<literal>!qi = ei</literal>という形をした全てのパターン<literal>pi</literal>について、これを<literal>(xi,!qi) = ((),ei)</literal>に変換し、<literal>e0</literal>を<literal>(xi `seq` e0)</literal>で置き換える。次に、左辺のパターンがどれも先頭にびっくりマークを持たないようになったら、今ある箱の中にある規則を適用する。
</para>
<para>このlet規則の効果は、本体の評価が始まる前に、パターン<literal>qi</literal>の照合を完全に終わらせることである。以下のように、<literal>qi</literal>が変数である場合に備えて、びっくりマークは変換後の形においても保持される。
<programlisting>
  let !y = f x in b
</programlisting>

</para>
<para>
このようなlet束縛は再帰的になり得る。しかし、非再帰的であることの方がずっと多く、その場合以下の法則が成り立つ。
<literal>(let !p = rhs in body)</literal>は、<literal>(case rhs of !p -> body)</literal>と同等である。
</para>
<para>
びっくりマークが最も外側にあるようなパターンは、モジュールの最上位では許されない。
</para>
</sect2>
</sect1>

<!-- ==================== ASSERTIONS =================  -->

<sect1 id="assertions">
<title>アサーション
<indexterm><primary>Assertions</primary></indexterm>
</title>

<para>
標準Haskellのコードでアサーションを使いたいなら、次のような関数を定義することができるだろう。
</para>

<para>

<programlisting>
assert :: Bool -> a -> a
assert False x = error "assertion failed!"
assert _     x = x
</programlisting>

</para>

<para>
これは動作するが、発生するエラーメッセージは全く役に立たない。アサーションが失敗した。よろしい。しかしどこのどれが失敗したのだ？
</para>

<para>
一つの解決策は、<function>assert</function>を拡張して、エラーメッセージに含める文字列を受け取るようにし、例えばソース中で<function>assert</function>が使われている場所にソース位置を挿入する前処理器と組み合わせることである。
</para>

<para>
GHCはこれに対して救いの手を差しのべる。これら全てを代わりに行うことによって。ユーザのソースにおいて<function>assert</function>が使われているところ全てに対して、以下の処理を行う。
</para>

<para>

<programlisting>
kelvinToC :: Double -> Double
kelvinToC k = assert (k &gt;= 0.0) (k+273.15)
</programlisting>

</para>

<para>
上のようなものがあったとき、これを、アサーションが行われた地点を含むように書き換える。
</para>

<para>

<programlisting>
assert pred val ==> assertError "Main.hs|15" pred val
</programlisting>

</para>

<para>
このような書き換えが行われるのは、コンパイラが<function>Control.Exception.assert</function>の適用を見つけたときだけである。したがって、もし望むなら、自分で定義した<function>assert</function>を使うこともできる。そうでないなら、<function>assert</function>を使うときは<literal>Control.Exception</literal>をインポートせよ。
</para>

<para>
GHCは、<option>-O</option><indexterm><primary><option>-O</option></primary></indexterm>フラグで最適化が有効になっていると、アサーションを無視する。つまり、<literal>assert pred e</literal>という形の式は<literal>e</literal>に書き換えられる。<option>-fignore-asserts</option>オプション<indexterm><primary><option>-fignore-asserts</option></primary></indexterm>を使ってアサーションを無効にすることもできる。</para>

<para>
アサーションの失敗は補足することができる。詳細は<literal>Control.Exception</literal>の説明書きを見よ。
</para>

</sect1>


<!-- =============================== PRAGMAS ===========================  -->

  <sect1 id="pragmas">
    <title>プラグマ</title>

    <indexterm><primary>pragma</primary></indexterm>

    <para>GHCはいくつかのプラグマ(ソースコード中に置かれるコンパイラへの指示)に対応している。プラグマは通常プログラムの意味には影響を与えないが、生成されるコードの効率性には影響し得る。</para>

    <para>全てのプラグマは<literal>{-# <replaceable>word</replaceable> ... #-}</literal>という形を取る。ここで、<replaceable>word</replaceable>はプラグマの種類を表す。必要なら、この後に続けて、その種類のプラグマに特有の情報を書く。<replaceable>word</replaceable>では大文字小文字の区別はなされない。GHCが理解する種々のプラグマは以下の節で解説されている。認識できない<replaceable>word</replaceable>を持ったプラグマは無視される。プラグマ中ではレイアウト規則が適用されるので、閉じ括弧<literal>#-}</literal>は開き括弧<literal>{-#</literal>よりも右のカラムで始まっていなければならない。</para>

    <para>ある種のプラグマは<emphasis>ファイルヘッダプラグマ</emphasis>である。
      <itemizedlist>
      <listitem><para>ファイルヘッダプラグマは、ファイル中で<literal>module</literal>キーワードよりも前になければならない。</para></listitem>
      <listitem><para>ファイルヘッダプラグマはいくつあっても良いし、コメントの前にあっても後にあっても良い。</para></listitem>
      <listitem><para>ファイルヘッダプラグマは、そのファイルを(例えばcppで)前処理する前に、一回だけ読まれる。</para></listitem>
      <listitem><para>ファイルヘッダプラグマは以下のものである。<literal>{-# LANGUAGE #-}</literal>、<literal>{-# OPTIONS_GHC #-}</literal>、<literal>{-# INCLUDE #-}</literal>。</para></listitem>
      </itemizedlist>
      </para>

    <sect2 id="language-pragma">
      <title>LANGUAGEプラグマ</title>

      <indexterm><primary>LANGUAGE</primary><secondary>pragma</secondary></indexterm>
      <indexterm><primary>pragma</primary><secondary>LANGUAGE</secondary></indexterm>

      <para>このプラグマは、言語拡張を、可搬性のある方法で有効にできるようにするものである。意図としては、全てのコンパイラが同じ構文の<literal>LANGUAGE</literal>に対応する、というものである。もちろん、全ての拡張が全てのコンパイラで使える訳ではないが。可能なら、<literal>OPTIONS_GHC</literal>プラグマの代わりに<literal>LANGUAGE</literal>を使うべきである。</para>

      <para>例えば、FFIと、CPPを使った前処理を有効にするには、次のようにする。</para>

<programlisting>{-# LANGUAGE ForeignFunctionInterface, CPP #-}</programlisting>

      <para><literal>LANGUAGE</literal>はファイルヘッダプラグマ(<xref linkend="pragmas"/>を見よ)である。</para>

      <para>全ての言語拡張は、前に「<literal>-X</literal>」を付けることでコマンド行フラグになる。例えば<option>-XForeignFunctionInterface</option>のように。(同様に、全ての「<literal>-X</literal>」フラグは<literal>LANGUAGE</literal>プラグマとして書ける)
      </para>
      <para>対応している言語拡張の一覧は、<literal>ghc --supported-extensions</literal>を実行することで得られる。(<xref linkend="modes"/>を見よ)</para>

      <para><ulink url="&libraryCabalLocation;/Language-Haskell-Extension.html"><literal>Language.Haskell.Extension</literal></ulink>で定義されている型<literal>Extension</literal>の構築子ならどれを使っても良い。指定された拡張がGHCでサポートされていないなら、エラーが報告される。</para>
    </sect2>

    <sect2 id="options-pragma">
      <title>OPTIONS_GHCプラグマ</title>
      <indexterm><primary>OPTIONS_GHC</primary>
      </indexterm>
      <indexterm><primary>pragma</primary><secondary>OPTIONS_GHC</secondary>
      </indexterm>

      <para><literal>OPTIONS_GHC</literal>プラグマは、そのソースファイルをコンパイルするときにコンパイラに与える追加のオプションを指定するのに使う。詳細は<xref linkend="source-file-options"/>を見よ。</para>

      <para>GHCの古い版では<literal>OPTIONS_GHC</literal>ではなく<literal>OPITONS</literal>を受け付けていたが、これはもはや非推奨である。</para>
    </sect2>

      <para><literal>OPTIONS_GHC</literal>はファイルヘッダプラグマ(<xref linkend="pragmas"/>を見よ)である。</para>

    <sect2 id="include-pragma">
      <title>INCLUDEプラグマ</title>

      <para>過去には、FFIを使うとき、Cを介してコンパイルしているなら、<literal>INCLUDE</literal>プラグマを使ってどのヘッダファイルをincludeする必要があるか指定しなければならなかった。これはもはやGHCにとって必要でないが、他のコンパイラとの互換性のために受け付けられる(そして無視される)。</para>
    </sect2>

    <sect2 id="warning-deprecated-pragma">
      <title>WARNINGおよびDEPRECATEDプラグマ</title>
      <indexterm><primary>WARNING</primary></indexterm>
      <indexterm><primary>DEPRECATED</primary></indexterm>

      <para>WARNINGプラグマを使うと、特定の関数やクラスや型に任意の警告を付属させることができる。DEPRECATEDプラグマを使うと、特定の関数やクラスや型が、非推奨・廃止予定であると指定できる。これらのプラグマを使うには二つの方法がある。

      <itemizedlist>
	<listitem>
	  <para>モジュール全体を相手にすることができる。</para>
<programlisting>
   module Wibble {-# DEPRECATED "Use Wobble instead" #-} where
     ...
</programlisting>
      <para>あるいは、</para>
<programlisting>
   module Wibble {-# WARNING "This is an unstable interface." #-} where
     ...
</programlisting>
          <para><literal>Wibble</literal>をインポートしているモジュールをコンパイルするときはいつでも、GHCは指定されたメッセージを印字する。</para>
	</listitem>

	<listitem>
	  <para>次のような最上位の宣言を使うことで、関数、クラス、型、データ構築子に警告を付属させることができる。</para>
<programlisting>
   {-# DEPRECATED f, C, T "Don't use these" #-}
   {-# WARNING unsafePerformIO "This is unsafe; I hope you know what you're doing" #-}
</programlisting>
	  <para>指定された実体をインポートして使用しているモジュールをコンパイルするとき、GHCは指定されたメッセージを印字する。</para>
          <para>付属させることができるのは、コンパイル中のモジュールの最上位で宣言されている実体だけである。また、実体を宣言する際には未修飾名を使わなければならない。<literal>T</literal>のように大文字から始まる名前は、型構築子<literal>T</literal>かデータ構築子<literal>T</literal>かの<emphasis>いずれか</emphasis>であり、両方がスコープにあるなら両方である。両方がスコープにあるとき、片方だけを指定することは今のところできない。(<xref linkend="infix-tycons"/>と比較せよ)</para>
	</listitem>
      </itemizedlist>
警告と非推奨報告は次のものに対しては為されない。(a) 定義されたモジュール中での使用、および (b) エクスポートリスト中での使用。後者のおかげで、一つのモジュールが複数のモジュールがエクスポートしているものを集めて再エクスポートするという構造のライブラリで、余計な文句を言うことがない。</para>
      <para>フラグ<option>-fno-warn-warnings-deprecations</option>を使ってこの警告を抑制することができる。</para>
    </sect2>

    <sect2 id="inline-noinline-pragma">
      <title>INLINEおよびNOINLINEプラグマ</title>

      <para>これらのプラグマは関数定義のインライン化を制御する。</para>

      <sect3 id="inline-pragma">
	<title>INLINEプラグマ</title>
	<indexterm><primary>INLINE</primary></indexterm>

	<para>GHCは、(いつもと同様、<option>-O</option>が指定されているときだけ)「十分に小さい」関数・値をインライン化(または「展開(unfold)」)して、呼び出しのオーバーヘッドを回避し、場合によってはより素晴らしい最適化を可能にしようとする。通常、GHCがある関数をインライン化するのが「高くつきすぎる」と判断したときは、インライン化は行わないし、他のモジュールで使うために展開候補をエクスポートすることもない。</para>

        <para>ここで使える強力な武器が<literal>INLINE</literal><indexterm><primary>INLINE pragma</primary></indexterm>プラグマであり、次のように使う。</para>

<programlisting>
key_function :: Int -> String -> (Bool, Double)
{-# INLINE key_function #-}
</programlisting>

        <para><literal>INLINE</literal>プラグマの主要な効果は、ある関数の「コスト」がとても低いと宣言することである。これによって、通常の展開機構がインライン化に非常に積極的になる。一方、関数「<literal>f</literal>」に関する<literal>INLINE</literal>プラグマには、他の効果がいくつかある。
<itemizedlist>
<listitem><para>
GHCは関数のインライン化について熱心であるが、盲目的に行なう訳ではない。例えば、次のように書いたとする。
<programlisting>
map key_function xs
</programlisting>
これをインライン化して以下のようにしても、実際得られるものは何もない。
<programlisting>
map (\x -> <replaceable>body</replaceable>) xs
</programlisting>
一般的に言って、GHCが関数をインライン化するのは、そうすることが有益だと考えるなんらかの理由が(どんなに軽微なものでもいいが)ある場合だけである。
</para></listitem>
<listitem><para>
さらに、GHCは関数が<emphasis>完全に適用されて</emphasis>いる場合にしかインライン化しない。ここで「完全に適用されて」いるというのは、その関数の定義の左辺に(構文的に)出現する引数の数と同じだけの引数に適用されているということである。例を挙げる。
<programlisting>
comp1 :: (b -> c) -> (a -> b) -> a -> c
{-# INLINE comp1 #-}
comp1 f g = \x -> f (g x)

comp2 :: (b -> c) -> (a -> b) -> a -> c
{-# INLINE comp2 #-}
comp2 f g x = f (g x)
</programlisting>
<literal>comp1</literal>と<literal>comp2</literal>の二つの関数は同じ意味論を持つが、<literal>comp1</literal>が<emphasis>二個</emphasis>の引数に適用されたときにインライン化されるのに対して、<literal>comp2</literal>は三個を必要とする。これは次のような場合に重大な違いを生むことがある。
<programlisting>
map (not `comp1` not) xs
</programlisting>
これは、同様に「comp2」を使った場合よりも良く最適化されることになるだろう。
</para></listitem>

<listitem><para>
INLINE関数<literal>f</literal>の非インライン版が最終的に使われる場合を考慮して、通常の非インライン関数と同様に<literal>f</literal>の定義を最適化することが、GHCにとって有用である。しかし、<literal>f</literal>の<emphasis>最適化</emphasis>版をインライン化したくはない。INLINEプラグマを使うことの大きな理由の一つは、<literal>f</literal>の右辺にある関数が書き換え規則を持っている場合にそれを露出することだが、これらの関数が最適化によって消えてしまっては良くない。
</para>
<para>
そのため、<emphasis>GHCは、書かれたコードをそのままの形でインライン化することを保証する</emphasis>。過不足なく。そのために、インライン用に関数定義のコピー("inline-RHS"と呼んでいる)を取っておき、それには手をつけずに、通常の右辺をいつものように最適化する。外部から可視である関数については、(最適化された右辺ではなく)この"inline-RHS"がインタフェースファイルに記録される。
</para></listitem>
<listitem><para>
INLINE関数は正格性解析によってworker/wrapperされることがない。そうでなく、全部まとめてインライン化される。
</para></listitem>
</itemizedlist>
</para>
<para>
GHCはインライン化が永遠に続くことがないことを保証する。相互再帰的な一団はすべて、一個以上の決してインライン化されない<emphasis>ループ破り</emphasis>によって切り離される。(<ulink url="http://research.microsoft.com/%7Esimonpj/Papers/inlining/index.htm"> Secrets of the GHC inliner, JFP 12(4) July 2002</ulink>を見よ)。GHCはループ破りとしてINLINEプラグマのついた関数を選ばないことを試みるが、選択肢がないときはINLINE関数でも選択され得、この場合INLINEプラグマは無視される。例えば、自己再帰的な関数では、ループ破りはその関数自体でしかありえないので、INLINEプラグマは常に無視される。</para>

        <para>構文的には、ある関数についての<literal>INLINE</literal>プラグマは、その関数の型シグネチャが置けるところならどこに置いても良い。</para>

        <para><literal>INLINE</literal>プラグマはモナドの<literal>then</literal>/<literal>return</literal>(または<literal>bind</literal>/<literal>unit</literal>)関数に特に有用である。例えば、GHCの<literal>UniqueSupply</literal>モナドのコードには次のものが含まれている。</para>

<programlisting>
#ifdef __GLASGOW_HASKELL__
{-# INLINE thenUs #-}
{-# INLINE returnUs #-}
#endif
</programlisting>

	<para><literal>NOINLINE</literal>プラグマ(<xref linkend="noinline-pragma"/>)と<literal>INLINABLE</literal>プラグマ(<xref linkend="inlinable-pragma"/>)も見よ。</para>

	<para>注意: HBCコンパイラは<literal>INLINE</literal>プラグマと相性が悪いので、コードをHBC互換にしたいなら<literal>#ifdef __GLASGOW_HASKELL__</literal>...<literal>#endif</literal>というCプリプロセッサ指令でプラグマを囲む必要があるだろう。</para>

      </sect3>

      <sect3 id="inlinable-pragma">
	<title>INLINABLEプラグマ</title>

<para>関数<literal>f</literal>に対する<literal>{-# INLINABLE f #-}</literal>プラグマは、以下のように振る舞う。
<itemizedlist>
<listitem><para>
<literal>INLINE</literal>は「これをインライン化してくれ」と言うものだが、<literal>INLINABLE</literal>は「インライン化は御自由に、あなたの裁量で」というものである。つまり、選択はGHCに委ねられ、プラグマのない関数と同じ規則が使われる。INLINEと異なり、その選択は<emphasis>呼び出し地点</emphasis>で行なわれ、したがってインライン化閾値や、最適化水準などの影響を受ける。</para></listitem>
<listitem><para>
<literal>INLINE</literal>と同様に、<literal>INLINABLE</literal>プラグマは元々の右辺のコピーを保持し、その右辺の大きさにかかわらずそれをインタフェースファイルに保存する。
</para></listitem>
<listitem><para>
<literal>INLINABLE</literal>プラグマの使い道の一つは、特殊関数<literal>inline</literal>(<xref linkend="special-ids"/>)と組み合わせることである。<literal>inline f</literal>という呼び出しは、極めて積極的に<literal>f</literal>をインライン化しようとする。<literal>f</literal>がインライン化できることを確実にするために<literal>f</literal>を<literal>INLINABLE</literal>と標示するのは良い考えである。そうすることで、GHCがそれの展開候補を(どれだけ大きくても)露出させることを保証するようにできるからである。さらに、<literal>f</literal>が<literal>INLINABLE</literal>であるという注釈をすることで、GHCの最適化器が作り出した何らかの<literal>f</literal>の最適化版ではなく、<literal>f</literal>の元々の右辺がインライン化されることが確かになる。
</para></listitem>
<listitem><para>
<literal>INLINABLE</literal>プラグマは<literal>SPECIALISE</literal>プラグマとも共同する。すなわち、関数<literal>f</literal>を<literal>INLINABLE</literal>と標示した場合、後で別モジュールで<literal>SPECIALISE</literal>することができる(<xref linkend="specialize-pragma"/>を見よ)。</para></listitem>

<listitem><para>
<literal>INLINE</literal>プラグマと異なり、<literal>INLINABLE</literal>プラグマを再帰関数に使うのは問題ない。これをするのは主に後で<literal>SPECIALISE</literal>を使えるようにするためである。
</para></listitem>
</itemizedlist>
</para>

      </sect3>

      <sect3 id="noinline-pragma">
	<title>NOINLINEプラグマ</title>
	
	<indexterm><primary>NOINLINE</primary></indexterm>
	<indexterm><primary>NOTINLINE</primary></indexterm>

        <para><literal>NOINLINE</literal>プラグマはまさに想像される通りのことを行う。すなわち、指定された関数がコンパイラによってインライン化されるのを防ぐ。コードの大きさについて非常に用心深くある場合をのぞけば、これが必要になることはないはずである。</para>

        <para><literal>NOTINLINE</literal>は<literal>NOINLINE</literal>の同義名である。(<literal>NOINLINE</literal>は、Haskell 98によって、インライン化を無効にするための標準的な方法として定められているので、コードの可搬性を気にするならこちらを使うべきである)</para>
      </sect3>

      <sect3 id="conlike-pragma">
	<title>CONLIKE修飾子</title>
	<indexterm><primary>CONLIKE</primary></indexterm>
        <para>INLINEプラグマとNOINLINEプラグマはCONLIKE修飾子を持つことができる。これは、RULEの照合に(のみ)影響する。<xref linkend="conlike"/>を見よ。</para>
      </sect3>

      <sect3 id="phase-control">
	<title>段階管理</title>

        <para>GHCのパイプライン中のどの段階でINLINEプラグマが有効になるかを制御したいことがあるだろう。インライン化が行われるのは、<emphasis>単純化器</emphasis>の実行過程だけである。単純化器は、毎回異なる<emphasis>段階番号</emphasis>で実行される。段階番号は零に向かって減少する。<option>-dverbose-core2core</option>を使えば、単純化器が連続して実行されるに際しての段階番号を見ることができる。次のように、INLINEプラグマに段階番号を指定することができる。
	<itemizedlist>
	  <listitem>
	    <para>"<literal>INLINE[k] f</literal>" : 段階<literal>k</literal>までは<literal>f</literal>をインライン化しないが、段階<literal>k</literal>以降は非常に積極的にインライン化する。
            </para></listitem>
	  <listitem>
	    <para>"<literal>INLINE[~k] f</literal>" : 段階<literal>k</literal>までは<literal>f</literal>を非常に積極的にインライン化するが、段階<literal>k</literal>以降はインライン化しない。
            </para></listitem>
	  <listitem>
	    <para>"<literal>NOINLINE[k] f</literal>" : 段階<literal>k</literal>までは<literal>f</literal>をインライン化しないが、段階<literal>k</literal>以降は(プラグマがないかのように)インライン化しようとする。
            </para></listitem>
	    <listitem>
	    <para>"<literal>NOINLINE[~k] f</literal>" : 段階<literal>k</literal>までは<literal>f</literal>をインライン化しようとするが、段階<literal>k</literal>以降はインライン化しない。
            </para></listitem>
	</itemizedlist>
以下に、上の情報をまとめる。
<programlisting>
                           --  段階2より前         段階2以降
  {-# INLINE   [2]  f #-}  --    しない              する
  {-# INLINE   [~2] f #-}  --     する              しない
  {-# NOINLINE [2]  f #-}  --    しない           場合による
  {-# NOINLINE [~2] f #-}  --  場合による           しない

  {-# INLINE   f #-}       --     する               する
  {-# NOINLINE f #-}       --    しない             しない
</programlisting>
「場合による」というのは、インライン化についての通常のヒューリスティクス(関数本体が小さいなら、とか、興味深い見た目の引数に適用されているなら、など)が適用されるということである。この規則は次のように捉えることもできる。
<itemizedlist>
<listitem><para>INLINEとNOINLINEの両方について、段階番号はインライン化が少しでも許されるかどうかを言っている。</para></listitem>
<listitem><para>これに加えて、INLINEプラグマには、関数本体を小さく見せる効果がある。したがって、インライン化が許されているときには、インライン化が発生する可能性が極めて高い。
</para></listitem>
</itemizedlist>
</para>
<para>これと同じ段階番号制御はRULES(<xref linkend="rewrite-rules"/>)についても使える。</para>
      </sect3>
    </sect2>

    <sect2 id="line-pragma">
      <title>LINEプラグマ</title>

      <indexterm><primary>LINE</primary><secondary>pragma</secondary></indexterm>
      <indexterm><primary>pragma</primary><secondary>LINE</secondary></indexterm>
      <para>このプラグマはCの<literal>#line</literal>プラグマに似ていて、自動生成されたHaskellコードで使うことを主に意図したものである。これを使うと、元々のコードの行番号とファイル名を指定することができる。例えば、ファイルが、<filename>Foo.vhs</filename>というファイルから生成され、その行が元のファイルの42行目に当たるなら、以下のように書けば良い。</para>

<programlisting>{-# LINE 42 "Foo.vhs" #-}</programlisting>

      <para>エラーメッセージが報告されるとき、<literal>LINE</literal>プラグマで指定された行・ファイルを参照するようになる。</para>
    </sect2>

    <sect2 id="rules">
      <title>RULESプラグマ</title>

      <para>RULESプラグマを使うと書き換え規則を指定することができる。これは<xref linkend="rewrite-rules"/>で解説されている。</para>
    </sect2>

    <sect2 id="specialize-pragma">
      <title>SPECIALIZEプラグマ</title>

      <indexterm><primary>SPECIALIZE pragma</primary></indexterm>
      <indexterm><primary>pragma, SPECIALIZE</primary></indexterm>
      <indexterm><primary>overloading, death to</primary></indexterm>

      <para>(英式にSPECIALISEでも良い) 鍵となる多重定義関数について、特定の型に特殊化された版を作ることができる。(注意: コードサイズは増大する)。次のような多重定義関数があったとしよう。</para>

<programlisting>
  hammeredLookup :: Ord key => [(key, value)] -> key -> value
</programlisting>

      <para>この関数が、keyの型を<literal>Widget</literal>として特に良く使われるなら、次のようにして特殊化することができる。</para>

<programlisting>
  {-# SPECIALIZE hammeredLookup :: [(Widget, value)] -> Widget -> value #-}
</programlisting>

<itemizedlist>
<listitem>
      <para>関数についての<literal>SPECIALIZE</literal>プラグマは、その関数の型シグネチャが書けるところならどこにでも書ける。さらに、定義の地点で<literal>INLINABLE</literal>プラグマを与えられている(<xref linkend="inlinable-pragma"/>)関数であれば、<emphasis>インポートした</emphasis>関数を<literal>SPECIALIZE</literal>することができる。
      </para>

      <para><literal>SPECIALIZE</literal>の効果は、その関数の特殊化版を生成することと、およびその関数の未特殊化版の呼び出しを特殊化版の呼び出しに書き換える規則(<xref linkend="rewrite-rules"/>を見よ)を生成することである。さらに、関数<literal>f</literal>に<literal>SPECIALIZE</literal>が与えられていると、<literal>f</literal>によって呼ばれている(型クラスによる)多重定義関数全てについて、もしそれがこの<literal>SPECIALIZE</literal>プラグマと同じモジュールにあるか<literal>INLINABLE</literal>であるならば、GHCは自動的にそれの特殊化版を作る。これは推移的に繰り返される。</para>
</listitem>

<listitem>
   <para><literal>SPECIALIZE</literal>プラグマによって生成されたRULEに段階制御(<xref linkend="phase-control"/>)を付け加えることができる。RULEを直接書いた場合と全く同様である。例を示す。
<programlisting>
  {-# SPECIALIZE [0] hammeredLookup :: [(Widget, value)] -> Widget -> value #-}
</programlisting>
   これは、段階0(最後の段階)にのみ発火する特殊化規則を生成する。<literal>SPECIALIZE</literal>中に段階制御を指定しなかった場合、段階制御はその関数のインラインプラグマ(あれば)から継承される。例。
<programlisting>
  foo :: Num a => a -> a
  foo = ...blah...
  {-# NOINLINE [0] foo #-}
  {-# SPECIALIZE foo :: Int -> Int #-}
</programlisting>
  この<literal>NOINLINE</literal>は、段階0になるまで<literal>foo</literal>をインライン化しないようにGHCに指示する。そしてこの性質は特殊化規則に継承されるので、これも段階0にのみ発火する。</para>
  <para>特殊化に対して段階制御を使うことの主な理由は、まずコンパイルパイプラインの初期に発火する最適化RULESを書いて、<emphasis>その後で</emphasis>関数の呼び出しを特殊化できるからである。特殊化が行なわれるのが早すぎると最適化RULESが発火しないかもしれない。
  </para>
</listitem>
<listitem>
      <para>SPECIALIZEプラグマ中の型は元の関数の型より多相性が低いものならなんでも良い。ちゃんとした言い方では次のようになる。元の関数が<literal>f</literal>だとする。
<programlisting>
  {-# SPECIALIZE f :: &lt;type&gt; #-}
</programlisting>
      このプラグマが正当なのは、以下の定義が正当な時だけである。
<programlisting>
  f_spec :: &lt;type&gt;
  f_spec = f
</programlisting>
      いくつか例を示す。(元の関数については型シグネチャだけを示し、コードは省略した)
<programlisting>
  f :: Eq a => a -> b -> b
  {-# SPECIALISE f :: Int -> b -> b #-}

  g :: (Eq a, Ix b) => a -> b -> b
  {-# SPECIALISE g :: (Eq a) => a -> Int -> Int #-}

  h :: Eq a => a -> a -> a
  {-# SPECIALISE h :: (Eq a) => [a] -> [a] -> [a] #-}
</programlisting>
最後の例では、生成されたRULSの左辺がかなり複雑なものになる(試してみよ)ので、あまりうまく発動しないかもしれない。この手の特殊化を使うことがあったら、どの程度うまくいったか知らせてほしい。
</para>
</listitem>
</itemizedlist>

    <sect3 id="specialize-inline">
      <title>SPECIALIZE INLINE</title>

<para><literal>SPECIALIZE</literal>の後には<literal>INLINE</literal>か<literal>NOINLINE</literal>プラグマを続けることができる。さらに、<xref linkend="inline-noinline-pragma"/>にあるように段階を指定することもできる。このような<literal>INLINE</literal>プラグマはその関数の特殊化版(のみ)に影響し、その関数が再帰的であっても適用される。動機となる例はこれである。
<programlisting>
-- type-indexedな表現を持つ配列のGADT
data Arr e where
  ArrInt :: !Int -> ByteArray# -> Arr Int
  ArrPair :: !Int -> Arr e1 -> Arr e2 -> Arr (e1, e2)

(!:) :: Arr e -> Int -> e
{-# SPECIALISE INLINE (!:) :: Arr Int -> Int -> Int #-}
{-# SPECIALISE INLINE (!:) :: Arr (a, b) -> Int -> (a, b) #-}
(ArrInt _ ba)     !: (I# i) = I# (indexIntArray# ba i)
(ArrPair _ a1 a2) !: i      = (a1 !: i, a2 !: i)
</programlisting>
ここでは、<literal>(!:)</literal>は<literal>Arr e</literal>型の配列の添字演算を行う再帰関数である。<literal>(Int,Int)</literal>での<literal>(!:)</literal>の呼び出しを考えてみよう。二番目の特殊化が発動し、その特殊化された関数がインライン化される。それには<literal>(!:)</literal>の呼び出しが二つあり、どちらも<literal>Int</literal>型についてのものである。これらの呼び出しは両方とも最初の特殊化を発動させ、その本体も再びインライン化される。結果として、添字演算関数についての型によるアンロールができたことになる。</para>
<para><literal>INLINE</literal>プラグマにするのと同様に、段階制御(<xref linkend="phase-control"/>)を<literal>SPECIALISE INLINE</literal>プラグマに加えることができる。そうした場合、書き換え規則と、特殊化される関数のINLINE制御の両方に、同じ段階が使われる。</para>
<para>警告: <literal>SPECIALISE INLINE</literal>を非多相再帰な関数に対して使うと、GHCは発散する。</para>
</sect3>

<sect3><title>インポートした関数のSPECIALIZE</title>

<para>
一般に、<literal>SPECIALIZE</literal>プラグマは同じモジュールで定義された関数にのみ与え得る。しかし関数<literal>f</literal>がその定義場所で<literal>INLINABLE</literal>プラグマを与えられているなら、インポート先のモジュールで後から特殊化することができる(<xref linkend="inlinable-pragma"/>を見よ)。例を挙げる。
<programlisting>
module Map( lookup, blah blah ) where
  lookup :: Ord key => [(key,a)] -> key -> Maybe a
  lookup = ...
  {-# INLINABLE lookup #-}

module Client where
  import Map( lookup )

  data T = T1 | T2 deriving( Eq, Ord )
  {-# SPECIALISE lookup :: [(T,a)] -> T -> Maybe a
</programlisting>
ここで、<literal>lookup</literal>が<literal>INLINABLE</literal>と宣言されているが、この定義位置では<literal>T</literal>が存在しないので、これを<literal>T</literal>に関して特殊化することができない。代わりに、利用者のモジュールが<literal>T</literal>を定義して、<literal>lookup</literal>をその型に関して特殊化することができる。
</para>
<para>
さらに、<literal>Client</literal>をインポートする(あるいは推移的に、<literal>Client</literal>をインポートするモジュールをインポートする)全てのモジュールからは、この<literal>lookup</literal>の特殊化版が「見え」て、利用されることになる。各モジュールに<literal>SPECIALIZE</literal>プラグマを置く必要はない。
</para>
<para>
さらに、そもそも<literal>SPECIALIZE</literal>プラグマすら必要ないこともある。モジュールMをコンパイルする際、GHCの最適化器(-Oで)は、Mで定義された全ての最上位の多重定義関数について、Mで呼ばれている型に関して特殊化するかどうか検討する。<emphasis>加えて</emphasis>最適化器はMに<emphasis>インポートされた</emphasis><literal>INLINABLE</literal>の多重定義関数について、Mで呼ばれている型に関して特殊化するかどうか検討する。よってこの例では、以下のように、<literal>lookup</literal>を<literal>T</literal>型で呼ぶだけで十分だろう。
<programlisting>
module Client where
  import Map( lookup )

  data T = T1 | T2 deriving( Eq, Ord )

  findT1 :: [(T,a)] -> Maybe a
  findT1 m = lookup m T1   -- T型でのlookupの呼び出し
</programlisting>
しかし、このような呼び出しがないこともあるので、そういう場合にこのプラグマは便利になり得る。
</para>
</sect3>

<sect3><title>旧式のSPECIALIZE構文</title>

      <para>参考: 古いGHCでは、特定の型についての特殊化を自分で指定することができた。

<programlisting>
{-# SPECIALIZE hammeredLookup :: [(Int, value)] -> Int -> value = intLookup #-}
</programlisting>

      より一般的な<literal>RULES</literal>プラグマ(<xref linkend="rule-spec"/>を見よ)ができたので、この機能は削除された。</para>
</sect3>

    </sect2>

<sect2 id="specialize-instance-pragma">
<title>SPECIALIZE instanceプラグマ
</title>

<para>
<indexterm><primary>SPECIALIZE pragma</primary></indexterm>
<indexterm><primary>overloading, death to</primary></indexterm>
考え方は同じで、対象がインスタンス宣言になっただけである。例を示す。

<programlisting>
instance (Eq a) => Eq (Foo a) where {
   {-# SPECIALIZE instance Eq (Foo [(Int, Bar)]) #-}
   ... 通常と同じ ...
 }
</programlisting>
このプラグマはインスタンス宣言の<literal>where</literal>部に現れなければならない。
</para>
<para>
ところで、これはHBCと互換性がある。あるいはプラグマの配置場所については非互換かもしれないが。
</para>

</sect2>

    <sect2 id="unpack-pragma">
      <title>UNPACKプラグマ</title>

      <indexterm><primary>UNPACK</primary></indexterm>

      <para><literal>UNPACK</literal>は、コンパイラに対し、構築子フィールドの内容を構築子に直に収めることで、一段階の間接参照を排除することを指示するものである。例を示す。</para>

<programlisting>
data T = T {-# UNPACK #-} !Float
           {-# UNPACK #-} !Float
</programlisting>

      <para>これにより、二つの非ボックス化Floatを保持する構築子<literal>T</literal>ができる。これは常に最適化になっているとは限らない。例えば、構築子<function>T</function>の内容を調べて、そのfloatを非正格な関数に渡す場合、それらを再びボックス化しなければならない。(これはコンパイラによって自動的に行われる)</para>

      <para>構築子のアンパックは専ら<option>-O</option>と組み合わせて使われるべきである<footnote><para>実は、技術的な事情によりUNPACKプラグマは<option>-O</option>なしでは何もしない。(<ulink url="http://hackage.haskell.org/trac/ghc/ticket/5252">tick 5252</ulink>を見よ)</para></footnote>。再ボックス化をなるべく排除できるように展開候補をコンパイラに露出するためである。次の例を考える。</para>

<programlisting>
f :: T -&#62; Float
f (T f1 f2) = f1 + f2
</programlisting>

      <para>コンパイラは、floatについての<function>+</function>をインライン化することで、<function>f1</function>と<function>f2</function>を再ボックス化することを避けるが、これは<option>-O</option>が有効なときだけである。</para>

      <para>単一構築子のデータはどんなものでもアンパックし得る。</para>

<programlisting>
data T = T {-# UNPACK #-} !(Int,Int)
</programlisting>

      <para>この場合、構築子<function>T</function>は、対を平坦化して、二つの<literal>Int</literal>を直接保持することになる。複数水準のアンパックもサポートされている。

<programlisting>
data T = T {-# UNPACK #-} !S
data S = S {-# UNPACK #-} !Int {-# UNPACK #-} !Int
</programlisting>

      この場合、二つの非ボックス化<literal>Int#</literal>が構築子<function>T</function>に直接置かれる。アンパックはnewtypeを透過して起こる。</para>

      <para><option>-funbox-strict-fields</option>フラグも見よ。これは、簡単に言うと、あらゆる正格な構築子フィールドに<literal>{-#&nbsp;UNPACK&nbsp;#-}</literal>を加えるのと同じ効果がある。</para>
    </sect2>

    <sect2 id="nounpack-pragma">
      <title>NOUNPACKプラグマ</title>

      <indexterm><primary>NOUNPACK</primary></indexterm>

      <para><literal>NOUNPACK</literal>はコンパイラに、構築子フィールドの中身をアンパックするべきでないということを伝える。例。
      </para>
<programlisting>
data T = T {-# NOUNPACK #-} !(Int,Int)
</programlisting>
      <para>フラグ<option>-funbox-strict-fields</option>および<option>-O</option>を使っていても、構築子<function>T</function>のフィールドはアンパックされない。
      </para>
    </sect2>

    <sect2 id="source-pragma">
      <title>SOURCEプラグマ</title>

      <indexterm><primary>SOURCE</primary></indexterm>
     <para><literal>{-# SOURCE #-}</literal>は専ら<literal>import</literal>宣言の中で使われ、モジュールのループを断ち切る役割を果たす。詳しい説明は<xref linkend="mutual-recursion"/>にある。
     </para>
</sect2>

</sect1>

<!--  ======================= REWRITE RULES ======================== -->

<sect1 id="rewrite-rules">
<title>書き換え規則

<indexterm><primary>RULES pragma</primary></indexterm>
<indexterm><primary>pragma, RULES</primary></indexterm>
<indexterm><primary>rewrite rules</primary></indexterm></title>

<para>
プログラマは、ソースプログラムの一部として(プラグマで)書き換え規則を指定することができる。
以下に例を示す。

<programlisting>
  {-# RULES
  "map/map"    forall f g xs.  map f (map g xs) = map (f.g) xs
    #-}
</programlisting>
</para>
<para>
どの規則が発火したかを見るには<option>-ddump-simpl-stats</option>というデバッグフラグを使えばよい。もっと情報が必要な場合は、<option>-ddump-rule-firings</option>によって、個々の規則発火を見ることができるし、<option>-ddump-rule-rewrites</option>なら、書き換えの前と後でコードがどんな風であったかを見ることができる。
</para>

<sect2>
<title>構文</title>

<para>
構文の観点からは、以下がいえる。

<itemizedlist>

<listitem>
<para>
一つの<literal>RULES</literal>プラグマには零個以上の規則を書ける。規則の間はセミコロンで区切る。(このセミコロンはレイアウト規則によって生成されたものでもよい)
</para>
</listitem>

<listitem>
<para>
プラグマ内ではレイアウト規則が適用される。現在、新しいインデントの水準が設定されることはない。そのため、一つのRULESプラグマに複数の規則を書いて、レイアウトを使ってそれを区切りたい場合、外側の定義と同じ位置で開始するように配置しなければならない。
<programlisting>
  {-# RULES
  "map/map"    forall f g xs.  map f (map g xs) = map (f.g) xs
  "map/append" forall f xs ys. map f (xs ++ ys) = map f xs ++ map f ys
    #-}
</programlisting>
さらに、閉じ括弧<literal>#-}</literal>は開き括弧<literal>{-#</literal>よりも右で始まっているようにするべきである。
</para>
</listitem>

<listitem>
<para>
全ての規則には名前があり、二重引用符で囲って示される。名前自体には全く意味はない。規則が何回発動したかを報告する際に用いられるだけである。
</para>
</listitem>

<listitem>
<para>
規則名の直後に段階番号(<xref linkend="phase-control"/>を見よ)を書くこともできる。次のように。
<programlisting>
  {-# RULES
        "map/map" [2]  forall f g xs. map f (map g xs) = map (f.g) xs
    #-}
</programlisting>
ここでの「[2]」は、この規則が段階2以降(段階2を含む)で有効になることを意味している。逆の記法である「[~2]」を使うこともでき、規則が段階2まで有効(段階2自体は含まない)という意味である。
</para>
</listitem>

<listitem>
<para>
規則中で言及される変数は、スコープにある(<function>map</function>のように)か、<literal>forall</literal>で束縛される(<function>f</function>、<function>g</function>、<function>xs</function>のように)かのどちらかでなければならない。<literal>forall</literal>で束縛された変数は<emphasis>パターン</emphasis>変数と呼ばれる。パターン変数は、型の<literal>forall</literal>の場合と同じく、空白で区切る。
</para>
</listitem>
<listitem>

<para>
パターン変数には型シグネチャをつけても良い。パターン変数の型が多相的なら、その変数には型シグネチャが<emphasis>必須</emphasis>である。例えば、以下は<literal>foldr/build</literal>規則である。

<programlisting>
"fold/build"  forall k z (g::forall b. (a->b->b) -> b -> b) .
              foldr k z (build g) = g k z
</programlisting>

<function>g</function>の型は多相的なので、型シグネチャを与える必要がある。

</para>
</listitem>
<listitem>

<para>
規則の左辺は、最上位の変数を任意の式に適用したものでなければならない。例えば、以下のものは正しく<emphasis>ない</emphasis>。

<programlisting>
"wrong1"   forall e1 e2.  case True of { True -> e1; False -> e2 } = e1
"wrong2"   forall f.      f True = True
</programlisting>

<literal>"wrong1"</literal>では、左辺が適用でない。<literal>"wrong2"</literal>では、左辺の先頭がパターン変数である。
</para>
</listitem>
<listitem>

<para>
規則は、それが言及する変数(のどれか)と同じモジュールにある必要はない。もちろん、それらはスコープになければならないが。
</para>
</listitem>
<listitem>

<para>
規則は全て暗黙にモジュールからエクスポートされ、したがって規則を定義したモジュールを直接または間接にインポートしたモジュールの全てで有効である。(つまり、AがBをインポートしていて、BがCをインポートしている場合、AをコンパイルするときにCの規則が有効である)この状況はインスタンス宣言の場合と非常に良く似ている。
</para>
</listitem>

<listitem>

<para>
RULEの内部において、「<literal>forall</literal>」は他のフラグ設定の如何にかかわらずキーワードとして扱われる。さらに、RULE内部では、言語拡張<option>-XScopedTypeVariables</option>が自動的に有効になる。<xref linkend="scoped-type-variables"/>を見よ。
</para>
</listitem>
<listitem>

<para>
他のプラグマと同様、RULEプラグマは常にスコープの誤りを検査され、型検査される。型検査というのは、規則の左辺と右辺が型検査され、さらに同じ型でなければならないということである。しかし、規則が<emphasis>有効になる</emphasis>のは<option>-fenable-rewrite-rules</option>フラグが有効な時だけである(<xref linkend="rule-semantics"/>を見よ)。
</para>
</listitem>

</itemizedlist>

</para>

</sect2>

<sect2 id="rule-semantics">
<title>意味論</title>

<para>
意味論の観点からは以下のことが言える。

<itemizedlist>
<listitem>

<para>
規則は<option>-fenable-rewrite-rules</option>フラグによって有効になる(つまり、最適化に使われる)。このフラグは<option>-O</option>によって有効になり、(いつも通り)<option>-fno-enable-rewrite-rules</option>で解除できる。(注意: 一方、<option>-O</option>なしで<option>-fenable-rewrite-rules</option>を有効にしても期待通りにはならないかもしれない。なぜなら<option>-O</option>なしではGHCはインタフェースファイル中の全ての最適化情報を無視するからである。<option>-fignore-interface-pragmas</option>、<xref linkend="options-f"/>を見よ。)<option>-fenable-rewrite-rules</option>は<emphasis>最適化</emphasis>フラグであって、パースや型検査には効果を及ぼさないことに注意。
</para>
</listitem>

<listitem>
<para>
規則は左から右への書き換えの規則だとみなされる。規則の左辺の置換例であるような式が見付かると、その式は右辺(に適切な置換を施したもの)に置き換えられる。「置換例」というのは、左辺に、パターン変数について置換を施すことで、その式と等しくすることができる、という意味である。

</para>
</listitem>
<listitem>

<para>
規則の左辺と右辺が同じ意味かどうかについては、GHCは一切検証を試みない。これは一般的には決定不能であるし、興味深い場合について実行不可能である。これについて、責任は完全にプログラマにある。

</para>
</listitem>
<listitem>

<para>
GHCは規則が合流性や停止性を持つことを確かめようとはしない。例。

<programlisting>
  "loop"        forall x y.  f x y = f y x
</programlisting>

この規則はコンパイラを無限ループさせる。

</para>
</listitem>
<listitem>

<para>
一つの呼び出しに複数の規則が適合する場合は、恣意的に一つが選ばれる。

</para>
</listitem>
<listitem>
<para>
現在、GHCでは、規則の左辺を式と照合するに当たって、非常に単純で構文的な照合アルゴリズムが使われている。左辺と式を、α変換を法として構文的に等しくするような置換を探すのである。パターン(規則)は必要ならη展開されるが、式はされない。(式をη展開すると遅延性にかかわるバグにつながる)。また、β変換(高階照合と呼ばれる)は行わない。
</para>

<para>
照合はGHCの中間言語で行われる。この言語には型抽象と型適用があるので、規則は型が合うときのみ適合する。下の<xref linkend="rule-spec"/>を見よ。
</para>
</listitem>
<listitem>

<para>
GHCは、最適化過程において、常に規則を適用しようとする。例として以下のものを考えてみよう。

<programlisting>
  let s = map f
      t = map g
  in
  s (t xs)
</programlisting>

式<literal>s (t xs)</literal>は規則<literal>"map/map"</literal>に適合しないが、GHCは<varname>s</varname>と<varname>t</varname>を置換するので、結果として適合する式ができる。<varname>s</varname>や<varname>t</varname>が(a)二度以上使われていて、かつ(b)大きかったり簡約項だったりする、場合は、これらは置換されないので、規則が発動することもない。

</para>
</listitem>
</itemizedlist>

</para>

</sect2>

<sect2 id="conlike">
<title>書き換え規則と、INLINE/NOINLINEおよびCONLIKEプラグマとの間の相互作用</title>

<para>
通常のインライン化は規則による書き換えと同時に起きる。これによって予期せぬ結果につながることがある。次の(人為的な)例を考えよ。
<programlisting>
f x = x
g y = f y
h z = g True

{-# RULES "f" f True = False #-}
</programlisting>
<literal>f</literal>の右辺は小さいので、<literal>g</literal>へとインライン化され、次のような結果になる。
<programlisting>
g y = y
</programlisting>

次に<literal>g</literal>が<literal>h</literal>へとインライン化されるが、<literal>f</literal>のRULEが発火する機会はない。GHCが逆にまず<literal>g</literal>を<literal>h</literal>へとインライン化していたら、<literal>f</literal>のRULEが発火する機会はより大きかっただろう。
</para>
<para>
振る舞いを予測可能にするには、<literal>f</literal>にNOINLINEプラグマかINLINE[<replaceable>phase</replaceable>]プラグマを使って、RULEに発火の機会があるうちにインライン化されることがないようにすれば良い。
</para>
<para>
GHCは、仕事を複製することに関して非常に慎重である。例として次を考えよ。
<programlisting>
f k z xs = let xs = build g
           in ...(foldr k z xs)...sum xs...
{-# RULES "foldr/build" forall k z g. foldr k z (build g) = g k z #-}
</programlisting>
<literal>xs</literal>が二回使われているので、GHCはfold/build規則を発火しない。これは正しい動作である。なぜなら、<literal>xs</literal>を計算するのに大量の作業が必要かもしれず、規則が発火したらその作業が複製されるからである。</para>
<para>
しかし、場合によっては、この方針では慎重すぎることがある。例え簡約基を複製することになっても、規則に発火してもらいたい場合である。これが良案だということをGHCが見つけ出す方法はないので、そのことを宣言するためのCONLIKEプラグマを提供している。次のようにする。
<programlisting>
{-# INLINE[1] CONLIKE f #-}
f x = <replaceable>blah</replaceable>
</programlisting>
CONLIKEは、INLINEまたはNOINLINEプラグマに対する修飾子である。fを一つの引数(一般には、'='記号の左側にある引数の数)に適用することが十分低コストで、複製によって規則が発火するならば複製できる、ということを示す。(「CONLIKE」という名前は"constructor-like"の短縮形である。構築子(constructor)は確実にこの性質を持つので) CONLIKEプラグマはINLINE/NOINLINEの修飾子であるが、これは次のような事情による。すなわち、規則が発火する前に<literal>f</literal>がインライン化されてしまわないことがはっきりしているのでない限り、<literal>f</literal>を規則の左辺と照合するのは実際上意味がないからである。
</para>
</sect2>

<sect2>
<title>リストの融合変換</title>

<para>
RULES機構は、良く使われるリスト関数についての融合変換(伐採)を実装するのに使われている。「優良生産者」の構築した中間リストを「優良消費者」が消費する場合、このリストは完全に排除されるはずである。
</para>

<para>
以下のものが優良生産者である。

<itemizedlist>
<listitem>

<para>
リスト内包表記
</para>
</listitem>
<listitem>

<para>
<literal>Int</literal>および<literal>Integer</literal>および<literal>Char</literal>についての列挙(例えば<literal>['a'..'z']</literal>)。
</para>
</listitem>
<listitem>

<para>
明示的なリスト(例: <literal>[True, False]</literal>)
</para>
</listitem>
<listitem>

<para>
cons構築子(例: <literal>3:4:[]</literal>)
</para>
</listitem>
<listitem>

<para>
 <function>++</function>
</para>
</listitem>

<listitem>
<para>
 <function>map</function>
</para>
</listitem>

<listitem>
<para>
<function>take</function>, <function>filter</function>
</para>
</listitem>
<listitem>

<para>
 <function>iterate</function>, <function>repeat</function>
</para>
</listitem>
<listitem>

<para>
 <function>zip</function>, <function>zipWith</function>
</para>
</listitem>

</itemizedlist>

</para>

<para>
以下は優良消費者である。

<itemizedlist>
<listitem>

<para>
リスト内包表記
</para>
</listitem>
<listitem>

<para>
 <function>array</function> (第二引数について)
</para>
</listitem>
<listitem>

<para>
 <function>++</function> (第一引数について)
</para>
</listitem>

<listitem>
<para>
 <function>foldr</function>
</para>
</listitem>

<listitem>
<para>
 <function>map</function>
</para>
</listitem>
<listitem>

<para>
<function>take</function>, <function>filter</function>
</para>
</listitem>
<listitem>

<para>
 <function>concat</function>
</para>
</listitem>
<listitem>

<para>
 <function>unzip</function>, <function>unzip2</function>, <function>unzip3</function>, <function>unzip4</function>
</para>
</listitem>
<listitem>

<para>
 <function>zip</function>, <function>zipWith</function> (ただし引数一つについてのみ。両方が優良生産者の場合、<function>zip</function>は片方のみと融合する)
</para>
</listitem>
<listitem>

<para>
 <function>partition</function>
</para>
</listitem>
<listitem>

<para>
 <function>head</function>
</para>
</listitem>
<listitem>

<para>
 <function>and</function>, <function>or</function>, <function>any</function>, <function>all</function>
</para>
</listitem>
<listitem>

<para>
 <function>sequence&lowbar;</function>
</para>
</listitem>
<listitem>

<para>
 <function>msum</function>
</para>
</listitem>

</itemizedlist>

</para>

 <para>
 よって、例えば以下のものは中間リストを生成しないはずである。

<programlisting>
array (1,10) [(i,i*i) | i &#60;- map (+ 1) [0..9]]
</programlisting>

</para>

<para>
この一覧を拡張することはいつでもできる。良く使うPrelude関数でここに含まれていないものがあったら教えてほしい。
</para>

<para>
自分で優良生産者や優良消費者を書きたいときは、上の関数のPreludeでの定義を見てどうするか知ると良い。
</para>

</sect2>

<sect2 id="rule-spec">
<title>特殊化
</title>

<para>
書き換え規則を使って、GHCの昔の版で使えた、ある機能と同等のことを行える。例として、以下のものを考えよ。

<programlisting>
genericLookup :: Ord a => Table a b   -> a   -> b
intLookup     ::          Table Int b -> Int -> b
</programlisting>

ここで、<function>intLookup</function>は、キーが<literal>Int</literal>の時に非常に高速に動作する<function>genericLookup</function>の実装である。<function>genericLookup</function>が型<literal>Table Int b -&gt; Int -&gt; b</literal>で呼ばれたときは代わりに<function>intLookup</function>を使うようにさせたいと思うかもしれない。次のように書くことが可能だった。

<programlisting>
{-# SPECIALIZE genericLookup :: Table Int b -> Int -> b = intLookup #-}
</programlisting>

この機能はもはやGHCにはないが、書き換え規則を使って同等のことができる。

<programlisting>
{-# RULES "genericLookup/Int" genericLookup = intLookup #-}
</programlisting>

この少々奇妙な規則は、<function>genericLookup</function>を<function>intLookup</function>に、<emphasis>型が適合するときはいつでも</emphasis>置き換えるように指示するものである。さらに、<literal>SPECIALIZE</literal>プラグマの場合と違って、この規則は<function>genericLookup</function>と同じモジュールにある必要がない。(<literal>SPECIALIZE</literal>プラグマの場合は、特殊化するのに元の定義が必要である)
</para>

<para><function>intLookup</function>がちゃんと<function>genericLookup</function>の特別な場合として振る舞うようにするのは<emphasis>あなたの責任</emphasis>である！！！</para>

<para><literal>RULES</literal>を使った特殊化が高い効果をあげる例を一つ挙げる。

<programlisting>
toDouble :: Real a => a -> Double
toDouble = fromRational . toRational

{-# RULES "toDouble/Int" toDouble = i2d #-}
i2d (I# i) = D# (int2Double# i) -- Glasgowのprim-opを直接使う
</programlisting>

<function>i2d</function>関数は、事実上、機械語命令一個である。これに比べると、<literal>Rational</literal>を経由した通常の変換は、非常識なまでに効率が悪い。
</para>

</sect2>

<sect2 id="controlling-rules">
<title>書き換え規則の中で何が起こるか制御する</title>

<para>

<itemizedlist>
<listitem>

<para>
<emphasis>このモジュールで</emphasis>定義された規則を見るには、<option>-ddump-rules</option>を使う。これには特殊化過程で生成されたものも含むが、他モジュールからインポートされたものは除外される。
</para>
</listitem>

<listitem>
<para>
どの規則が発動したかを知るには<option>-ddump-simpl-stats</option>を使う。<option>-dppr-debug</option>も加えればより詳細な出力が得られる。</para>
</listitem>

<listitem>
<para><option>-ddump-rule-firings</option>や<option>-ddump-rule-rewrites</option>を使うと、どの規則が発火したかを極めて詳細に見ることができる。<option>-dppr-debug</option>を加えるとさらに詳細な一覧が得られる。
</para>
</listitem>

<listitem>
<para>
例えば、<filename>GHC/Base.lhs</filename>の<function>build</function>の定義は以下の様になっている。

<programlisting>
        build   :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
        {-# INLINE build #-}
        build g = g (:) []
</programlisting>

<literal>INLINE</literal>が使われていることに注意。これのおかげで、<literal>PrelBase</literal>をコンパイルするときに<literal>(:)</literal>がインライン化されることがなく、結果としてインポート元のモジュールが<literal>(:)</literal>を「見る」ことができ、これを規則の左辺に適合させることができる。<literal>INLINE</literal>があると、その<literal>INLINE</literal>なものの右辺にインライン化が発生することが抑制される。私はこの気遣いを後悔している。

</para>
</listitem>
<listitem>

<para>
融合変換を行い、融合が起こらなかった場合でも効率的なプログラムになるような規則の書き方については<filename>libraries/base/GHC/Base.lhs</filename>にある<function>map</function>の規則を見よ。<filename>GHC/List.lhs</filename>にも規則がある。
</para>
</listitem>

</itemizedlist>

</para>

</sect2>

<sect2 id="core-pragma">
  <title>COREプラグマ</title>

  <indexterm><primary>CORE pragma</primary></indexterm>
  <indexterm><primary>pragma, CORE</primary></indexterm>
  <indexterm><primary>core, annotation</primary></indexterm>

<para>
  外部コア形式は「Note」注釈をサポートしている。<literal>CORE</literal>プラグマを使うと、どういう注釈を入れるかをHaskellコード中で指定することができる。構文的には、core注釈は式に付属し、Haskellの文字列リテラルを引数として取る。以下の関数定義が例である。

<programlisting>
f x = ({-# CORE "foo" #-} show) ({-# CORE "bar" #-} x)
</programlisting>

意味上は、これは以下のものに等しい。

<programlisting>
g x = show x
</programlisting>
</para>

<para>
しかし、(<option>-fext-core</option>で)外部coreが生成されるとき、式<function>show</function>と<varname>x</varname>にNoteが付加される。<function>f</function>のcoreでの宣言は以下である。
</para>

<programlisting>
  f :: %forall a . GHCziShow.ZCTShow a ->
                   a -> GHCziBase.ZMZN GHCziBase.Char =
    \ @ a (zddShow::GHCziShow.ZCTShow a) (eta::a) ->
        (%note "foo"
         %case zddShow %of (tpl::GHCziShow.ZCTShow a)
           {GHCziShow.ZCDShow
            (tpl1::GHCziBase.Int ->
                   a ->
                   GHCziBase.ZMZN GHCziBase.Char -> GHCziBase.ZMZN GHCziBase.Char)
            (tpl2::a -> GHCziBase.ZMZN GHCziBase.Char)
            (tpl3::GHCziBase.ZMZN a ->
                   GHCziBase.ZMZN GHCziBase.Char -> GHCziBase.ZMZN GHCziBase.Char) ->
              tpl2})
        (%note "bar"
         eta);
</programlisting>

<para>
ここで、関数<function>show</function>(これは展開されてShow辞書についてのcase式になっている)に<literal>%note</literal>が付属していることが分かる。<varname>eta</varname>(<varname>x</varname>という名前だったもの)も同様である。
</para>

</sect2>

</sect1>

<sect1 id="special-ids">
<title>特殊な組込み関数</title>
<para>GHCには特殊な振る舞いをする組込み関数が少々ある。これらはライブラリ説明書の<ulink url="&libraryGhcPrimLocation;/GHC-Prim.html"><literal>GHC.Prim</literal></ulink>モジュールに解説がある。特に、
<itemizedlist>
<listitem><para>
<ulink url="&libraryGhcPrimLocation;/GHC-Prim.html#v%3Ainline"><literal>inline</literal></ulink>は、個々の呼び出し地点ごとにインライン化を制御できる。
</para></listitem>
<listitem><para>
<ulink url="&libraryGhcPrimLocation;/GHC-Prim.html#v%3Alazy"><literal>lazy</literal></ulink>は正格性解析器を抑制する。
</para></listitem>
<listitem><para>
<ulink url="&libraryGhcPrimLocation;/GHC-Prim.html#v%3AunsafeCoerce%23"><literal>unsafeCoearce</literal></ulink>は、型検査器を欺くことを可能にする。
</para></listitem>
</itemizedlist>
</para>
</sect1>


<sect1 id="generic-classes">
<title>総称クラス</title>

<para>過去にGHCは総称クラスの実装を持っていた。これは論文"Derivable type classes", Ralf Hinze and Simon Peyton Jones, Haskell Workshop, Montreal Sept 2000, pp94-105で定義されている。これは削除され、もっと一般的な<link linkend="generic-programming">総称プログラミングのサポート</link>が代わりとなった。</para>

</sect1>


<sect1 id="generic-programming">
<title>総称プログラミング</title>

<para>
<option>-XDeriveGeneric</option>(<xref linkend="deriving-typeable"/>)と<option>-XDefaultSignatures</option> (<xref linkend="class-default-signatures"/>)を組み合わせることで、データ型について総称的なプログラミングを<literal>GHC.Generics</literal>を使って簡単に行なえる。この節は、その方法について極めて短かい概観を与える。</para>

<para>
GHCにおける総称プログラミングでは、ユーザがインスタンスを作成する際にメソッドを指定する必要がないようなクラスを定義することが可能になる。メソッド本体はGHCによって自動的に導出される。これは例えば<literal>Read</literal>や<literal>Show</literal>などの標準クラスの事情に似ているが、ユーザ定義のクラスについでである。</para>

<sect2>
<title>表現を導出する</title>

<para>
まず必要なのは総称的な型表現である。<literal>GHC.Generics</literal>には数個の基本的な型が定義されていて、これらを使ってHaskellのデータ型を表現することができる。

<programlisting>
-- | 単位: 引数のない構築子に使われる
data U1 p = U1

-- | 定数、追加のパラメタ、種*の再帰
newtype K1 i c p = K1 { unK1 :: c }

-- | メタ情報 (構築子名など)
newtype M1 i c f p = M1 { unM1 :: f p }

-- | 和: 構築子間での選択をエンコードする
infixr 5 :+:
data (:+:) f g p = L1 (f p) | R1 (g p)

-- | 積: 構築子への複数の引数をエンコードする
infixr 6 :*:
data (:*:) f g p = f p :*: g p
</programlisting>
</para>

<para>
<literal>Generic</literal>クラスおよび<literal>Generic1</literal>クラスは、ユーザ定義のデータ型と、それの積和形(sum-of-products)の内部表現との間の仲介を行なう。

<programlisting>
class Generic a where
  -- ユーザのデータ型の表現をエンコードする
  type Rep a :: * -> *
  -- データ型をその表現に変換する
  from  :: a -> (Rep a) x
  -- 表現をデータ型に変換する
  to    :: (Rep a) x -> a

class Generic1 f where
  type Rep1 f :: * -> *

  from1  :: f a -> Rep1 f a
  to1    :: Rep1 f a -> f a
</programlisting>

<literal>Generic1</literal>は、 <literal>map</literal>のように型コンテナについてのみ定義できる関数に使われる。総称的なインスタンスを自動的に定義するにはこれらのクラスのインスタンスが必要であり、これは<option>-XDeriveGeneric</option> (<xref linkend="deriving-typeable"/>)を付けるとGHCによって自動導出できる。</para>

<para>
例えば、木のユーザ定義データ型<literal>data UserTree a = Node a (UserTree a) (UserTree a) | Leaf</literal>は以下の表現を得る。

<programlisting>
instance Generic (UserTree a) where
  -- 表現型
  type Rep (UserTree a) =
    M1 D D1UserTree (
          M1 C C1_0UserTree (
                M1 S NoSelector (K1 R a)
            :*: M1 S NoSelector (K1 R (UserTree a))
            :*: M1 S NoSelector (K1 R (UserTree a)))
      :+: M1 C C1_1UserTree U1)

  -- 変換関数
  from (Node x l r) = M1 (L1 (M1 (M1 (K1 x) :*: M1 (K1 l) :*: M1 (K1 r))))
  from Leaf         = M1 (R1 (M1 U1))
  to (M1 (L1 (M1 (M1 (K1 x) :*: M1 (K1 l) :*: M1 (K1 r))))) = Node x l r
  to (M1 (R1 (M1 U1)))                                      = Leaf

-- メタ情報
data D1UserTree
data C1_0UserTree
data C1_1UserTree

instance Datatype D1UserTree where
  datatypeName _ = "UserTree"
  moduleName _   = "Main"

instance Constructor C1_0UserTree where
  conName _ = "Node"

instance Constructor C1_1UserTree where
  conName _ = "Leaf"
</programlisting>

この表現は、<literal>deriving Generic</literal>がデータ型に付属していれば自動的に生成される。<link linkend="stand-alone-deriving">独立deriving</link>も使える。</para>

</sect2>

<sect2>
<title>総称関数を書く</title>

<para>
総称関数は、クラスを作り、<literal>GHC.Generics</literal>の各表現型についてインスタンスを与えることで定義できる。例として総称的な直列化を示す。
<programlisting>
data Bin = O | I

class GSerialize f where
  gput :: f a -> [Bin]

instance GSerialize U1 where
  gput U1 = []

instance (GSerialize a, GSerialize b) => GSerialize (a :*: b) where
  gput (x :*: y) = gput x ++ gput y

instance (GSerialize a, GSerialize b) => GSerialize (a :+: b) where
  gput (L1 x) = O : gput x
  gput (R1 x) = I : gput x

instance (GSerialize a) => GSerialize (M1 i c a) where
  gput (M1 x) = gput x

instance (Serialize a) => GSerialize (K1 i a) where
  gput (K1 x) = put x
</programlisting>

このクラスは表現型以外に関するインスタンスを持っても意味がないので、典型的にはエクスポートされない。
</para>
</sect2>

<sect2>
<title>総称的デフォルト</title>

<para>
あとは、ユーザに露出される「フロントエンド」クラスを定義するだけである。
<programlisting>
class Serialize a where
  put :: a -> [Bin]

  default put :: (Generic a, GSerialize (Rep a)) => a -> [Bit]
  put = gput . from
</programlisting>
ここでは、<link linkend="class-default-signatures">デフォルトシグネチャ</link>を使って、インスタンスとなる型に<literal>Generic</literal>インスタンスがある限り、ユーザが<literal>put</literal>の実装を提供する必要がないということを指定している。例えば、<literal>UserTree</literal>型に関しては、ユーザは単に次のように書くことができる。

<programlisting>
instance (Serialize a) => Serialize (UserTree a)
</programlisting>

すると<literal>put</literal>のデフォルトメソッド(これは直列化の総称実装に対応する)が使われる。もっと多くの総称関数の例がHackageの<ulink url="http://hackage.haskell.org/package/generic-deriving">generic-deriving</ulink>パッケージにあるので参照して欲しい。
</para>
</sect2>

<sect2>
<title>さらなる情報</title>

<para>
さらなる詳細については、<ulink url="http://www.haskell.org/haskellwiki/GHC.Generics">HaskellWikiのページ</ulink>か以下の元論文を参照せよ。
</para>

<itemizedlist>
<listitem>
<para>
Jose Pedro Magalhaes, Atze Dijkstra, Johan Jeuring, and Andres Loeh.
<ulink url="http://dreixel.net/research/pdf/gdmh.pdf">
  A generic deriving mechanism for Haskell</ulink>.
<citetitle>Proceedings of the third ACM Haskell symposium on Haskell</citetitle>
(Haskell'2010), pp. 37-48, ACM, 2010.
</para>
</listitem>
</itemizedlist>

</sect2>

</sect1>


<sect1 id="monomorphism">
<title>単相性の制御</title>

<para>
letおよびwhere束縛での一般化の扱いに関わるフラグが二つある。
</para>

<sect2>
<title>恐怖の単相性限定を無効にする</title>
          <indexterm><primary><option>-XNoMonomorphismRestriction</option></primary></indexterm>

<para>Haskellの単相性限定(Haskellレポートの<ulink url="http://www.haskell.org/onlinereport/decls.html#sect4.5.5">4.5.5節</ulink>(<ulink url="http://www.sampou.org/haskell/report-revised-j/decls.html#sect4.5.5">和訳</ulink>)を見よ)は、<option>-XNoMonomorphismRestriction</option>で完全に無効にできる。
</para>
</sect2>

<sect2>
<title>単相的パターン束縛</title>
          <indexterm><primary><option>-XNoMonoPatBinds</option></primary></indexterm>
          <indexterm><primary><option>-XMonoPatBinds</option></primary></indexterm>

	  <para>実験的な変更として、我々はパターン束縛を単相的にする可能性を探っている。単相的というのは、全く一般化されないということである。パターン束縛とは、左辺に関数引数がなく、かつ、左辺が単純な変数でないものである。例を示す。
<programlisting>
  f x = x                    -- パターン束縛ではない
  f = \x -> x                -- パターン束縛ではない
  f :: Int -> Int = \x -> x  -- パターン束縛ではない

  (g,h) = e                  -- パターン束縛
  (f) = e                    -- パターン束縛
  [x] = e                    -- パターン束縛
</programlisting>
実験的に、GHCは<emphasis>デフォルトで</emphasis>パターン束縛を単相的にする。標準の振る舞いに戻すには<option>-XNoMonoPatBinds</option>を使うこと。
</para>
</sect2>
</sect1>


<!-- Emacs stuff:
     ;;; Local Variables: ***
     ;;; sgml-parent-document: ("users_guide.xml" "book" "chapter" "sect1") ***
     ;;; ispell-local-dictionary: "british" ***
     ;;; End: ***
 -->

