<?xml version="1.0" encoding="UTF-8"?>
<para>
<indexterm><primary>language, GHC</primary></indexterm>
<indexterm><primary>extensions, GHC</primary></indexterm>
既知のHaskell処理系はどれもそうだが、GHCもいくつかの言語拡張を実装している。これらはオプションが指定されたときのみ有効になる。デフォルトでGHCが理解するのは素のHaskell 98だけである。
</para>

<para>
グラスゴー拡張の中には、Haskellを実装するのに使われている基礎となる機能に触れるようにするものがある。よって、可搬性のないコードを原始的な水準で書くつもりがあるなら、生の部分を操作することができる。効率を追求するとき、Haskellの高水準な機能の実装コストのせいで行き詰まる必要はない。常にそれらの機能の「下」でコードを書けるからである。極端な場合、速度が重要な部分は全てCで書き、それをあとでHaskellと合わせる、ということもできる。</para>

<para>
最低水準での作業に没頭する(例えば、至るところで<literal>MutableByteArray#</literal>を使ったり)前に、必要な機能に「Haskellらしい被覆」を被せるライブラリがないか確かめた方が良いだろう。<ulink url="../libraries/index.html">ライブラリ説明書</ulink>(訳注: 未訳。<ulink url="http://www.haskell.org/ghc/docs/latest/html/libraries/">web上の最新版</ulink>)にはGHC付属のライブラリが全て説明されている。
</para>

<!-- LANGUAGE OPTIONS -->
  <sect1 id="options-language">
    <title>言語オプション</title>

    <indexterm><primary>language</primary><secondary>option</secondary>
    </indexterm>
    <indexterm><primary>options</primary><secondary>language</secondary>
    </indexterm>
    <indexterm><primary>extensions</primary><secondary>options controlling</secondary>
    </indexterm>

    <para>言語オプションのフラグは、言語のどの変種が許されるか制御するものである。これらを一つも使わない場合は、標準のHaskell 98になる。</para>

    <para>一般的に、全ての言語オプションは「<option>-X</option>」で始まる。例えば<option>-XTemplateHaskell</option>のように。</para>

   <para>言語オプションは全て、「<option>No</option>」を前置することによって無効にすることができる。例えば「<option>-XNoTemplateHaskell</option>」のように。</para>

   <para>Cabalが認識する言語オプションは<literal>LANGUAGE</literal>プラグマを使って有効にすることもできる。<literal>{-# LANGUAGE TemplateHaskell #-}</literal>のように。(<xref linkend="language-pragma"/>を見よ)</para>

    <para><option>-fglasgow-exts</option><indexterm><primary><option>-fglasgow-exts</option></primary></indexterm>フラグは、以下の拡張を有効にするのと同じである。<option>-XPrintExplicitForalls</option>、<option>-XForeignFunctionInterface</option>、<option>-XUnliftedFFITypes</option>、<option>-XGADTs</option>、<option>-XImplicitParams</option>、<option>-XScopedTypeVariables</option>、<option>-XUnboxedTuples</option>、<option>-XTypeSynonymInstances</option>、<option>-XStandaloneDeriving</option>、<option>-XDeriveDataTypeable</option>、<option>-XFlexibleContexts</option>、<option>-XFlexibleInstances</option>、<option>-XConstrainedClassMethods</option>、<option>-XMultiParamTypeClasses</option>、<option>-XFunctionalDependencies</option>、<option>-XMagicHash</option>、<option>-XPolymorphicComponents</option>、<option>-XExistentialQuantification</option>、<option>-XUnicodeSyntax</option>、<option>-XPostfixOperators</option>、<option>-XPatternGuards</option>、<option>-XLiberalTypeSynonyms</option>、<option>-XRankNTypes</option>、<option>-XImpredicativeTypes</option>、<option>-XTypeOperators</option>、<option>-XRecursiveDo</option>、<option>-XParallelListComp</option>、<option>-XEmptyDataDecls</option>、<option>-XKindSignatures</option>、<option>-XGeneralizedNewtypeDeriving</option>、<option>-XTypeFamilies</option>。<option>-fglasgow-exts</option>の効果は、これらのオプションを有効にすること<emphasis>だけ</emphasis>である。我々はこの多目的フラグをやめて、機能を個別に有効にする方向に移行しようとしている。</para>

  </sect1>

<!-- UNBOXED TYPES AND PRIMITIVE OPERATIONS -->
<sect1 id="primitives">
  <title>非ボックス化型とプリミティブ演算</title>

<para>GHCは大量のプリミティブなデータ型と演算を基礎としている。(「プリミティブ」だというのは、Haskell自体では定義できないという意味である)。高速なコードを書くためにこれらを使うこともできるが、高水準の言語機能やライブラリを使った方が、通常はずっと苦痛が少なく、長期的に見て良い結果になる。運が良ければ、書いたコードは最適化されて、結局、効率的な非ボックス化版になる。もしそうならないときは知らせてほしい。</para>

<para>これらのプリミティブなデータ型と演算は全て<literal>GHC.Prim</literal>というライブラリからエクスポートされている。これには<ulink url="../libraries/base/GHC.Prim.html">詳細なオンライン説明書</ulink>(訳注: 未訳。<ulink url="http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim/GHC-Prim.html">web上の最新版</ulink>)がある。(この説明書は<filename>compiler/prelude/primops.txt.pp</filename>というファイルから生成されている)</para>
<para>プログラム中でプリミティブなデータ型や演算に言及したいなら、まず<literal>GHC.Prim</literal>をインポートしてそれらをスコープに導入しなければならない。多くは「&num;」で終わる名前を持っているので、そのようなものに言及するには拡張<option>-XMagicHash</option>(<xref linkend="magic-hash"/>)が必要である。
</para>

<para>プリミティブ演算は広範にわたって<link linkend="glasgow-unboxed">非ボックス化型</link>と<link linkend="unboxed-tuples">非ボックス化タプル</link>を使っている。ここではこれらについて短くまとめる。</para>
  
<sect2 id="glasgow-unboxed">
<title>非ボックス化型
</title>

<para>
<indexterm><primary>Unboxed types (Glasgow extension)</primary></indexterm>
</para>

<para>GHCにおいて、大部分の型は<firstterm>ボックス化</firstterm>されている。つまり、その型の値はヒープ中オブジェクトへのポインタで表現されている。例えば、Haskellの<literal>Int</literal>の表現は、二ワードのヒープ中オブジェクトである。一方、<firstterm>非ボックス化</firstterm>型は、値そのものによって表現され、ポインタやヒープ確保とは無関係である。</para>

<para>
非ボックス化型は、Cで使う「生の機械上の」型に相当する。<literal>Int&num;</literal> (long int)、<literal>Double&num;</literal> (double)、<literal>Addr&num;</literal> (void *)などである。これらの型の上の<emphasis>プリミティブ演算</emphasis>(PrimOp)は予想される通りのものである。例えば、<literal>(+&num;)</literal>は<literal>Int&num;</literal>についての加算であり、我々が皆愛する機械上の加算(通常一命令)である。</para>

<para>
プリミティブな(非ボックス化)型はHaskellで定義できないので、言語とコンパイラに組み込まれている。プリミティブ型は決して持ち上げられていない。すなわち、プリミティブ型の値はボトムになり得ない。慣習として、プリミティブな型、値、演算には<literal>&num;</literal>を接尾辞として付ける(ただし、あくまで慣習である)(<xref linkend="magic-hash"/>を見よ)。プリミティブ型には、リテラルのために特別な構文があるものもあるが、それも<link linkend="magic-hash">同じ節</link>で述べている。</para>

<para>
しばしば、プリミティブな型は単なるビットパターンで表される。例えば、<literal>Int&num;</literal>、<literal>Float&num;</literal>、<literal>Double&num;</literal>がそうである。しかし、常にそうという訳ではない。プリミティブな値がヒープに確保されたオブジェクトへのポインタで表現されていることもある。例として<literal>Array&num;</literal>、すなわちプリミティブ配列の型がある。プリミティブ配列はヒープに確保されているが、これは、大きすぎてレジスタに収まらず、コピーして持ち回るのはコストが掛かりすぎるからである。ある意味では、これがポインタで表現されているというのは偶然に過ぎない。プリミティブ型がポインタで表現されるときは、ポインタは必ずその値を指すのであって、未評価のサンクや間接参照等々を指すことはない。たくさんの数値計算を行うプログラムでは、非ボックス化型を使うことで「標準的な」書き方をしたものよりも<emphasis>ずっと</emphasis>速くなることがある。ある例では、三倍もの高速化が達成された。</para>

<para>
プリミティブ型を使うにあたって、いくつか制限がある。
<itemizedlist>
<listitem><para>もっとも基本的な制限は、プリミティブ値は、多相的な関数に渡したり多相的なデータ型中に保持したりできないということである。これによって<literal>[Int&num;]</literal>(つまり、プリミティブ整数のリスト)のようなものが禁止される。この制限があるのは、多相的な引数や多相的な構築子フィールドはポインタであると期待されているからである。これらに非ボックス化整数が入り込むと、GCの追跡対象となり、予測できないスペースリークを引き起こす。また、その多相的な要素に対して<function>seq</function>を行うと、ポインタとして参照外しを試みることになり、壊滅的な結果を招く。さらに悪いことに、非ボックス化型はポインタよりも大きいことがある。(<literal>Double&num;</literal>が一例)
</para>
</listitem>
<listitem><para>newtypeを定義するとき、その表現の型(データ構築子の引数の型)が非ボックス化型であってはならない。よって、以下は許されない。
<programlisting>
  newtype A = MkA Int#
</programlisting>
</para></listitem>
<listitem><para><emphasis>最上位の</emphasis>束縛で、非ボックス化型を持つ変数を束縛することはできない。
</para></listitem>
<listitem><para><emphasis>再帰的な</emphasis>束縛で、非ボックス化型を持つ変数を束縛することはできない。
</para></listitem>
<listitem><para>非ボックス化変数を(非再帰的、非最上位)パターン束縛で束縛することはできるが、その場合、パターン照合が全体として正格になる。例。
<programlisting>
  data Foo = Foo Int Int#

  f x = let (Foo a b, w) = ..rhs.. in ..body..
</programlisting>
<literal>b</literal>の型は<literal>Int#</literal>なので、パターン照合が全体として正格になり、プログラムは以下のように書いたかのように動作する。
<programlisting>
  data Foo = Foo Int Int#

  f x = case ..rhs.. of { (Foo a b, w) -> ..body.. }
</programlisting>
</para>
</listitem>
</itemizedlist>
</para>

</sect2>

<sect2 id="unboxed-tuples">
<title>非ボックス化タプル
</title>

<para>
非ボックス化タプルは<literal>GHC.Exts</literal>でエクスポートされている訳ではなく、<option>-fglasgow-exts</option>が使われているときはそのままで使用可能である。非ボックス化タプルは次のような形をしている。
</para>

<para>

<programlisting>
(# e_1, ..., e_n #)
</programlisting>

</para>

<para>
ここで、<literal>e_1..e_n</literal>は任意の型(プリミティブであるかを問わない)をもつ式である。非ボックス化タプルの型も同様に書く。</para>

<para>
非ボックス化タプルが使われるのは、関数が複数の値を返す必要があり、なおかつ、通常のタプルを使ったときのようなヒープ確保を避けたい場合である。非ボックス化タプルが返されるとき、要素がレジスタかスタックに直接置かれる。非ボックス化タプルそれ自体は複合物としての表現を持たない。<literal>primops.txt.pp</literal>に載っているプリミティブ演算の多くが非ボックス化タプルを返す。特に、<literal>IO</literal>モナドおよび<literal>ST</literal>モナドでは、操作の連結に際して不要なメモリ確保をしなくても済むようにするために非ボックス化タプルが使われている。</para>

<para>
非ボックス化タプルの使用に際しては、かなり厳しい規則が存在する。
<itemizedlist>
<listitem>

<para>
非ボックス化タプル型の値は、通常の非ボックス化型と同じ制約を受ける。すなわち、多相的なデータ構造に入れることはできないし、多相的な関数に渡すこともできない。

</para>
</listitem>
<listitem>

<para>
非ボックス化タプル型の変数は存在し得ない。構築子や関数の引数が非ボックス化タプル型の引数を取ることはできない。以下の例は全て不正である。

<programlisting>
  data Foo = Foo (# Int, Int #)

  f :: (# Int, Int #) -&#62; (# Int, Int #)
  f x = x

  g :: (# Int, Int #) -&#62; Int
  g (# a,b #) = a

  h x = let y = (# x,x #) in ...
</programlisting>
</para>
</listitem>
</itemizedlist>
</para>
<para>
非ボックス化タプルの典型的な使いかたは、単純に複数の値を返し、その複数の結果を<literal>case</literal>式で束縛するというものである。
<programlisting>
  f x y = (# x+1, y-1 #)
  g x = case f x x of { (# a, b #) -&#62; a + b }
</programlisting>
パターン束縛中に非ボックス化タプルを用いることができる。
<programlisting>
  f x = let (# p,q #) = h x in ..body..
</programlisting>
<literal>p</literal>と<literal>q</literal>の型が非ボックス化型でないなら、通常のHaskellのパターン束縛と同様に、この束縛は遅延する。上記の例は次のように脱糖できる。
<programlisting>
  f x = let t = case h x o f{ (# p,q #) -> (p,q)
            p = fst t
            q = snd t
        in ..body..
</programlisting>
実際、束縛は再帰的であっても良い。
</para>

</sect2>
</sect1>


<!-- ====================== SYNTACTIC EXTENSIONS =======================  -->

<sect1 id="syntax-extns">
<title>構文的拡張</title>
 
    <sect2 id="magic-hash">
      <title>魔法の井桁(magic hash)</title>
      <para><option>-XMagicHash</option>という言語拡張は、識別子に対する後置修飾子として「&num;」を認めるものである。つまり、「x&num;」が変数として有効に、「T&num;」が型構築子やデータ構築子として有効になる。</para>

      <para>この井桁記号はまったく意味論に影響を与えない。非ボックス化された値や型に「&num;」で終わる名前を付ける(たとえば<literal>Int&num;</literal>)傾向があるが、必須ではない。これらはただの通常の変数に過ぎないのである。また、拡張<option>-XMagicHash</option>が何かをスコープに導入することもない。例えば、<literal>Int&num;</literal>をスコープに導入するためには<literal>GHC.Prim</literal>(<xref linkend="primitives"/>を見よ)をインポートしなければならない。その後で、スコープに導入された<literal>Int&num;</literal>に<emphasis>言及</emphasis>することを可能にするのが<option>-XMagicHash</option>オプションである。</para>
      <para>また、<option>-XMagicHash</option>は新しい形式のリテラルを何種類か有効にする。(<xref linkend="glasgow-unboxed"/>を見よ)
	<itemizedlist> 
	  <listitem><para> <literal>'x'&num;</literal>の型は<literal>Char&num;</literal></para> </listitem>
	  <listitem><para> <literal>&quot;foo&quot;&num;</literal>の型は<literal>Addr&num;</literal></para> </listitem>
	  <listitem><para> <literal>3&num;</literal>の型は<literal>Int&num;</literal>である。一般に、なんらかのHaskell 98の整数lexemeの後に<literal>&num;</literal>が付いたものは<literal>Int&num;</literal>になる。例えば<literal>-0x3A&num;</literal>や<literal>32&num;</literal>がそうである。</para></listitem>
	  <listitem><para> <literal>3&num;&num;</literal>の型は<literal>Word&num;</literal>である。一般に、なんらかの非負なHaskell 98の整数lexemeの後に<literal>&num;&num;</literal>が付いたものは<literal>Word&num;</literal>になる。</para> </listitem>
	  <listitem><para> <literal>3.2&num;</literal>の型は<literal>Float&num;</literal></para> </listitem>
	  <listitem><para> <literal>3.2&num;&num;</literal>の型は<literal>Double&num;</literal></para> </listitem>
	  </itemizedlist>
      </para>
   </sect2>

    <sect2 id="new-qualified-operators">
      <title>演算子を修飾する際の新しい構文</title>

      <para>修飾された演算子を参照するための新しい構文をHaskell'に導入することが計画されており、GHCでは<option>-XNewQualifiedOperators</option><indexterm><primary><option>-XNewQualifiedOperators</option></primary></indexterm>オプションによって有効になる。この新しい構文では、修飾された演算子を前置形式で使うときは<literal><replaceable>module</replaceable>.(<replaceable>symbol</replaceable>)</literal>と書く。(Haskell 98ではこれは<literal>(<replaceable>module</replaceable>.<replaceable>symbol</replaceable>)</literal>になる)。また、中置形式で使うときは<literal>`<replaceable>module</replaceable>.(<replaceable>symbol</replaceable>)`</literal>と書く。(Haskell 98では<literal>`<replaceable>module</replaceable>.<replaceable>symbol</replaceable>`</literal>である)。例を挙げる。
<programlisting>
  add x y = Prelude.(+) x y
  subtract y = (`Prelude.(-)` y)
</programlisting>
この新しい形式は、<literal>Prelude..</literal>のような奇妙な例を排除することで、構文を規則的にすることを意図している。例えば、<literal>NewQualifiedOperators</literal>が有効なとき、<literal>[Monday..]</literal>という列の生成をスペース無しで書くことができる。Haskell 98では、これは<literal>Monday</literal>というモジュールの「<literal>.</literal>」という演算子を参照することになる。</para>

      <para><option>-XNewQualifiedOperators</option>が有効なとき、古いHaskell 98形式の演算子の修飾構文は受け付けられないので、このオプションは既存のHaskell 98コードを壊す可能性がある。</para>

    </sect2>
        

    <!-- ====================== HIERARCHICAL MODULES =======================  -->


    <sect2 id="hierarchical-modules">
      <title>階層的モジュール</title>

      <para>GHCは、モジュール名の構文について、ある小さな拡張をサポートしている。すなわち、モジュール名はドット「<literal>.</literal>」を含むことができる。これは「階層的モジュール名前空間」拡張とも呼ばれる。これは、通常平坦なHaskellモジュールの名前空間を拡張して、より柔軟な、モジュールの階層をつくり出すからである。</para>

      <para>この拡張は言語そのものにはほとんど影響を与えない。モジュール名は<emphasis>常に</emphasis>完全修飾されるので、完全修飾されたモジュール名を「真のモジュール名」だと考えることができる。従って、特に、モジュールの先頭の<literal>module</literal>キーワードの後には、完全なモジュール名を与えなければならない。例えば、<literal>A.B.C</literal>というモジュールは次のように始まらなければならない。</para>

<programlisting>module A.B.C</programlisting>


      <para>階層的モジュールを使っていて、修飾名を使いたいときは、<literal>as</literal>キーワードを使ってタイプ数を節約するのが常套手段である。例えば、次のようにである。</para>

<programlisting>
import qualified Control.Monad.ST.Strict as ST
</programlisting>

      <para>階層的モジュールが使われているときにGHCがどのようにソースファイルやインタフェースファイルを探索するかについては、<xref linkend="search-path"/>を見よ。</para>

      <para>GHCには、階層的に配置された大規模なライブラリ群が付属している。これについては、付属の<ulink url="../libraries/index.html">ライブラリ説明書</ulink>(訳注: 未訳。<ulink url="http://www.haskell.org/ghc/docs/latest/html/libraries/">web上の最新版</ulink>)を見てほしい。また、<ulink url="http://hackage.haskell.org/packages/hackage.html">HackageDB</ulink>から別のライブラリを入手してインストールすることもできる。</para>

    </sect2>

    <!-- ====================== PATTERN GUARDS =======================  -->

<sect2 id="pattern-guards">
<title>パターンガード</title>

<para>
<indexterm><primary>Pattern guards (Glasgow extension)</primary></indexterm>
以下の議論はSimon Peyton Jonesの元<ulink url="http://research.microsoft.com/~simonpj/Haskell/guards.html">提案</ulink>を短くしたものである。(この提案はパターンガードが実装される前に書かれたので、これを未実装の機能として扱っていることに注意)</para>

<para>
有限写像を表す抽象データ型と、それについてのlookup操作があったとしよう。

<programlisting>
lookup :: FiniteMap -> Int -> Maybe Int
</programlisting>

lookupは、与えられたキーが写像の定義域に含まれなければ<function>Nothing</function>を返し、そうでなければ<function>(Just v)</function>を返す。ここで<varname>v</varname>はそのキーが対応する値である。ここで次の定義を考えよう。
</para>

<programlisting>
clunky env var1 var2 | ok1 &amp;&amp; ok2 = val1 + val2
| otherwise  = var1 + var2
where
  m1 = lookup env var1
  m2 = lookup env var2
  ok1 = maybeToBool m1
  ok2 = maybeToBool m2
  val1 = expectJust m1
  val2 = expectJust m2
</programlisting>

<para>
補助関数は次のとおりである。
</para>

<programlisting>
maybeToBool :: Maybe a -&gt; Bool
maybeToBool (Just x) = True
maybeToBool Nothing  = False

expectJust :: Maybe a -&gt; a
expectJust (Just x) = x
expectJust Nothing  = error "Unexpected Nothing"
</programlisting>

<para>
<function>clunky</function>は何をしているのか？ガードである<literal>ok1 &amp;&amp; ok2</literal>は両方のlookupが成功したことを確かめている。このために、<function>maybeToBool</function>を使って<function>Maybe</function>を真偽値に変換している。<function>expectJust</function>の呼び出し(遅延評価される)は、lookupの結果から値を抽出し、返った値を<varname>val1</varname>と<varname>val2</varname>にそれぞれ束縛している。もしどちらかのlookupが失敗すると、clunkyは<literal>otherwise</literal>の選択肢を選び、引数の和を返す。</para>

<para>
これは確かに合法なHaskellだが、欲する結果を得るのに非常に冗長で自明でないやりかたをしている。おそらく、case式を使った方がclunkyをもっと直接的に書けるだろう。
</para>

<programlisting>
clunky env var1 var2 = case lookup env var1 of
  Nothing -&gt; fail
  Just val1 -&gt; case lookup env var2 of
    Nothing -&gt; fail
    Just val2 -&gt; val1 + val2
where
  fail = var1 + var2
</programlisting>

<para>
これで少し短くなったが、改善とは言えないだろう。もちろん、パターン照合やガードのついた等式をcase式に書き換えることは常にできる。これはまさに、複数の等式を持つ定義をコンパイルするときにコンパイラが行っていることである。Haskellにガードつきの等式があるのは、場合分けを一つ一つ独立に書き下していくことができるようにである。この構造はcaseを使った版では明らかでない。右辺のうちふたつは同じ(<function>fail</function>)だし、式全体がどんどんインデントされていっている。
</para>

<para>
私ならclunkyを次のように書く。
</para>

<programlisting>
clunky env var1 var2
  | Just val1 &lt;- lookup env var1
  , Just val2 &lt;- lookup env var2
  = val1 + val2
...clunkyの他の等式...
</programlisting>

<para>
意味は十分明快だろう。修飾子は順番に照合される。<literal>&lt;-</literal>修飾子(パターンガードと呼ぼう)については、右辺が評価され、左辺のパターンと照合される。照合が失敗するとガードが全体として失敗し、次の等式が試みられる。成功すると、それに沿った束縛が行われ、次の修飾子が、拡張された環境の下で照合される。ただし、リスト内包表記の場合と違って、<literal>&lt;-</literal>の右辺の式の型は左辺のパターンの型と同じである。パターンガードによって導入された束縛のスコープは、残りのガード修飾子と、その等式の右辺にわたる。</para>

<para>
リスト内包表記の場合と同様に、パターンガード間に自由に真偽式を混ぜることができる。例えば、次のようにである。
</para>

<programlisting>
f x | [y] &lt;- x
    , y > 3
    , Just z &lt;- h y
    = ...
</programlisting>

<para>
従って、現在のHaskellのガードは、修飾子がただ一つの要素からなり、その要素が真偽式であるような、特別な場合とみなされる。
</para>
</sect2>

    <!-- ===================== View patterns ===================  -->

<sect2 id="view-patterns">
<title>ビューパターン
</title>

<para>
ビューパターンを有効にするフラグは<literal>-XViewPatterns</literal>である。ビューパターンに関するさらなる情報と実例は<ulink url="http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns">Wikiのページ</ulink>にある。
</para>

<para>
ビューパターンは、他のパターンの中に入れ子にして使えるパターンガードに少々似ていて、抽象型に対するパターン照合の方法として便利である。例えば、プログラミング言語の実装において、その言語の型の構文を以下のように表現することがあるかもしれない。
<programlisting>
type Typ
 
data TypView = Unit
             | Arrow Typ Typ

view :: Type -> TypeView

-- さらに、Typを構築するための演算が続く...
</programlisting>
Typの表現は抽象的なままにされているので、実装では手の込んだ表現(例えば共有を管理するためのhash-consing)を使うこともできる。

ビューパターンがないと、このシグネチャを使うのは少々不便である。
<programlisting>
size :: Typ -> Integer
size t = case view t of
  Unit -> 1
  Arrow t1 t2 -> size t1 + size t2
</programlisting>
等式を使った関数定義は使えず、このcaseを繰り返すしかない。さらに、<literal>t</literal>に関する照合が別のパターンの深くに埋まっている場合、状況はもっと悪くなる。</para>

<para>
ビューパターンを使うと、関数viewをパターンの中で呼んで、その結果に対して照合を行うことができる。
<programlisting>
size (view -> Unit) = 1
size (view -> Arrow t1 t2) = size t1 + size t2
</programlisting>
つまり、<replaceable>expression</replaceable> <literal>-></literal> <replaceable>pattern</replaceable>と書かれる新しい形式のパターンを追加したのである。これは、「照合対象にexpressionを適用し、その適用の結果をpatternに対して照合せよ」という意味である。expressionは関数の型を持つ任意のHaskellの式であり、ビューパターンはパターンが使えるところならどこにでも使える。
</para>

<para>
<literal>(</literal><replaceable>exp</replaceable> <literal>-></literal> <replaceable>pat</replaceable> <literal>)</literal>というパターンの意味論は以下の通り。

<itemizedlist>

<listitem>スコープ規則:

<para>このビューパターンによって束縛される変数は、<replaceable>pat</replaceable>によって束縛される変数である。
</para>

<para>
<replaceable>exp</replaceable>中の変数は全て束縛された出現である(訳注: 変数はどれも束縛されていなければいけない、換言すればスコープにある変数しか使ってはいけないということ)が、「左の方」のパターン中で束縛された変数はスコープにある。この特徴によって、例えば、ある関数のある引数を、別の引数のビューの中で使うことができる。例えば、<xref linkend="pattern-guards"/>に登場した関数<literal>clunky</literal>は、ビューパターンを使って次のように書ける。

<programlisting>
clunky env (lookup env -> Just val1) (lookup env -> Just val2) = val1 + val2
...clunkyのその他の等式...
</programlisting>
</para>

<para>
より精密に言うと、スコープ規則は以下の通りである。
<itemizedlist>
<listitem>
<para>
単一のパターンの中で、ビューパターンの左にあるパターンで束縛された変数はスコープにある。例。
<programlisting>
example :: Maybe ((String -> Integer,Integer), String) -> Bool
example Just ((f,_), f -> 4) = True
</programlisting>

さらに、関数定義において、カリー化された引数を照合することで束縛された変数は、その後の引数におけるビューパターン内で使うことができる。
<programlisting>
example :: (String -> Integer) -> String -> Bool
example f (f -> 4) = True
</programlisting>
つまり、この場合のスコープ割り当ては、カリー化された引数をタプルにまとめた場合と同じになる。
</para>
</listitem>

<listitem>
<para>
<literal>let</literal>や<literal>where</literal>、もしくは最上位のような相互再帰的な束縛において、ある宣言中のビューパターンが別の宣言によって束縛された変数に言及することはできない。つまり、それぞれの宣言が自己完結していなければならない。例えば、以下のプログラムは許されない。
<programlisting>
let {(x -> y) = e1 ;
     (y -> x) = e2 } in x
</programlisting>

(将来、この制限を取り除くかもしれない。唯一のコストは、パターンの型検査がもう少し複雑になることである。)

</para>
</listitem>
</itemizedlist>

</para>
</listitem>

<listitem><para>型付け: もし<replaceable>exp</replaceable>の型が<replaceable>T1</replaceable> <literal>-></literal> <replaceable>T2</replaceable>で<replaceable>pat</replaceable>が<replaceable>T2</replaceable>型の値に照合するなら、ビューパターン全体で<replaceable>T1</replaceable>型の値に照合する。</para></listitem>

<listitem><para>照合: <ulink url="http://www.haskell.org/onlinereport/">Haskell 98レポート</ulink>の3.17.3節(<ulink url="http://www.sampou.org/haskell/report-revised-j/exps.html#sect3.17.3">和訳</ulink>)の等式群に、以下のものを加える。
<programlisting>
case v of { (e -> p) -> e1 ; _ -> e2 } 
 = 
case (e v) of { p -> e1 ; _ -> e2 }
</programlisting>
つまり、<literal>(</literal> <replaceable>exp</replaceable> <literal>-></literal> <replaceable>pat</replaceable> <literal>)</literal>というパターンに変数<replaceable>v</replaceable>を照合するには、<literal>(</literal><replaceable>exp</replaceable> <replaceable> v</replaceable><literal>)</literal>を評価し、その結果を<replaceable>pat</replaceable>に対して照合する。
</para></listitem>

<listitem><para>効率性: ある関数定義やcase式の中で、同じビュー関数が複数の選択肢の中で使われている(例えば上の<literal>size</literal>)場合、ビュー関数が一回しか適用されないように、GHCはその関数の適用を集約して一つのネストしたcase式にしようとする。GHCのパターンのコンパイルは、<ulink url="http://research.microsoft.com/~simonpj/Papers/slpj-book-1987/">The Implementation of Functional Programming Languages</ulink>の第四章にある行列アルゴリズムに従っている。ある行列の最初の列の上部の行いくつか(訳注: top rows)が全て「同じ」式を持つビューパターンであった場合、それらのパターンは一つのネストされたcaseに変換される。これには、例えば、tuple中で整列したの隣接ビューパターンが含まれる。以下のような場合である。
<programlisting>
f ((view -> A, p1), p2) = e1
f ((view -> B, p3), p4) = e2
</programlisting>
</para>

<para>二つのビューパターンがどんなときに「同じ」であるかの現在の描像は非常に制限されたもので、完全な構文的同値性ですらない。それでも、変数、リテラル、適用、それにタプルを含んでいる。例えば、<literal>view ("hi", "there")</literal>が二つあった場合、それはまとめられる。一方、現在の実装はα同値性に従った比較を行わないので、<literal>(x, view x -> y)</literal>が二つあっても合体することはない。
</para>

</listitem>

</itemizedlist>
</para>

</sect2>

    <!-- ===================== Recursive do-notation ===================  -->

<sect2 id="mdo-notation">
<title>再帰的do記法
</title>

<para>再帰的do記法(mdo記法とも呼ばれる)は、<ulink url="http://citeseer.ist.psu.edu/erk02recursive.html">A recursive do for Haskell</ulink>, by Levent Erkok, John Launchbury, Haskell Workshop 2002, pages: 29-37. Pittsburgh, Pennsylvaniaに記されている通りに実装されている。この論文は、mdo記法の自明でない使い方をする者にとっては必読であって、ここで内容を繰り返すことはしない。</para>

<para>
Haskellのdo記法では、<emphasis>再帰的な束縛</emphasis>が許されない。すなわち、do式中で束縛された変数は、テキスト中でそれより後ろのコードブロックからのみ可視である。これに対して、let式では、束縛変数がその束縛グループ全体から可視である。do記法でも再帰的束縛ができると恩恵を被る応用がいくつかあると分かったので、必要な構文的なサポートを提供しようというのがこの拡張である。</para>
<para>
以下は単純な(しかし巧妙に作られた)例である。
</para>
<programlisting>
import Control.Monad.Fix

justOnes = mdo xs &lt;- Just (1:xs)
               return xs
</programlisting>
<para>
推測できるだろうが、<literal>justOnes</literal>は<literal>Just [1,1,1,...</literal>に評価される。
</para>

<para>
ライブラリControl.Monad.Fixで、<literal>MonadFix</literal>クラスが導入されている。定義は以下である。
</para>
<programlisting>
class Monad m => MonadFix m where
   mfix :: (a -> m a) -> m a
</programlisting>
<para>
<literal>mfix</literal>関数は、必要とされる再帰演算がどのように実行されるかを規定する。例えば、<literal>justOnes</literal>は以下のように脱糖される。
<programlisting>
justOnes = mfix (\xs' -&gt; do { xs &lt;- Just (1:xs'); return xs }
</programlisting>
mdoがどのように型検査され脱糖されるかの完全な詳細については、論文<ulink url="http://citeseer.ist.psu.edu/erk02recursive.html">A recursive do for Haskell</ulink>を見よ。特に、GHCはこの論文の3.2節に記述されているsegmentation techniqueを実装している。</para>
<para>
あるモナドについて再帰的束縛を使いたいなら、そのモナドは<literal>MonadFix</literal>クラスのインスタンスとして宣言されていなければならない。List、Maybe、IOについては<literal>MonadFix</literal>のインスタンスが自動的に与えられている。さらに、Control.Monad.STとControl.Monad.ST.Lazyでは、Haskellの内部状態モナド(それぞれ正格版と遅延版)についてのMonadFixクラスのインスタンスが提供されている。
</para>
<para>
再帰的do記法を使うにあたって、いくつか重要な点がある。
<itemizedlist>
<listitem><para>
再帰的do記法ではキーワードとして(<literal>do</literal>ではなく)<literal>mdo</literal>を使う。
</para></listitem>

<listitem><para>
これは<literal>-XRecursiveDo</literal>フラグで有効になる。このフラグは<literal>-fglasgow-exts</literal>で有効になる。
</para></listitem>

<listitem><para>
通常のdo記法と異なり、<literal>let</literal>や<literal>where</literal>の束縛と同じように、名前の隠蔽は許されない。つまり、一つの<literal>mdo</literal>において束縛される名前は全て異なっていなければならない。(論文の3.3節)
</para></listitem>

<listitem><para>
<literal>mdo</literal>中の<literal>let</literal>文で束縛された変数はその<literal>mdo</literal>において単相的である。(論文の3.1節)。ただし、GHCは、多相性を増し、停止性を改善するために、<literal>mdo</literal>を分割する。(論文の3.2節)
 </para></listitem>
</itemizedlist>
</para>

<para>
歴史的な参考事項: mdo記法の古い実装(および既存の文書の大部分)は、ライブラリとクラスの名として<literal>MonadRec</literal>を使っていたが、GHCはこの名前をサポートしない。
</para>

</sect2>


   <!-- ===================== PARALLEL LIST COMPREHENSIONS ===================  -->

  <sect2 id="parallel-list-comprehensions">
    <title>並行リスト内包表記</title>
    <indexterm><primary>list comprehensions</primary><secondary>parallel</secondary>
    </indexterm>
    <indexterm><primary>parallel list comprehensions</primary>
    </indexterm>

    <para>並行リスト内包表記はリスト内包表記を自然に拡張したものである。リスト内包表記は、mapとfilterを書くための扱いやすい構文と捉えることができる。並行内包表記はこれをzipWith系関数を含むように拡張するものである。</para>

    <para>並行リスト内包表記は複数の独立した枝からなり、「|」で区切られる。それぞれの枝には修飾子が並べられる。例えば、以下のものは二つのリストをzipする。</para>

<programlisting>
   [ (x, y) | x &lt;- xs | y &lt;- ys ] 
</programlisting>

    <para>結果のリストは、最も短い枝と同じ長さになる。この点で、並行リスト内包表記の振る舞いはzipのものを踏襲している。</para>

    <para>通常の内包表記への変換を規定することによって並行リスト内包表記を定義することができる。以下に示すのは基本的な考え方である。</para>

    <para>次のような並行内包表記があったとする。</para>

<programlisting>
   [ e | p1 &lt;- e11, p2 &lt;- e12, ... 
       | q1 &lt;- e21, q2 &lt;- e22, ... 
       ... 
   ] 
</programlisting>

    <para>これは次のように変換される。</para>

<programlisting>
   [ e | ((p1,p2), (q1,q2), ...) &lt;- zipN [(p1,p2) | p1 &lt;- e11, p2 &lt;- e12, ...] 
                                         [(q1,q2) | q1 &lt;- e21, q2 &lt;- e22, ...] 
                                         ... 
   ] 
</programlisting>

    <para>ここで、「zipN」は、枝の数に応じた適切なzipである。</para>

  </sect2>
  
  <!-- ===================== TRANSFORM LIST COMPREHENSIONS ===================  -->

  <sect2 id="generalised-list-comprehensions">
    <title>一般化(SQL風)リスト内包表記</title>
    <indexterm><primary>list comprehensions</primary><secondary>generalised</secondary>
    </indexterm>
    <indexterm><primary>extended list comprehensions</primary>
    </indexterm>
    <indexterm><primary>group</primary></indexterm>
    <indexterm><primary>sql</primary></indexterm>


    <para>一般化リスト内包表記は、SQLでおなじみのソートやグループ化といった操作を可能にするための、リスト内包表記という構文糖に対するさらなる強化である。これは、論文<ulink url="http://research.microsoft.com/~simonpj/papers/list-comp">Comprehensive comprehensions: comprehensions with "order by" and "group by"</ulink>で完全に記述されている。ただし、我々が使う構文は論文のものと僅かに異なる。</para>
<para>例を示す。
<programlisting>
employees = [ ("Simon", "MS", 80)
, ("Erik", "MS", 100)
, ("Phil", "Ed", 40)
, ("Gordon", "Ed", 45)
, ("Paul", "Yale", 60)]

output = [ (the dept, sum salary)
| (name, dept, salary) &lt;- employees
, then group by dept
, then sortWith by (sum salary)
, then take 5 ]
</programlisting>
この例では、リスト<literal>output</literal>の値は次のようになる。
<programlisting>
[("Yale", 60), ("Ed", 85), ("MS", 180)]
</programlisting>
</para>
<para>新しいキーワードが三つある。<literal>group</literal>、<literal>by</literal>、<literal>using</literal>である。(関数<literal>sortWith</literal>はキーワードではない。<literal>GHC.Exts</literal>からエクスポートされている普通の関数である。)</para>

<para>内包表記修飾子の新しい形式が五つあり、すべて(既存の)キーワード<literal>then</literal>で導入される。
    <itemizedlist>
    <listitem>
    
<programlisting>
then f
</programlisting>

この文は、<literal>f</literal>が型<literal>forall a. [a] -> [a]</literal>を持つことを要求する。これの使用例として、最初にあげた例では<literal>take 5</literal>を適用するのに使われている。
    
    </listitem>
    
    
    <listitem>
<para>
<programlisting>
then f by e
</programlisting>

この形式は上のものに似ているが、fの最初の引数として渡される関数を作ることができる。そのため、fの型は<literal>forall a. (a -> t) -> [a] -> [a]</literal>でなければならない。型から分かるように、この関数は、変形対象のリストの要素からfがなんらかの情報を「射影抽出(project out)」できるようにするものである。</para>

    <para>ひとつの例が最初の例にある。この例では、変換されるリストの任意の要素について<literal>sortWith</literal>が<literal>sum salary</literal>を見つけ出すのに使われる関数が、<literal>sortWith</literal>への引数として与えられている。</para>

    </listitem>


    <listitem>

<programlisting>
then group by e using f
</programlisting>

    <para>グループ化系統の文のうち、最も一般的な形がこれである。この形式では、fの型が<literal>forall a. (a -> t) -> [a] -> [[a]]</literal>であることが要求される。上の<literal>then f by e</literal>の場合と同様、最初の引数はコンパイラによってfに与えられる。これは、変換対象のリストの各要素についてfがeを計算することができるようにする関数である。しかし、グループ化以外の場合と異なり、fはさらに対象のリストをいくつかの部分リストに分割する。これによって、この文以降のあらゆる点において、内包表記中でこれ以前に現われた束縛は、単一の値ではなく可能な値の<emphasis>リスト</emphasis>を指すようになる。これを理解する助けになるように、ひとつの例を見てみよう。</para>
    
<programlisting>
-- これはGHC.ExtsのgroupWithと同様に働くが、最初に入力をソートしない
groupRuns :: Eq b => (a -> b) -> [a] -> [[a]]
groupRuns f = groupBy (\x y -> f x == f y)

output = [ (the x, y)
| x &lt;- ([1..3] ++ [1..2])
, y &lt;- [4..6]
, then group by x using groupRuns ]
</programlisting>

    <para>結果として、変数<literal>output</literal>は次に示す値を取る。</para>

<programlisting>
[(1, [4, 5, 6]), (2, [4, 5, 6]), (3, [4, 5, 6]), (1, [4, 5, 6]), (2, [4, 5, 6])]
</programlisting>

    <para>関数<literal>the</literal>を使って、xの型をリストから元の数値型に戻したのに注意。対照的に、変数yは、グループ化によって導入されたリスト形式のままにしてある。</para>

    </listitem>

    <listitem>

<programlisting>
then group by e
</programlisting>

    <para>この形式のグループ化は、要するに上述のものと同じだが、グループ化に用いられる関数が与えられていないので、代わりに<ulink url="../libraries/base/GHC-Exts.html"><literal>GHC.Exts</literal></ulink>(訳注: 未訳。<ulink url="http://www.haskell.org/ghc/docs/latest/html/libraries/base/GHC-Exts.html">web上の最新版</ulink>)で定義されている<literal>groupWith</literal>が用いられる。最初の例で使ったグループ化の形式はこれである。</para>

    </listitem>
    
    
    <listitem>

<programlisting>
then group using f
</programlisting>

    <para>この形式のgroup文では、fの型は単純に<literal>forall a. [a] -> [[a]]</literal>である必要があり、ここまでの内包を直接グループ化するのに使われる。この形式の例を以下に示す。</para>
    
<programlisting>
output = [ x
| y &lt;- [1..5]
, x &lt;- "hello"
, then group using inits]
</programlisting>

    <para>結果は、「hello」という単語を五回並べた文字列の、すべての前方部分列(prefix)を含むリストになる。</para>

<programlisting>
["","h","he","hel","hell","hello","helloh","hellohe","hellohel","hellohell","hellohello","hellohelloh",...]
</programlisting>

    </listitem>
</itemizedlist>
</para>
  </sect2>

   <!-- ===================== REBINDABLE SYNTAX ===================  -->
<sect2 id="rebindable-syntax">
<title>再束縛可能な構文とPreludeの暗黙インポート</title>

<para><indexterm><primary>-XNoImplicitPrelude option</primary></indexterm>GHCは通常<filename>Prelude.hi</filename>を自動的にインポートする。これが嫌なら、<option>-XNoImplicitPrelude</option>を使うと良い。こうすれば、自分自身のPreludeをインポートすることができる。(ただし、それに<literal>Prelude</literal>という名前をつけてはいけない。Haskellではモジュールの名前空間は平坦なので、Preludeモジュールと衝突を起こしてはならないのだ)</para>
 
            <para>自分で数値クラスの階層を定義するために、自作のプレリュードを実装しているとしよう。しかし、リテラルの「1」が、Haskellレポートの指定通りに<literal>Prelude.fromInteger 1</literal>を意味するとしたら、これは完全な無駄骨である。このため、<option>-XNoImplicitPrelude</option>フラグを使った場合に<emphasis>も</emphasis>、以下に挙げる組込み構文は(Preludeのものではなく)<emphasis>スコープにあるものならなんでも</emphasis>使うようになる。
	    <itemizedlist>
	      <listitem>
		<para>整数リテラル<literal>368</literal>の意味は「<literal>fromInteger (368::Integer)</literal>」であり、「<literal>Prelude.fromInteger (368::Integer)</literal>」ではない。</para> </listitem>	    

      <listitem><para>小数リテラルも全く同じように扱われる。変換は<literal>fromRational (3.68::Rational)</literal>である。
</para> </listitem>	    

	  <listitem><para>多重定義された数値的パターンでの等値比較では、とにかくスコープにある<literal>(==)</literal>を使う。</para> </listitem>	    

	  <listitem><para><literal>n+k</literal>パターンにおける減算演算およびだいなりいこーる比較では、とにかくスコープにある<literal>(-)</literal>と<literal>(>=)</literal>を使う。</para></listitem>

	      <listitem>
                <para>符号反転(例えば「<literal>- (f x)</literal>」)は、数値パターンでも式中でも「<literal>negate (f x)</literal>」を意味する。</para></listitem>

	      <listitem>
	  <para>do記法の変換時にはとにかくスコープにある<literal>(>>=)</literal>、<literal>(>>)</literal>、<literal>fail</literal>が使われる。リスト内包表記、mdo(<xref linkend="mdo-notation"/>)、並行配列内包表記は影響を受けない。</para></listitem>

	      <listitem>
                <para>アロー記法(<xref linkend="arrow-notation"/>を見よ)では、とにかくスコープにある<literal>arr</literal>、<literal>(>>>)</literal>、<literal>first</literal>、<literal>app</literal>、<literal>(|||)</literal>、<literal>loop</literal>の各関数が使われる。ただし、他の構文要素の場合と異なり、これらの関数の型はPreludeのものとかなり良く近似していなければならない。詳細は固まっていので、もしこれを使いたいなら、声を掛けてほしい。
	      </para></listitem>
	    </itemizedlist>
どの場合でも(アロー記法は例外)、コードの静的意味は脱糖された形でのそれと等しくなるはずである。これは少々予想に反するかもしれない。例えば、<literal>368</literal>というリテラルの静的意味は<literal>fromInteger (368::Integer)</literal>のそれとまったく同じである。従って、<literal>fromInteger</literal>は下に挙げるどんな型をもっていても良い。
<programlisting>
fromInteger :: Integer -> Integer
fromInteger :: forall a. Foo a => Integer -> a
fromInteger :: Num a => a -> Integer
fromInteger :: Integer -> Bool -> Bool
</programlisting>
</para>
	        
             <para>警告: これは実験的な機能であり、通常ほど検査がなされない。脱糖されたプログラムを型検査するには<literal>-dcore-lint</literal>を使う。Core Lintが満足しているなら、問題ないはずである。</para>

</sect2>

<sect2 id="postfix-operators">
<title>後置演算子</title>

<para>
<option>-XPostfixOperators</option>フラグを使うと、演算子の左セクションの構文に小さな拡張が有効になり、これを使って後置演算子を定義することができるようになる。拡張とはこうである。以下のような左セクションがあったとしよう。
<programlisting>
  (e !)
</programlisting>
これは、(型検査と実行の両面において)以下の式と等しい。
<programlisting>
  ((!) e)
</programlisting>
(これは式<literal>e</literal>が何であっても、また演算子<literal>(!)</literal>が何であっても成り立つ)。Haskell 98の厳密な解釈では、このセクションは以下と同等だとされる。
<programlisting>
  (\y -> (!) e y)
</programlisting>
つまり、演算子は二引数の関数でなければならない。GHCでは一引数の関数であっても良く、結果として、関数を後置記法で書くことができるようになる。
</para>
<para>この拡張は関数定義の左辺には及ばない。従って、このような関数を定義するときには前置形を使わなければならない。</para>

</sect2>

<sect2 id="disambiguate-fields">
<title>レコードフィールドの曖昧性除去</title>
<para>
レコードの構築とパターンマッチにおいては、仮に同じフィールド名を持つデータ型が二つスコープにあったとしても、どのフィールドが言及されているのか全く曖昧でない。例えば以下のように。
<programlisting>
module M where
  data S = MkS { x :: Int, y :: Bool }

module Foo where
  import M

  data T = MkT { x :: Int }
  
  ok1 (MkS { x = n }) = n+1   -- 曖昧でない

  ok2 n = MkT { x = n+1 }     -- 曖昧でない

  bad1 k = k { x = 3 }  -- 曖昧
  bad2 k = x k          -- 曖昧
</programlisting>
スコープには二つの<literal>x</literal>があるが、<literal>ok1</literal>の定義中のパターンにおける<literal>x</literal>は、型<literal>S</literal>のフィールドを指す他にないということが明白である。関数<literal>ok2</literal>についても同様である。しかし、<literal>bad1</literal>におけるレコード更新と、<literal>bad2</literal>におけるレコード選択では、どちらの型が意図されているか明確でない。
</para>
<para>
Haskell 98はこの四つすべてを曖昧であると見做すが、<option>-XDisambiguateRecordFields</option>が与えられると、GHCは前者二つを認める。この規則は、Haskell 98でのインスタンス宣言の規則(インスタンス宣言中のメソッド束縛の左辺のメソッド名は曖昧さなくそのクラスのメソッドを(スコープにあれば)参照し、スコープに同名の別の変数があっても構わないとする)と全く同じである。これによって、異なるモジュールから同じフィールド名を使う二つのレコードをインポートしたときに、修飾名が散らばるのを軽減できる。
</para>
</sect2>

    <!-- ===================== Record puns ===================  -->

<sect2 id="record-puns">
<title>レコード同名利用
</title>

<para>
レコード同名利用(record puns; punは「駄洒落」「語呂合わせ」の意)は、<literal>-XNamedFieldPuns</literal>フラグによって有効になる。
</para>

<para>
レコードを使うとき、フィールド名と同じ名前の変数を束縛するようなパターンを書くことがよくある。以下のような場合である。

<programlisting>
data C = C {a :: Int}
f (C {a = a}) = a
</programlisting>
</para>

<para>
レコード同名利用は、この変数名を省略することを可能にする。よって、上と同じことを単に次のように書くことができる。

<programlisting>
f (C {a}) = a
</programlisting>

つまり、レコードパターン中において、<literal>a</literal>というパターンは<literal>a = a</literal>というパターン(同じ<literal>a</literal>という名前についての)に展開される。
</para>

<para>
同じレコード中で、同名利用と通常のパターンを混ぜることもできるのに注意。
<programlisting>
data C = C {a :: Int, b :: Int}
f (C {a, b = 4}) = a
</programlisting>
また、同名利用は、レコードパターンが使えるところ(例えば<literal>let</literal>束縛の中や最上位)ならどこでも使うことができる。
</para>

<para>
レコード同名利用は式中でも使える。例えば、次のように書く。
<programlisting>
let a = 1 in C {a}
</programlisting>
これは次のものと同等である。
<programlisting>
let a = 1 in C {a = a}
</programlisting>

この展開は純粋に構文上のものであるため、レコード同名利用の式は、そのフィールド名と同じ綴りを持つなかで、最も内側の変数を参照することに注意。
</para>

</sect2>

    <!-- ===================== Record wildcards ===================  -->

<sect2 id="record-wildcards">
<title>レコードワイルドカード
</title>

<para>
レコードワイルドカードは<literal>-XRecordWildCards</literal>フラグによって有効になる。
</para>

<para>
沢山のフィールドのあるレコードでは、レコードパターンにおいてフィールドをいちいち書き下すのが面倒なことがある。次のような場合である。
<programlisting>
data C = C {a :: Int, b :: Int, c :: Int, d :: Int}
f (C {a = 1, b = b, c = c, d = d}) = b + c + d
</programlisting>
</para>

<para>
レコードワイルドカード構文では、レコードパターン中に(<literal>..</literal>)を使えるようになる。そうすると、省略したそれぞれの<literal>f</literal>が<literal>f = f</literal>というパターンに置換される。例として、上のパターンは次のように書ける。
<programlisting>
f (C {a = 1, ..}) = b + c + d
</programlisting>
</para>

<para>
ワイルドカードは他のパターン(同名利用(<xref linkend="record-puns"/>)も含む)と併用できることに注意。例えば<literal>C {a = 1, b, ..})</literal>というパターンでのように。さらに、レコードワイルドカードはレコードパターンが使えるところならどこでも使えるので、<literal>let</literal>束縛や最上位でも使える。例えば、次の最上位の束縛は、<literal>b</literal>と<literal>c</literal>と<literal>d</literal>を定義する。
<programlisting>
C {a = 1, ..} = e
</programlisting>
</para>

<para>
レコードワイルドカードは式中でも使える。次のように書くことができる。

<programlisting>
let {a = 1; b = 2; c = 3; d = 4} in C {..}
</programlisting>

これは以下のように書くのと同じである。

<programlisting>
let {a = 1; b = 2; c = 3; d = 4} in C {a=a, b=b, c=c, d=d}
</programlisting>

この展開は純粋に構文上のものなので、レコードワイルドカード式は、省略されたフィールド名と同じ綴りの変数のうちもっとも内側にあるものを参照することに注意。
</para>

</sect2>

    <!-- ===================== Local fixity declarations ===================  -->

<sect2 id="local-fixity-declarations">
<title>局所結合性宣言
</title>

<para>Haskell 98レポートを注意深く読むと、<literal>let</literal>や<literal>where</literal>で導入される局所束縛の内部に結合性宣言(<literal>infix</literal>、<literal>infixl</literal>、<literal>infixr</literal>)が出現することが許されていることが分かる。しかし、このような束縛の意味論について、Haskellレポートはあまり詳しく規定していない。
</para>

<para>GHCでは、次のように、局所束縛に結合性宣言が付属していてもよい。
<programlisting>
let f = ...
    infixr 3 `f`
in 
    ...
</programlisting>
そして、この結合性宣言は、この束縛がスコープにあるようなあらゆる場所で適用される。例えば、<literal>let</literal>式なら、他の<literal>let</literal>束縛の右辺と<literal>let</literal>式の本体で適用される。また、再帰的<literal>do</literal>式(<xref linkend="mdo-notation"/>)では、<literal>let</literal>文の局所結合性宣言は、束縛される名前と同様に、そのグループの全ての文に渡るスコープを持つ。
</para>

<para>
さらに、局所結合性宣言にはその名前についての局所束縛が付属「していなければならない」。次のように、別の場所で束縛された名前の結合性を設定しなおすことは不可能である。
<programlisting>
let infixr 9 $ in ...
</programlisting>

局所結合性宣言は技術的にHaskell 98なので、有効にするのにフラグは必要ない。
</para>
</sect2>

<sect2 id="package-imports">
  <title>パッケージ修飾されたインポート</title>

  <para><option>-XPackageImports</option>フラグが有効なら、GHCは、インポート宣言を、インポート先のモジュールが属しているべきパッケージ名で修飾することを認める。例をあげる。</para>

<programlisting>
import "network" Network.Socket
</programlisting>
  
  <para>こうすると、<literal>network</literal>パッケージ(のいずれかのバージョン)から<literal>Network.Socket</literal>をインポートすることになる。これは、同じモジュールが複数のパッケージから利用できたり、現在ビルド中のパッケージと外部のパッケージの両方にあったりする場合に、インポートの曖昧性を取り除くために使うことができる。</para>

  <para>注意: おそらく、あなたがこの機能を使う必要はないだろう。この機能は、主に我々がAPIの変更に際して後方互換なパッケージのバージョンをビルドすることができるように追加されたものである。一般的な事例では、この機能を使うと脆い依存が発生しやすい。モジュールはあるパッケージから別のパッケージに移ることがあり、その場合パッケージ修飾されたインポートは壊れるからである。</para>
</sect2>
<sect2 id="syntax-stolen">
<title>盗まれた構文の概略</title>

    <para>専用の構文を有効にするオプションを使うと、Haskell 98で動作していたコードがコンパイルできなくなる<emphasis>可能性がある</emphasis>。これは大抵、変数名として使われていたものが予約語になることが原因である。この節では、言語拡張によって「盗まれた」構文を列挙する。ここではHaskell 98の字句構文(Haskell 98レポートを見よ)の記法と非終端記号を使っている。構文の変更については、既存の正しいプログラムに影響する可能性のあるもの(「盗まれた」構文)のみを列挙する。多くの拡張は新しい文脈自由構文を導入するが、これらの場合は例外なく、新しい構文を使って書かれたプログラムは適当なオプションなしではコンパイルできない。</para>
    
    <para>専用の構文には次の二種類がある。</para>

    <itemizedlist>
      <listitem>
        <para>新しい予約語や予約シンボル。もはやプログラムで識別子として使うことのできない文字列である。</para>
      </listitem>
      <listitem>
        <para>その他の専用構文。特定のオプションが有効になっていると別の意味を持つような文字の列。</para>
      </listitem>
    </itemizedlist>
    
<para>盗まれるのは以下の構文である。</para>

    <variablelist>
      <varlistentry>
	<term>
          <literal>forall</literal>
          <indexterm><primary><literal>forall</literal></primary></indexterm>
	</term>
	<listitem><para><option>-XScopedTypeVariables</option>、<option>-XLiberalTypeSynonyms</option>、<option>-XRank2Types</option>、<option>-XRankNTypes</option>、<option>-XPolymorphicComponents</option>、<option>-XExistentialQuantification</option>によって盗まれる(型中において)。
	  </para></listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>mdo</literal>
          <indexterm><primary><literal>mdo</literal></primary></indexterm>
	</term>
	<listitem><para>
	<option>-XRecursiveDo</option>に盗まれる。
	  </para></listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>foreign</literal>
          <indexterm><primary><literal>foreign</literal></primary></indexterm>
	</term>
	<listitem><para>
	<option>-XForeignFunctionInterface</option>に盗まれる。
	  </para></listitem>
      </varlistentry>

      <varlistentry>
	<term>
          <literal>rec</literal>、<literal>proc</literal>、<literal>-&lt;</literal>、<literal>&gt;-</literal>、<literal>-&lt;&lt;</literal>、<literal>&gt;&gt;-</literal>、および<literal>(|</literal>、<literal>|)</literal>の括弧
          <indexterm><primary><literal>proc</literal></primary></indexterm>
	</term>
	<listitem><para>
	<option>-XArrows</option>によって盗まれる。
	  </para></listitem>
      </varlistentry>

      <varlistentry>
	<term>
	  <literal>?<replaceable>varid</replaceable></literal>,
	  <literal>%<replaceable>varid</replaceable></literal>
          <indexterm><primary>implicit parameters</primary></indexterm>
	</term>
	<listitem><para>
	<option>-XImplicitParams</option>によって盗まれる。
	  </para></listitem>
      </varlistentry>

      <varlistentry>
	<term>
	  <literal>[|</literal>,
	  <literal>[e|</literal>, <literal>[p|</literal>,
	  <literal>[d|</literal>, <literal>[t|</literal>,
	  <literal>$(</literal>,
	  <literal>$<replaceable>varid</replaceable></literal>
          <indexterm><primary>Template Haskell</primary></indexterm>
	</term>
	<listitem><para>
	<option>-XTemplateHaskell</option>によって盗まれる。
	  </para></listitem>
      </varlistentry>

      <varlistentry>
	<term>
	  <literal>[:<replaceable>varid</replaceable>|</literal>
          <indexterm><primary>quasi-quotation</primary></indexterm>
	</term>
	<listitem><para>
	<option>-XQuasiQuotes</option>によって盗まれる。
	  </para></listitem>
      </varlistentry>

      <varlistentry>
	<term>
	      <replaceable>varid</replaceable>{<literal>&num;</literal>},
	      <replaceable>char</replaceable><literal>&num;</literal>,	    
	      <replaceable>string</replaceable><literal>&num;</literal>,    
	      <replaceable>integer</replaceable><literal>&num;</literal>,    
	      <replaceable>float</replaceable><literal>&num;</literal>,    
	      <replaceable>float</replaceable><literal>&num;&num;</literal>,    
	      <literal>(&num;</literal>, <literal>&num;)</literal>,	    
	</term>
	<listitem><para>
	<option>-XMagicHash</option>によって盗まれる。
	  </para></listitem>
      </varlistentry>
    </variablelist>
</sect2>
</sect1>


<!-- TYPE SYSTEM EXTENSIONS -->
<sect1 id="data-type-extensions">
<title>データ型と型シノニムへの拡張</title>

<sect2 id="nullary-types">
<title>構築子のないデータ型</title>

<para><option>-fglasgow-exts</option>フラグが指定されていると、構築子なしでデータ型を宣言できるようになる。例えば、以下のようにである。</para>

<programlisting>
  data S      -- S :: *
  data T a    -- T :: * -> *
</programlisting>

<para>構文的にいうと、この宣言は「= constrs」の部分を欠いている。このように定義される型は多相的でも良く、さらにどのような類について多相的でも良いが、類が<literal>*</literal>でないなら、明示的な類注釈を使う必要がある。(<xref linkend="kinding"/>を見よ)</para>

<para>このようなデータ型はボトムというただ一つの値しか持たないが、「幽霊型(phantom type)」を定義するときには便利なことがある。</para>
</sect2>

<sect2 id="infix-tycons">
<title>中置型構築子、中置クラス、中置型変数</title>

<para>
GHCでは、型構築子、クラス、型変数を演算子として定義し、式と同じように中置記法で書くことが許される。具体的には、以下のようにである。
<itemizedlist>
<listitem><para>
型構築子やクラスは、コロンで始まる演算子であっても良い。例えば<literal>:*:</literal>。字句的な構文はデータ構築子の場合と同じである。
  </para></listitem>
<listitem><para>
  データ型と型シノニムの宣言は中置形でも行える。引数がさらに必要なら括弧を使う。例。
<screen>
  data a :*: b = Foo a b
  type a :+: b = Either a b
  class a :=: b where ...

  data (a :**: b) x = Baz a b x
  type (a :++: b) y = Either (a,b) y
</screen>
  </para></listitem>
<listitem><para>
  型およびクラス制約は中置形で書いても良い。
  <screen>
	x :: Int :*: Bool
        f :: (a :=: b) => a -> b
  </screen>
  </para></listitem>
<listitem><para>
  型変数は(修飾されていない)演算子であっても良い。例えば<literal>+</literal>などである。字句構文は変数演算子の場合と同じであるが、「(.)」、「(!)」、「(*)」は除外される。束縛位置では、演算子は括弧で括らねばならない。以下のように。
<programlisting>
   type T (+) = Int + Int
   f :: T Either
   f = Left 3
 
   liftA2 :: Arrow (~>)
	  => (a -> b -> c) -> (e ~> a) -> (e ~> b) -> (e ~> c)
   liftA2 = ...
</programlisting>
  </para></listitem>
<listitem><para>
  バッククオートは、型構築子と型変数のどちらについても、式の場合と同様に働く。例えば、<literal>Int `Either` Bool</literal>とか<literal>Int `a` Bool</literal>のように書ける。同様に、括弧も同じように働く。例えば、<literal>(:*:) Int Bool</literal>のようにである。
  </para></listitem>
<listitem><para>
  型構築子やクラスについて、データ構築子の場合と同じように結合性を宣言することができる。しかし、結合性宣言中でこの二つを区別することはできない。一つの結合性宣言で、データ構築子の結合性と型構築子の結合性が同時に設定される。
<screen>
  infixl 7 T, :*:
</screen>
  上記は、型構築子<literal>T</literal>とデータ構築子<literal>T</literal>の両方の結合性を設定している。<literal>:*:</literal>についても同様である。<literal>Int `a` Bool</literal>.
  </para></listitem>
<listitem><para>
  関数の矢印は<literal>infixr</literal>で結合性0である。(これは変わるかもしれない。どうするべきかわからないので)
  </para></listitem>

</itemizedlist>
</para>
</sect2>

<sect2 id="type-synonyms">
<title>型シノニムの制限緩和</title>

<para>
型シノニムは型の世界でのマクロに似ているが、Haskell 98は型シノニムの個々の宣言にたくさんの規則を課している。拡張<option>-XLiberalTypeSynonyms</option>が有効だと、GHCはいろいろな検査を<emphasis>型シノニムを展開した後にしか</emphasis>行わない。つまり、型シノニムについてGHCはHaskell 98よりもずっと制限を緩くすることができる。
<itemizedlist>
<listitem> <para>次のように、型シノニム中に<literal>forall</literal>(多重定義が関係しても良い)を書くことができる。
<programlisting>
  type Discard a = forall b. Show b => a -> b -> (a, String)

  f :: Discard a
  f x y = (x, show y)

  g :: Discard Int -> (Int,String)    -- ランク2の型
  g f = f 3 True
</programlisting>
</para>
</listitem>

<listitem><para>
<option>-XUnboxedTuples</option>も使っているなら、型シノニム中に非ボックス化型を書くことができる。
<programlisting>
  type Pr = (# Int, Int #)

  h :: Int -> Pr
  h x = (# x, x #)
</programlisting>
</para></listitem>

<listitem><para>
型シノニムをforall型に適用できる。
<programlisting>
  type Foo a = a -> a -> Bool
 
  f :: Foo (forall b. b->b)
</programlisting>
この型シノニムを展開すると、<literal>f</literal>の型は(GHCでは)合法なものになる。
<programlisting>
  f :: (forall b. b->b) -> (forall b. b->b) -> Bool
</programlisting>
</para></listitem>

<listitem><para>
部分適用された型シノニムに型シノニムを適用することができる。
<programlisting>
  type Generic i o = forall x. i x -> o x
  type Id x = x
  
  foo :: Generic Id []
</programlisting>
この型シノニムを展開すると、<literal>foo</literal>の型は(GHCでは)合法なものになる。
<programlisting>
  foo :: forall x. x -> [x]
</programlisting>
</para></listitem>

</itemizedlist>
</para>

<para>
GHCは現在、型シノニムを展開する前に類検査を行っている。(ただしこれも変えることはできるだろう)
</para>
<para>
型シノニムを展開した後、GHCは、以下のような、類検査では発見できない誤りを見つけるために、型に対して妥当性検査を行う。
<itemizedlist>
<listitem><para>
型構築子がforall付きの型に適用されている。
</para></listitem>
<listitem><para>
矢印の左側に非ボックス化タプルがある。
</para></listitem>
<listitem><para>
部分適用された型シノニムがある。
</para></listitem>
</itemizedlist>
従って、例えば、以下のものは拒絶される。
<programlisting>
  type Pr = (# Int, Int #)

  h :: Pr -> Int
  h x = ...
</programlisting>
これは、関数の矢印の左側に非ボックス化タプルが現れることをGHCが許していないからである。
</para>
</sect2>


<sect2 id="existential-quantification">
<title>存在量化されたデータ構築子
</title>

<para>
データ型の宣言において存在量化を使うという考えはPerryによって提案され、Hope+に実装された。(Nigel Perry, <emphasis>The Implementation of Practical Functional Programming Languages</emphasis>, PhD Thesis, University of London, 1991)。数年の間Lennart Augustssonの<command>hbc</command>というHaskellコンパイラで利用でき、非常に便利なことが明らかになった。ここに考え方を示す。次のような宣言があったとしよう。
</para>

<para>

<programlisting>
  data Foo = forall a. MkFoo a (a -> Bool)
           | Nil
</programlisting>

</para>

<para>
データ型<literal>Foo</literal>は、次のような型を持つ二つの構築子を持っている。
</para>

<para>

<programlisting>
  MkFoo :: forall a. a -> (a -> Bool) -> Foo
  Nil   :: Foo
</programlisting>

</para>

<para>
<function>MkFoo</function>の型において、型変数<literal>a</literal>がデータ型自体(ただの<literal>Foo</literal>である)のなかに現れないことに注意せよ。例えば、以下の式は正しい。
</para>

<para>

<programlisting>
  [MkFoo 3 even, MkFoo 'c' isUpper] :: [Foo]
</programlisting>

</para>

<para>
ここで、<literal>(MkFoo 3 even)</literal>は、一つの整数と、整数を<literal>Bool</literal>に写す関数<function>even</function>を梱包しており、<literal>(MkFoo 'c' isUpper)</literal>は、一つの文字と、対応する関数を梱包している。これらはどちらも<literal>Foo</literal>型のものであり、一つのリストに入れることができる。
</para>

<para>
<literal>Foo</literal>型の値に対してできることは何だろうか？特に、<function>MkFoo</function>に対してパターン照合を行うと何が起きるだろうか？
</para>

<para>

<programlisting>
  f (MkFoo val fn) = ???
</programlisting>

</para>

<para>
ここで、<literal>val</literal>と<function>fn</function>について判っているのは、<literal>val</literal>の型と<function>fn</function>の引数の型が同じだということだけなので、できることは(実質的に)<function>fn</function>を<literal>val</literal>に適用して真偽値を得ることだけである。以下のように。
</para>

<para>

<programlisting>
  f :: Foo -> Bool
  f (MkFoo val fn) = fn val
</programlisting>

</para>

<para>
結局できたことは、不特定の型の値を、それを操作するいくつかの関数と一緒に梱包して、梱包物の集まりを統一的に扱うことである。この方法で、オブジェクト指向っぽいプログラミングのかなりの部分を行うことができる。
</para>

<sect3 id="existential">
<title>どこが存在的か？
</title>

<para>
これが<emphasis>存在</emphasis>量化とどう関係するのだろうか？これは単に、<function>MkFoo</function>が以下の(ほぼ)同型な型を持っているというだけのことである。
</para>

<para>

<programlisting>
  MkFoo :: (exists a . (a, a -> Bool)) -> Foo
</programlisting>

</para>

<para>
しかし、Haskellプログラマは上に挙げた通常の<emphasis>全称</emphasis>量化された型を考えれば十分である。こうすれば、存在量化のための構文要素を新しく加える必要がない。
</para>

</sect3>

<sect3 id="existential-with-context">
<title>存在型と型クラス</title>

<para>
簡単な拡張として、構築子の前に任意の文脈を置くことを可能にするというのがある。
</para>

<para>

<programlisting>
data Baz = forall a. Eq a => Baz1 a a
         | forall b. Show b => Baz2 b (b -> b)
</programlisting>

</para>

<para>
これらの二つの構築子は、予想される通りの型を持つ。
</para>

<para>

<programlisting>
Baz1 :: forall a. Eq a => a -> a -> Baz
Baz2 :: forall b. Show b => b -> (b -> b) -> Baz
</programlisting>

</para>

<para>
ただし、<function>Baz1</function>に関するパターン照合では、照合された値を等値比較できるし、<function>Baz2</function>に関するパターン照合では、照合された最初の値を文字列に変換することができる(関数を適用することもできる)。従って以下のプログラムは合法である。
</para>

<para>

<programlisting>
  f :: Baz -> String
  f (Baz1 p q) | p == q    = "Yes"
               | otherwise = "No"
  f (Baz2 v fn)            = show (fn v)
</programlisting>

</para>

<para>
操作的にいうと、辞書渡し式の実装では、構築子<function>Baz1</function>と<function>Baz2</function>は<literal>Eq</literal>と<literal>Show</literal>の辞書をそれぞれ記憶しておかなければならず、パターン照合の時にはそれを展開する。
</para>

</sect3>

<sect3 id="existential-records">
<title>レコード構築子</title>

<para>
以下のように、存在量化とレコード構文を併用することができる。

<programlisting>
data Counter a = forall self. NewCounter
    { _this    :: self
    , _inc     :: self -> self
    , _display :: self -> IO ()
    , tag      :: a
    }
</programlisting>
ここで<literal>tag</literal>は公開フィールドであり、正しく型のついた選択関数である<literal>tag :: Counter a -&gt; a</literal>が付属している。型<literal>self</literal>は外部からは隠蔽されている。<literal>_this</literal>、<literal>_inc</literal>、<literal>_display</literal>を関数として適用しようとするとコンパイル時エラーになる。言い替えると、<emphasis>GHCは、フィールドの型が、存在量化された型変数に言及していない場合に限り、そのフィールドへの選択関数を定義する</emphasis>。(この例では選択関数が定義されていないフィールドにアンダースコアを用いているが、これは単なるプログラミングの上での様式であり、GHCは関知しない)
</para>

<para>
これらの隠されたフィールドを利用するには、ヘルパ関数をいくつか作らないといけない。

<programlisting>
inc :: Counter a -> Counter a
inc (NewCounter x i d t) = NewCounter
    { _this = i x, _inc = i, _display = d, tag = t } 

display :: Counter a -> IO ()
display NewCounter{ _this = x, _display = d } = d x
</programlisting>

ここで、異なる実装を持つ複数のカウンタを定義することができる。

<programlisting>
counterA :: Counter String 
counterA = NewCounter
    { _this = 0, _inc = (1+), _display = print, tag = "A" }

counterB :: Counter String 
counterB = NewCounter
    { _this = "", _inc = ('#':), _display = putStrLn, tag = "B" }

main = do
    display (inc counterA)         -- prints "1"
    display (inc (inc counterB))   -- prints "##"
</programlisting>

現在のところ、レコード更新構文はHaskell 98データ型に対してのみサポートされている。従って、下記の関数は動作しない。

<programlisting>
-- 不正。とりあえず明示的にNewCounterを使うべし
setTag :: Counter a -> a -> Counter a
setTag obj t = obj{ tag = t }
</programlisting>

</para>

</sect3>


<sect3>
<title>制約</title>

<para>
存在量化された構築子を使う上で、何種類かの制約がある。
</para>

<para>

<itemizedlist>
<listitem>

<para>
パターン照合では、個々の存在量化された型変数について、新しい、相互に異なる型が導入される。これらの型は他の型と単一化されることはなく、パターン照合のスコープの外に抜け出すこともできない。例えば、以下の断片は正しくない。


<programlisting>
f1 (MkFoo a f) = a
</programlisting>


ここでは、<literal>a</literal>が<function>f1</function>の結果なので、<function>MkFoo</function>で束縛された型が「抜け出して(escape)」いる。なぜこれが間違っているか納得する方法の一つは、<function>f1</function>がどういう型を持つか問うことである。


<programlisting>
  f1 :: Foo -> a             -- おかしい！
</programlisting>


結果型の「<literal>a</literal>」とはなんだ？もちろん次のようなことを言いたい訳ではない。


<programlisting>
  f1 :: forall a. Foo -> a   -- 間違い
</programlisting>


これは、元のプログラムが間違っているというだけのことである。下記はまた別の種類の誤りである。


<programlisting>
  f2 (Baz1 a b) (Baz1 p q) = a==q
</programlisting>


<literal>a==b</literal>とか<literal>p==q</literal>と言うのは構わないが、<literal>a==q</literal>は間違っている。二つの<function>Baz1</function>構築子に由来する異なった型を等値比較しているからである。


</para>
</listitem>
<listitem>

<para> 存在量化された構築子に関するパターン照合を<literal>let</literal>や<literal>where</literal>グループの束縛で行うことはできない。従って次は不正である。


<programlisting>
  f3 x = a==b where { Baz1 a b = x }
</programlisting>

代わりに、<literal>case</literal>式を使うこと。

<programlisting>
  f3 x = case x of Baz1 a b -> a==b
</programlisting>

一般に、存在量化された構築子についてパターン照合できるのは、<literal>case</literal>式においてと、関数定義のパターンにおいてのみである。この制約は実は実装上の理由による。束縛グループを型検査するのは既に悪夢であり、存在型はさらに問題をややこしくする。さらに、モジュールの最上位での存在的パターン束縛には意味がない。存在量化された型が抜け出すのを防ぐ方法がはっきりしないからである。このため、今のところ、述べやすい制約が科せられている。私はこの制約がどれくらい厄介か見定めているところである。

</para>
</listitem>
<listitem>

<para>
<literal>newtype</literal>宣言に存在量化を使うことはできない。よって以下は不正である。


<programlisting>
  newtype T = forall a. Ord a => MkT a
</programlisting>

理由: <literal>T</literal>の値は<literal>Ord t</literal>の辞書と<literal>t</literal>型の値の組で表現されねばならないが、これは<literal>newtype</literal>は具体的な表現形式を持つべきではないという考えに反する。<literal>newtype</literal>の代わりに<literal>data</literal>を使うことで、全く同じ効果・効率を得ることができる。多重定義が関係しないときは、存在量化された<literal>newtype</literal>を許す根拠がある。代わりに<literal>data</literal>を使うと実際に実装コストが掛かるからである。しかし、単一フィールドの存在量化構築子はあまり使い道がない。このため、何か説得力のある理由がない限り、この単純な制約(<literal>newtype</literal>では存在的なもの禁止)が有効である。

</para>
</listitem>
<listitem>

<para>
<literal>deriving</literal>を使って、存在量化されたデータ構築子のあるデータ型のインスタンスを定義することはできない。

理由: 大抵の場合、これは意味をなさない。例。

<programlisting>
data T = forall a. MkT [a] deriving( Eq )
</programlisting>

標準的な方法で<literal>Eq</literal>を導出するには、二つの<function>MkT</function>構築子の内容を等値比較する必要がある。

<programlisting>
instance Eq T where
  (MkT a) == (MkT b) = ???
</programlisting>

しかし<varname>a</varname>と<varname>b</varname>の型は異なるので、比較することができない。導出されたインスタンスが意味をなすような例を考えることも不可能ではないが、このような宣言をまとめて禁止した方が単純だと考えられる。自分でインスタンスを定義しましょう！
</para>
</listitem>

</itemizedlist>

</para>

</sect3>

</sect2>

<!-- ====================== Generalised algebraic data types =======================  -->

<sect2 id="gadt-style">
<title>構築子のシグネチャを明示してデータ型を宣言する</title>

<para>GHCは、構築子の型シグネチャを明示的に与えることで代数的データ型を宣言することを許している。例えば、次のように。
<programlisting>
  data Maybe a where
      Nothing :: Maybe a
      Just    :: a -> Maybe a
</programlisting>
この形式は「GADT様式の宣言」と呼ばれる。これは、一般化代数データ型(<xref linkend="gadt"/>に記述がある)が、この形式でしか宣言できないからである。</para>
<para>GADT様式の構文は存在型(<xref linkend="existential-quantification"/>)の一般化になっていることに注意。例えば、以下の二つの宣言は同等である。
<programlisting>
  data Foo = forall a. MkFoo a (a -> Bool)
  data Foo' where { MKFoo :: a -> (a->Bool) -> Foo' }
</programlisting>
</para>
<para>標準のHaskell-98の構文で宣言できるデータ型は全てGADT様式でも宣言できる。どちらを選ぶかは大部分スタイルの問題だが、GADT様式の宣言が通常と異なる重要な点が一つある。データ構築子に関するクラス制約の扱いが異なるのである。具体的に言うと、構築子に型クラス文脈が与えられたとき、パターン照合によってその文脈が使えるようになる。例を示す。
<programlisting>
  data Set a where
    MkSet :: Eq a => [a] -> Set a

  makeSet :: Eq a => [a] -> Set a
  makeSet xs = MkSet (nub xs)

  insert :: a -> Set a -> Set a
  insert a (MkSet as) | a `elem` as = MkSet as
                      | otherwise   = MkSet (a:as)
</programlisting>
<literal>mkSet</literal>を構築子として使う(例えば<literal>makeSet</literal>の定義)と、期待通り<literal>(Eq a)</literal>の制約が生じる。新機能は、<literal>MkSet</literal>についてのパターン照合(<literal>insert</literal>の定義にあるようなもの)の際、文脈<literal>(Eq a)</literal>が<emphasis>使えるようになる</emphasis>ということである。実装の言葉で言うと、<literal>MkSet</literal>には、渡された<literal>(Eq a)</literal>の辞書を持っておくための隠れたフィールドがある。それで、パターン照合の際には、照合の右辺からその辞書を使うことができる。この例では、こうして得られたEqの辞書を、<literal>elem</literal>の呼び出しによって生成されたEq制約を満足させるのに使うので、<literal>insert</literal>の型自体には<literal>Eq</literal>制約が現れない。</para>
<para>
例えば、応用の一つとして、辞書をオブジェクト化するというのがある。
<programlisting>
   data NumInst a where
     MkNumInst :: Num a => NumInst a

   intInst :: NumInst Int
   intInst = MkNumInst

   plus :: NumInst a -> a -> a -> a
   plus MkNumInst p q = p + q
</programlisting>
ここで、<literal>NumInst a</literal>型の値は、<literal>(Num a)</literal>の辞書を明示的にしたものと同等である。
</para>
<para>これは全て、<xref linkend="existential-with-context"/>の構文を使って宣言された構築子についても当てはまる。例えば、上のデータ型<literal>NumInst</literal>は次のように定義しても同等である。
<programlisting>
   data NumInst a 
      = Num a => MkNumInst (NumInst a)
</programlisting>
存在型を定義する場合と違って<literal>forall</literal>がないことに注意。これは、<literal>Num</literal>が、データ型の全称修飾された型変数<literal>a</literal>を制約するからである。ひとつの構築子に、全称と存在の両方の型変数があってもよい。例えば、以下の二つの宣言は同等である。
<programlisting>
   data T1 a 
	= forall b. (Num a, Eq b) => MkT1 a b
   data T2 a where
	MkT2 :: (Num a, Eq b) => a -> b -> T2 a
</programlisting>
</para>
<para>これらの振る舞いは全て、Haskell 98の、データ型宣言における文脈の奇妙な扱い(Haskell 98レポートの4.2.1節)と対照を為す。Haskell 98では、次の定義によって、上の<literal>MkSet</literal>と同じ型の<literal>MkSet'</literal>が得られる。
<programlisting>
  data Eq a => Set' a = MkSet' [a]
</programlisting>
しかし、<literal>MkSet'</literal>についてのパターン照合では、<literal>(Eq a)</literal>の制約が<emphasis>使えるようになる</emphasis>のでなく、<literal>(Eq a)</literal>の制約を<emphasis>要求する</emphasis>のだ。変な振る舞いだが、GHCはこれを忠実に実装している。しかし、GADT様式の宣言なら、GHCの振る舞いはずっと有用で、同時にずっと直感的である。</para>
<para>
この節の残りの部分では、GADT様式のデータ型宣言について、さらなる詳細を与える。

<itemizedlist>
<listitem><para>
各データ構築子の結果の型は、定義しようとしている型構築子で始まっていなければならない。構築子の結果の型が全て<literal>T a1 ... an</literal>という形(ただし<literal>a1 .. an</literal>は相異なる型変数)なら、それは<emphasis>通常の</emphasis>データ型であり、そうでなければ<emphasis>一般化された</emphasis>データ型(<xref linkend="gadt"/>)である。
</para></listitem>

<listitem><para>
それぞれの構築子の型シグネチャは独立していて、通常通り暗黙に全称量化される。別々の構築子には異なる全称量化の型変数があっても良いし、異なる型制約があっても良い。例えば、これは問題ない。
<programlisting>
  data T a where
    T1 :: Eq b => b -> T b
    T2 :: (Show c, Ix c) => c -> [c] -> T c
</programlisting>
</para></listitem>

<listitem><para>
Haskell 98様式のデータ型宣言と異なり、「<literal>data Set a where</literal>」というヘッダに出てくる型変数にはスコープがない。実際、代わりに類シグネチャを書くこともできる。
<programlisting>
  data Set :: * -> * where ...
</programlisting>
あるいは、この二つを混ぜるのでも良い。
<programlisting>
  data Foo a :: (* -> *) -> * where ...
</programlisting>
型変数(与えられるなら)は明示的に類付けされていても良いので、<literal>Foo</literal>のヘッダを以下のように書くこともできる。
<programlisting>
  data Foo a (b :: * -> *) where ...
</programlisting>
</para></listitem>


<listitem><para>
正確性注釈は、構築子の型の中の当然の場所に付けることができる。
<programlisting>
  data Term a where
      Lit    :: !Int -> Term Int
      If     :: Term Bool -> !(Term a) -> !(Term a) -> Term a
      Pair   :: Term a -> Term b -> Term (a,b)
</programlisting>
</para></listitem>

<listitem><para>
GADT様式のデータ型宣言で<literal>deriving</literal>節を使うことができる。例えば、以下の二つの宣言は同等である。
<programlisting>
  data Maybe1 a where {
      Nothing1 :: Maybe1 a ;
      Just1    :: a -> Maybe1 a
    } deriving( Eq, Ord )

  data Maybe2 a = Nothing2 | Just2 a 
       deriving( Eq, Ord )
</programlisting>
</para></listitem>

<listitem><para>
GADT様式のデータ型宣言においてレコード構文を使うこともできる。

<programlisting>
  data Person where
      Adult { name :: String, children :: [Person] } :: Person
      Child { name :: String } :: Person
</programlisting>
通常と同じように、<literal>f</literal>というフィールドを持つ全ての構築子に関して、フィールド<literal>f</literal>の型が(α変換を法として)等しくなければならない。
</para>
<para>
今のところ、レコード更新はGADTではまだ不可能である。このため、サポートされているのは、レコードの構築、選択、パターン照合だけである。例を示す。
<programlisting>
  aPerson = Adult { name = "Fred", children = [] }

  shortName :: Person -> Bool
  hasChildren (Adult { children = kids }) = not (null kids)
  hasChildren (Child {})                  = False
</programlisting>
</para></listitem>

<listitem><para> 
Haskell 98風のレコード構文で存在型を宣言する場合(<xref linkend="existential-records"/>)と同様に、レコード選択関数は、選択関数にうまく型が付くフィールドについてのみ生成される。以下は、存在的レコードの節の例をGADT様式にしたものである。
<programlisting>
data Counter a where
    NewCounter { _this    :: self
               , _inc     :: self -> self
               , _display :: self -> IO ()
               , tag      :: a
               }
        :: Counter a
</programlisting>
前と同じように、ここで生成される選択関数は唯一つ、<literal>tag</literal>についてものである。ただし、パターン照合とレコード構築では、相変わらず全てのフィールド名を使うことができる。
</para></listitem>
</itemizedlist></para>

 </sect2>
 
<sect2 id="gadt">
<title>一般化代数データ型(GADT)</title>

<para>一般化代数データ型は、通常の代数的データ型を拡張して、構築子がより多様な型を持てるようにしたものである。以下は例である。
<programlisting>
  data Term a where
      Lit    :: Int -> Term Int
      Succ   :: Term Int -> Term Int
      IsZero :: Term Int -> Term Bool	
      If     :: Term Bool -> Term a -> Term a -> Term a
      Pair   :: Term a -> Term b -> Term (a,b)
</programlisting>
通常のデータ型の場合と違って、構築子の結果の型が<literal>Term a</literal>だとは限らないことに注意。この一般化のお陰で、<literal>Term</literal>について、正しく型の付いた<literal>eval</literal>関数を書くことができる。
<programlisting>
  eval :: Term a -> a
  eval (Lit i) 	    = i
  eval (Succ t)     = 1 + eval t
  eval (IsZero t)   = eval t == 0
  eval (If b e1 e2) = if eval b then eval e1 else eval e2
  eval (Pair e1 e2) = (eval e1, eval e2)
</programlisting>
GADTの鍵となる点は、<emphasis>パターン照合によって型の精密化が起こる</emphasis>ことである。以下の例を考える。
<programlisting>
  eval :: Term a -> a
  eval (Lit i) =  ...
</programlisting>
等式の右辺では、<literal>a</literal>が精密化されて<literal>Int</literal>になる。これこそが売りである。型付け規則の正確な規定は利用の手引きが目指すところではないが、設計は、<ulink url="http://research.microsoft.com/%7Esimonpj/papers/gadt/">Simple unification-based type inference for GADTs</ulink>, (ICFP 2006)で述べられているものによく倣っている。
一般的な原則はこうである。<emphasis>精密化は、ユーザ供給の型注釈を基にしてのみ起こる</emphasis>。従って、もし<literal>eval</literal>に型シグネチャが与えられなければ、型精密化は起こらず、大量の不明瞭なエラーが発生することだろう。一方、精密化はかなり一般的である。例えば、以下のものがあったとしよう。
<programlisting>
  eval :: Term a -> a -> a
  eval (Lit i) j =  i+j
</programlisting>
このパターン照合で、型<literal>a</literal>が精密化されて(構築子<literal>Lit</literal>の型にしたがって)<literal>Int</literal>になる。この精密化は<literal>j</literal>の型とこの<literal>case</literal>式の結果の型にも及ぶ。だから<literal>i+j</literal>という加算は合法である。
</para>
<para>
これらの例と、他の多くの例が、Hongwei XiとTim Sheardによる論文群で与えられている。<ulink url="http://www.haskell.org/haskellwiki/GADT">wikiには</ulink>もっと長い入門文書があるし、Ralf Hinzeの<ulink url="http://www.informatik.uni-bonn.de/~ralf/publications/With.pdf">Fun with phantom types</ulink>にもいくつか例がある。
これらの論文ではGHCに実装されているのと異なる記法を使っていることがあるので注意。
</para>
<para>
この節の残りの部分では、GADTをサポートするGHCの拡張について概観する。この拡張は<option>-XGADTs</option>で有効になる。<option>-XGADTs</option>フラグを使うと、<option>-XRelaxedPolyRec</option>も同時に設定される。
<itemizedlist>
<listitem><para>
GADTは、GADT様式の構文(<xref linkend="gadt-style"/>)でなければ宣言できない。Haskell 98の古いデータ宣言の構文では、常に通常のデータ型が宣言される。各構築子の結果の型は定義しようとしている型構築子で始まっていなければならないが、GADTについては、その型への引数は任意のmonotypeで良い。例えば、上の<literal>Term</literal>型において、各構築子の型は<literal>Term ty</literal>で終わっていなければならないが、<literal>ty</literal>が型変数である必要はない。(例えば構築子<literal>Lit</literal>)。
</para></listitem>

<listitem><para>
GADT様式の構文を使って通常の代数的データ型を宣言することは可能である。GADTをGADTたらしめるのは構文ではなく、結果の型が単なる<literal>T a b</literal>でないような構築子の存在である。
</para></listitem>

<listitem><para>
GADTについて<literal>deriving</literal>節を使うことはできない。通常のデータ型だけである。
</para></listitem>

<listitem><para>
<xref linkend="gadt-style"/>で述べたように、レコード記法にも対応している。例えば以下のように。
<programlisting>
  data Term a where
      Lit    { val  :: Int }      :: Term Int
      Succ   { num  :: Term Int } :: Term Int
      Pred   { num  :: Term Int } :: Term Int
      IsZero { arg  :: Term Int } :: Term Bool	
      Pair   { arg1 :: Term a
             , arg2 :: Term b
             }                    :: Term (a,b)
      If     { cnd  :: Term Bool
             , tru  :: Term a
             , fls  :: Term a
             }                    :: Term a
</programlisting>
ただし、GADTについては以下の制約が追加される。フィールド<literal>f</literal>を持つ全ての構築子は、(α変換を法として)同じ結果型を持たねばならない。だから、上の例なら、<literal>num</literal>フィールドと<literal>arg</literal>フィールドをまとめて一つの名前にすることはできない。フィールド型はどちらも<literal>Term Int</literal>だが、実は選択関数は異なる型を持っている。

<programlisting>
  num :: Term Int -> Term Int
  arg :: Term Bool -> Term Int
</programlisting>
</para></listitem>

<listitem><para>
GADTから得られたデータ構築子に対してパターン照合を行なう(例えば<literal>case</literal>式で)場合、以下の規則が適用される。
<itemizedlist>
<listitem><para>検査対象(訳注: scrutinee; case式ならcaseとinの間に書かれる式のこと)の型は固い型でなければならない。</para></listitem>
<listitem><para><literal>case</literal>式全体の型は固い型でなければならない。</para></listitem>
<listitem><para><literal>case</literal>の各分岐で言及される自由変数の型はすべて固い型でなければならない。</para></listitem>
</itemizedlist>
型が「固い(rigid)」というのは、それが束縛された地点において、コンパイラにとって完全に既知であることをいう。ある変数の型が固い型であることを確実にしたいなら、もっとも簡単な方法はそれに型シグネチャを与えることである。より精密な詳細については<ulink url="http://research.microsoft.com/%7Esimonpj/papers/gadt">Simple unification-based type inference for GADTs</ulink>を見よ。GHCに実装されている基準はAppendixに載っている。

</para></listitem>

</itemizedlist>
</para>

</sect2>
</sect1>

<!-- ====================== End of Generalised algebraic data types =======================  -->

<sect1 id="deriving">
<title>「deriving」機構への拡張</title>

<sect2 id="deriving-inferred">
<title>deriving節について推論される文脈</title>

<para>
Haskell Reportは、正確にどんな場合に<literal>deriving</literal>節が有効かについてはっきりしない。例を示す。
<programlisting>
  data T0 f a = MkT0 a         deriving( Eq )
  data T1 f a = MkT1 (f a)     deriving( Eq )
  data T2 f a = MkT2 (f (f a)) deriving( Eq )
</programlisting>
自然生成された<literal>Eq</literal>のコードは以下のようなインスタンス宣言になるだろう。
<programlisting>
  instance Eq a         => Eq (T0 f a) where ...
  instance Eq (f a)     => Eq (T1 f a) where ...
  instance Eq (f (f a)) => Eq (T2 f a) where ...
</programlisting>
最初のものは明らかに問題ない。二番目も、それほど明らかではないが、問題ない。三番目はHaskell 98でなく、インスタンスの停止性を損なう危険がある。
</para>
<para>
GHCは保守的な立場を採っている。最初の二つは受け付けるが、三番目は受け付けない。規則はこうである。推論された文脈中の各制約は、型変数のみから成っていなければならず、型変数に重複があってもならない。
</para>
<para>
この規則はフラグに関係なく適用される。もっと風変りな文脈が必要なら、<link linkend="stand-alone-deriving">独立derivingの機構</link>を使って自分で書くことができる。
</para>
</sect2>

<sect2 id="stand-alone-deriving">
<title>独立deriving宣言</title>

<para>
GHCは単独の<literal>deriving</literal>宣言を受け付けるようになった。これは<literal>-XStandaloneDeriving</literal>で有効になる。
<programlisting>
  data Foo a = Bar a | Baz String

  deriving instance Eq a => Eq (Foo a)
</programlisting>
構文は通常のインスタンス宣言と同じであるが、(a)<literal>deriving</literal>キーワードを使うことと、(b)<literal>where</literal>部がないことが異なる。通常のインスタンス宣言でするのと全く同じように、文脈(この例では文脈は<literal>(Eq a)</literal>)を指定しなければならない。(これは、データ型宣言に付属したderiving節において文脈が推論されるのと対照を為す)。<literal>deriving instance</literal>の宣言は、形式と停止性に関して、通常のインスタンス宣言が従うのと同じ規則に従い、同じフラグで制御される。<xref linkend="instance-decls"/>を見よ。</para>
<para>
<literal>data</literal>宣言に付属する<literal>deriving</literal>宣言と異なり、インスタンスはデータ型よりも限定的になり得る(<literal>-XFlexibleInstances</literal>を使うことを前提にすれば。<xref linkend="instance-rules"/>)。例として以下を考えよ。
<programlisting>
  data Foo a = Bar a | Baz String

  deriving instance Eq a => Eq (Foo [a])
  deriving instance Eq a => Eq (Foo (Maybe a))
</programlisting>
これによって<literal>(Foo [a])</literal>と<literal>(Foo (Maybe a))</literal>についての導出インスタンスが生成されるが、それ以外の<literal>(Foo (Int,Bool))</literal>といった型は<literal>Eq</literal>のインスタンスにならない。
</para>

<para>この独立deriving構文は、通常の<literal>deriving</literal>がnewtypeに対して一般化された(<xref linkend="newtype-deriving"/>)のと全く同じように一般化される。例えば次のように。
<programlisting>
  newtype Foo a = MkFoo (State Int a)

  deriving instance MonadState Int Foo
</programlisting>
GHCは常に、インスタンスの<literal>最後</literal>のパラメタ(この例では<literal>Foo</literal>)を導出対象の型として扱う。
</para>

</sect2>

<sect2 id="deriving-typeable">
<title><literal>Typeable</literal>クラスおよび<literal>Data</literal>クラスについてのderiving節</title>

<para>
Haskell 98では、プログラマがデータ型宣言に「<literal>deriving( Eq, Ord )</literal>」と付け加えれば、これらのクラスの標準的なインスタンス宣言が生成される。Haskell 98では、<literal>deriving</literal>節に現れることのできるクラスは標準の<literal>Eq</literal>、<literal>Ord</literal>、<literal>Enum</literal>、<literal>Ix</literal>、<literal>Bounded</literal>、<literal>Read</literal>、<literal>Show</literal>だけである。
</para>
<para>
GHCはこれを拡張し、新たに二つのクラスが自動的に導出できるようにする。(ただし、<option>-XDeriveDataTypeable</option>フラグが必要)。<literal>Typeable</literal>と<literal>Data</literal>である。これらのクラスはそれぞれライブラリモジュール<literal>Data.Typeable</literal>と<literal>Data.Generics</literal>で定義されており、<literal>deriving</literal>節で使うためには、あらかじめ適切なクラスをスコープに導入しておく必要がある。
</para>
<para><literal>Typeable</literal>のインスタンスは、データ型の型パラメタの数が七個以下で、その全てが類<literal>*</literal>を持っているときのみ導出できる。これは、<literal>Typeable</literal>クラスが<ulink url="http://research.microsoft.com/%7Esimonpj/papers/hmap/gmap2.ps">Scrap More Boilerplate: Reflection, Zips, and Generalised Casts</ulink>で述べられている形を使って導出されているからである。(この論文の7.4節では、使われる複数の<literal>Typeable</literal>について述べられているが、ライブラリが提供するのは<literal>Typeable1</literal>から<literal>Typeable7</literal>までだけである)。この条件を満たさない場合、プログラマは、そのデータ構築子に合った類を持つ<literal>TypeableX</literal>を書き、そのデータ型についてのインスタンスを手で書くことができる。</para>
</sect2>

<sect2 id="newtype-deriving">
<title>newtypeについての導出インスタンスの一般化</title>

<para>
<literal>newtype</literal>を使って抽象型を定義するとき、元の型からインスタンスをいくつか継承させたいと思うことがあるかもしれない。Haskell 98では、<literal>Eq</literal>、<literal>Ord</literal>、<literal>Enum</literal>、<literal>Bounded</literal>に関しては導出を使うことでインスタンスを継承させられるが、それ以外の型については明示的なインスタンス宣言を書かなければならない。例えば、次のように定義したとする。

<programlisting>
  newtype Dollars = Dollars Int 
</programlisting>

そして、<literal>Dollars</literal>に対して数値演算を使いたいなら、次のようにして明示的に<literal>Num</literal>のインスタンスを書かなければならない。

<programlisting>
  instance Num Dollars where
    Dollars a + Dollars b = Dollars (a+b)
    ...
</programlisting>
このインスタンスは、<literal>newtype</literal>の構築子を適用したり排除したりしているだけである。特にくやしいのは、この構築子は実行時には存在しないので、このインスタンス宣言が定義する辞書は<literal>Int</literal>の辞書と<emphasis>全体を通して同じ</emphasis>で、違いはこちらの方がより遅いことだけだ、という点である。
</para>


<sect3> <title>deriving節の一般化</title>
<para>
このようなことをしなくても、GHCでは、<option>-XGeneralizedNewtypeDeriving</option>を使ってこの種のインスタンスは導出できるようになった。従って、次のように書くことができる。
<programlisting>
  newtype Dollars = Dollars Int deriving (Eq,Show,Num)
</programlisting>

そして、実装では、<literal>Dollars</literal>について<literal>Int</literal>のものと<emphasis>同じ</emphasis><literal>Num</literal>用辞書が使われる。概念上は、コンパイラは次のような形のインスタンス宣言を導出している。

<programlisting>
  instance Num Int => Num Dollars
</programlisting>

このインスタンスは、型にしたがって<literal>newtype</literal>構築子を付けたり外したりすることだけを行う。
</para>
<para>

構築子クラスのインスタンスも同様に導出することができる。例えば、次のように、状態と失敗を扱うモナド変換子を実装したとしよう。

<programlisting>
  instance Monad m => Monad (State s m) 
  instance Monad m => Monad (Failure m)
</programlisting>
Haskell 98では、次のようにしてパーサモナドを定義することができる。
<programlisting>
  type Parser tok m a = State [tok] (Failure m) a
</programlisting>

これは、上記のインスタンス宣言によって自動的にモナドになっている。拡張を使うと、<literal>Monad</literal>クラスのインスタンスを書くことなくパーサの型を抽象型にすることができる。次のようになる。

<programlisting>
  newtype Parser tok m a = Parser (State [tok] (Failure m) a)
                         deriving Monad
</programlisting>
この場合、導出されたインスタンス宣言は次の形になる。
<programlisting>
  instance Monad (State [tok] (Failure m)) => Monad (Parser tok m) 
</programlisting>

<literal>Monad</literal>は構築子クラスなので、このインスタンスはこのnewtypeの<emphasis>部分適用</emphasis>であり、左辺全体ではない。インスタンス宣言の文脈を生成するためにこの型宣言が「η変換」されたと考えることができる。
</para>
<para>

多引数型クラスについても、そのnewtypeがクラスの最後の引数であることを条件に、インスタンスを導出できる。この場合、<literal>deriving</literal>節に現れるのはクラスの「部分適用」形である。例として、次のようなクラスがあったとする。

<programlisting>
  class StateMonad s m | m -> s where ... 
  instance Monad m => StateMonad s (State s m) where ... 
</programlisting>
このとき、次のようにして、<literal>Parser</literal>についての<literal>StateMonad</literal>のインスタンスを導出できる。
<programlisting>
  newtype Parser tok m a = Parser (State [tok] (Failure m) a)
                         deriving (Monad, StateMonad [tok])
</programlisting>

導出インスタンスは、部分適用されたクラスを最後にnewtypeに適用し、完全に適用された形にすることで得られる。次のようにである。

<programlisting>
  instance StateMonad [tok] (State [tok] (Failure m)) =>
           StateMonad [tok] (Parser tok m)
</programlisting>
</para>
<para>

この拡張の結果、newtype宣言での導出インスタンスは、<literal>Show</literal>と<literal>Read</literal>(これらは元の型とは異なる振る舞いをする)を除いた全てのクラスについて一様に扱われ(、元となった型の辞書を再利用することで実装され)る。
</para>
</sect3>

<sect3> <title>より精密な規定</title>
<para>
導出されたインスタンス宣言が構築されるときの規則は以下である。次の宣言(型シノニムを展開した後のもの)を考える。

<programlisting>
  newtype T v1...vn = T' (t vk+1...vn) deriving (c1...cm) 
</programlisting>

ここで、
 <itemizedlist>
<listitem><para>
<literal>ci</literal>はクラスの部分適用であり、<literal>C t1'...tj'</literal>という形をとる。ただし<literal>C</literal>の引数の数は<literal>j+1</literal>である。すなわち、<literal>C</literal>はただ一つの引数を欠いている。
</para></listitem>
<listitem><para>
  <literal>k</literal>は、<literal>ci (T v1...vk)</literal>の類が正しくなるように選ばれる。
</para></listitem>
<listitem><para>
  型<literal>t</literal>は任意の型である。
</para></listitem>
<listitem><para>
  型変数<literal>vk+1...vn</literal>は、<literal>t</literal>にも、<literal>ci</literal>にも出現しない。
</para></listitem>
<listitem><para>
  <literal>ci</literal>はどれも、<literal>Read</literal>、<literal>Show</literal>、<literal>Typeable</literal>、<literal>Data</literal>のいずれでもない。これらのクラスは型やその構築子を「素通りする」べきものではない。これらのクラスをnewtypeに導出することもできるが、それは通常の方法で行われ、この新しい機構は利用されない。
</para></listitem>
</itemizedlist>
このとき、それぞれの<literal>ci</literal>に対して、導出されるインスタンス宣言は以下のようになる。
<programlisting>
  instance ci t => ci (T v1...vk)
</programlisting>
<emphasis>うまくいかない</emphasis>例として、以下のものを考えてみよう。
<programlisting>
  newtype NonMonad m s = NonMonad (State s m s) deriving Monad 
</programlisting>
ここで、次のインスタンスを導出することはできない。
<programlisting>
  instance Monad (State s m) => Monad (NonMonad m) 
</programlisting>

なぜなら、型変数<literal>s</literal>が<literal>State s m</literal>に現れており、「η変換」によって消し去ることができないからである。この<literal>deriving</literal>節が拒絶されるのは良いことである。<literal>NonMonad m</literal>は実際、同じ理由で、モナドではないからである。正しい型を持つ<literal>>>=</literal>を定義しようとしてみよ。できないはずである。
</para>
<para>

また、クラス引数の<emphasis>順序</emphasis>が重要になることに注意。これは、最後の引数についてしかインスタンスの導出ができないからである。もし上記の<literal>StateMonad</literal>が次のように定義されていたなら、上のように<literal>Parser</literal>型についてインスタンスを導出することは不可能だった。

<programlisting>
  class StateMonad m s | m -> s where ... 
</programlisting>

我々は、多引数型クラスには通常ひとつの「主要な」引数があり、それについてのインスタンス導出が最も重視される、という仮説を立てている。
</para>
<para>最後に、これら全ては<literal>Read</literal>、<literal>Show</literal>、<literal>Typeable</literal>、<literal>Data</literal>の各クラスには適用されない。これらには、組込みの導出規則(Haskellレポートの4.3.3節)が適用される。(<literal>Eq</literal>、<literal>Ord</literal>、<literal>Ix</literal>、<literal>Bounded</literal>の各標準クラスについては、どちらの方法を使うかは重要でない)
</para>
</sect3>

</sect2>

</sect1>


<!-- TYPE SYSTEM EXTENSIONS -->
<sect1 id="type-class-extensions">
<title>クラスおよびインスタンス宣言</title>
 
<sect2 id="multi-param-type-classes">
<title>クラス宣言</title>

<para>
この節及び次の節では、型クラスに関するGHCの拡張を説明する。論文<ulink url="http://research.microsoft.com/~simonpj/Papers/type-class-design-space/" >Type classes: exploring the design space</ulink> (Simon Peyton Jones, Mark Jones, Erik Meijer)には、多くの背景事項が書かれている。
</para>
<para>
これらの拡張は全て<option>-fglasgow-exts</option>フラグで有効になる。
</para>

<sect3>
<title>多引数の型クラス</title>
<para>
以下のような、多引数の型クラスが許される。


<programlisting>
  class Collection c a where
    union :: c a -> c a -> c a
    ...etc.
</programlisting>

</para>
</sect3>

<sect3>
<title>クラス宣言のスーパークラス</title>

<para>
クラス宣言の文脈(スーパークラスを導入する)には、クラス階層に循環があってはならないということ以外に、制約はない。従って、以下のようなクラス宣言が認められる。


<programlisting>
  class Functor (m k) => FiniteMap m k where
    ...

  class (Monad m, Monad (t m)) => Transform t m where
    lift :: m a -> (t m) a
</programlisting>


</para>
<para>
Haskell 98と同様に、クラス階層に循環があってはならない。しかし、「循環があってはならない」というのは、スーパークラスという関係についてのみである。例えば、以下は問題ない。


<programlisting>
  class C a where {
    op :: D b => a -> b -> b
  }

  class C a => D a where { ... }
</programlisting>


この場合、<literal>C</literal>は<literal>D</literal>のスーパークラスであるが、<literal>C</literal>のクラス演算である<literal>op</literal>が<literal>D</literal>に言及するのは問題ない。(<literal>D</literal>を<literal>C</literal>のスーパークラスにするのは駄目である)
</para>
</sect3>




<sect3 id="class-method-types">
<title>クラスメソッドの型</title>

<para>
Haskell 98では、クラスメソッドの型中に、クラス型変数についての制約が現れることを禁止している。次のような場合である。
<programlisting>
  class Seq s a where
    fromList :: [a] -> s a
    elem     :: Eq a => a -> s a -> Bool
</programlisting>
Haskell 98では<literal>elem</literal>の型は不正である。制約<literal>Eq a</literal>がクラス型変数(この場合<literal>a</literal>)のみを拘束しているからである。GHCはこの制限を撤廃する(<option>-XConstrainedClassMethods</option>フラグ)。
</para>


</sect3>
</sect2>

<sect2 id="functional-dependencies">
<title>関数従属
</title>

<para>関数従属は、&ldquo;<ulink url="http://citeseer.ist.psu.edu/jones00type.html">Type Classes with Functional Dependencies</ulink>&rdquo;, Mark P. Jones, In Proceedings of the 9th European Symposium on Programming, ESOP 2000, Berlin, Germany, March 2000, Springer-Verlag LNCS 1782,で述べられている通りに実装されている。
</para>
<para>
関数従属は、クラス宣言の構文中で次のように垂直線を使うことで導入される。
<programlisting>
  class (Monad m) => MonadState s m | m -> s where ...

  class Foo a b c | a b -> c where ...
</programlisting>
本来もっと説明があるべきだが、(まだ)ない。必要なら文句をいってほしい。
</para>

<sect3><title>関数従属に関する諸規則</title>
<para>
クラス宣言では、全てのメソッドについて、そのメソッドの型中の自由変数から、クラス型変数が全て(<xref linkend="type-restrictions"/>で言われている意味で)到達可能でなければならない。例を挙げる。

<programlisting>
  class Coll s a where
    empty  :: s
    insert :: s -> a -> s
</programlisting>

これは正しくない。<literal>empty</literal>の型が<literal>a</literal>に言及していないからである。関数従属を使ってこの型変数に到達できるようにすることができる。
<programlisting>
  class Coll s a | s -> a where
    empty  :: s
    insert :: s -> a -> s
</programlisting>

あるいは、次のように<literal>Coll</literal>を書き換えても良い。

<programlisting>
  class Coll s a where
    empty  :: s a
    insert :: s a -> a -> s a
</programlisting>


<literal>a</literal>の集積物の型(<literal>(s a)</literal>)と要素の型である<literal>a</literal>との間につながりを作った訳である。
これがうまく行かないこともある。そういうときは、次のようにクラスを分割することができる。


<programlisting>
  class CollE s where
    empty  :: s

  class CollE s => Coll s a where
    insert :: s -> a -> s
</programlisting>
</para>
</sect3>


<sect3>
<title>関数従属の背景</title>

<para>なぜ関数従属が必要か、およびどのようにそれを使うか、についての以下の解説は、Hugsの利用者手引きから採られたものである。Mark Jonesが親切にも許可をくれたので、ここに(多少の改変の上で)転載する。
</para>
<para> 

以下のクラスを考えてみよう。これは、何かの集まりを表す型を扱うライブラリの一部という意図である。
<programlisting>
   class Collects e ce where
       empty  :: ce
       insert :: e -> ce -> ce
       member :: e -> ce -> Bool
</programlisting>
型変数eは要素型を表しており、ceはコンテナの型を表している。この枠組みの下で、このクラスのインスタンスとして、リストや特性関数(どちらも、等値比較可能なあらゆる要素型の集まりを表現できる)、ビット集合(文字の集まりを表現できる)、ハッシュ表(ハッシュ関数のあるあらゆる要素型の集まりを表現できる)を持ちたいとしよう。標準的な実装の詳細を省くと、これは次のような宣言になる。
<programlisting>
   instance Eq e => Collects e [e] where ...
   instance Eq e => Collects e (e -> Bool) where ...
   instance Collects Char BitSet where ...
   instance (Hashable e, Collects a ce)
              => Collects e (Array Int ce) where ...
</programlisting>
クラスを定義し、いくつかの有用な実装を定義したわけで、ここまでのところ順調である。残念ながら、このクラス宣言にはいくつかの重大な問題がある。第一に、empty関数の型が曖昧である。
<programlisting>
   empty :: Collects e ce => ce
</programlisting>
「曖昧」だというのは、型変数eが<literal>=&gt;</literal>の左辺に現れるにもかかわらず、右辺には現れないということである。これが問題なのは、Haskellの多重定義の理論的基礎によると、曖昧な型のある項には、明確に定義された意味が与えられることを保証できないからである。
</para>
<para>
この問題を回避するだけなら、クラス宣言からemptyメンバを取り除くだけで良い。しかし、残りのメンバであるinsertとmemberも、型こそ曖昧でないが、使おうとすると問題が発生する。例えば、以下の例を考えてほしい。
<programlisting>
   f x y = insert x . insert y
   g     = f True 'a'
</programlisting>
これに対して、GHCは以下の型を推論する。
<programlisting>
   f :: (Collects a c, Collects b c) => a -> b -> c -> c
   g :: (Collects Bool c, Collects Char c) => c -> c
</programlisting>
fではxとyの値を一つの集まりに対して順番にinsertしようとしているが、fの型は、この二つの変数が異なる型を持つことを許している。我々が
表現しようとしているのが、ただ一つの型の値のみを含む集まりだとすれば、これは明らかに不正確な型である。さらに悪いことに、gの定義は、型エラーを起こすことなくコンパイルを通過する。結果として、このコードの誤りはすぐには明らかにされない。これが発覚するのはgを使おうとしたときで、これは別のモジュールであることさえあり得る。
</para>

<sect4><title>構築子クラスを使ってみる</title>

<para>
上記の問題点に直面して、Haskellプログラマの中には次のようなクラス宣言を使うのはどうかと考える者もいるだろう。
<programlisting>
   class Collects e c where
      empty  :: c e
      insert :: e -> c e -> c e
      member :: e -> c e -> Bool
</programlisting>
決定的な違いは、ここでは、集まりの型(元のクラス宣言のce)ではなく、型構築子cに関して抽象化しているという点である。集まりの型はcを使ってc eと表される。これで、上記の直接的な問題は解決された。emptyの型は<literal>Collects e c => c e</literal>であり、これは曖昧ではない。
</para>
<para>
前節の関数fには、より正確な型が与えられる。
<programlisting>
   f :: (Collects e c) => e -> e -> c e -> c e
</programlisting>
前節の関数gは、意図したとおり、型エラーで拒絶される。これは、fの型が、二つの引数が異なる型を持つことを許していないからである。従って、これは、複数引数の型クラスが、曖昧さの問題無しに、実際的にかなりうまく行く例である。しかし欠陥もある。このCollectsクラスは、元々のクラスの意図と比べて著しく一般性に欠ける。上記の<literal>Collects</literal>に対する四つのインスタンスのうち、このCollectsに対して動作するのはリストのインスタンス一つだけである。ある型構築子cと要素型eについてc eという形で書けるのはこれだけだからである。
</para>
</sect4>

<sect4><title>関数従属を加える</title>

<para>
より有用なCollectsクラスを得るために、Hugsでは、複数引数の型クラスにおいて引数間の従属関係(依存関係)をプログラマが指定できるようにする機構が提供される。(理論的基礎や先行研究に興味のある読者向け: 従属性情報の利用は、Chen、Hudak、Oderskyの提出した「パラメータ付き型クラス」の提案を一般化した物とも捉えられるし、Mark Jonesによるqualified typeの「improvement」のためのフレームワークの特別な場合とも捉えられる。基礎となる考えは原稿[implparam]で、より理論的で抽象的な土台で考察されている。そこでは、暗黙なパラメタ化のためのシステムの一般的な設計空間の中の一点として扱われている)。抽象的な例として、次のような宣言を考えよう。
<programlisting>
   class C a b where ...
</programlisting>
このようにすると、Cは型(aやbの類によっては型構築子)上の二項関係と捉えられる。次の例のように、クラス定義中に節を追加して、引数間の従属性に関する情報を追加することができる。
<programlisting>
   class D a b | a -> b where ...
   class E a b | a -> b, b -> a where ...
</programlisting>
ここで|とwhereの間に書かれている<literal>a -&gt; b</literal>という記法(関数の型と混同してはならない)は、引数aが引数bをただ一つ定めるということを意味しており、例えば「aがbを決める」と読む。従ってDは単なる関係ではなく、(部分)関数である。同様に、Eの定義中の二つの従属関係から、Eが(部分的な)一対一写像を表していることがわかる。
</para>
<para>
より一般的には、従属関係は<literal>x1 .. xn -&gt; y1 ... ym</literal>という形をとる。ここでx1, ..., xnおよびy1, ..., yn<!-- 訳注: ynでなくym? -->(n&gt;0、m&gt;0)は型変数であり、全てのy引数はx引数によって一意に決定されることを意味する。従属関係のどちらかの辺に複数の変数が現れるなら、<literal>t -&gt; a b</literal>のようにスペースで区切る。上記のEの例のように、一つのクラスについて複数の従属関係をコンマで区切って並べることができる。書き得る従属関係の中には冗長なものもあるが、これらの一部は拒絶される。全く役に立たない上に、プログラム中の誤りを反映しているかもしれないからである。このような従属関係の例として<literal>a -&gt; a</literal>、<literal>a -&gt; a a</literal>、<literal>a -&gt; </literal>などが挙げられる。複数の従属関係が与えられているとき、例えば<literal>a-&gt;b</literal>, <literal>b-&gt;c</literal>, <literal>a-&gt;c</literal>のような場合、複数の従属関係を組み合わせることで残りものが言え、やはり冗長だが、このような場合はエラーとされない。従属関係はクラス宣言にのみ現れ、言語の中のその他の場所には現れないことに注意。特に、インスタンス宣言、クラス制約、型はどれも全く変化を被らない。
</para>
<para>
クラス宣言に従属関係を含めることで、プログラマは多引数の型クラスをより精密に指定できる。一方、コンパイラは、プログラム中のどの一点においても、そこから見えるインスタンスの集合が宣言された従属性に整合していることを保証しなければならない。例えば、以下の二つのインスタンス宣言は一つのスコープに同時に現れてはならない。Dに関する従属性に反するからである。どちらか一方であれば問題ない。
<programlisting>
   instance D Bool Int where ...
   instance D Bool Char where ...
</programlisting>
また、以下のような宣言は単独でも禁止される。
<programlisting>
   instance D [a] b where ...
</programlisting>
ここでの問題は、特定の[a]に対して、複数のbが関連づけられ、結果としてDの定義で指定された従属性に反することである。
<programlisting>
   instance D t s where ...
</programlisting>
より一般的に、上のような宣言があったとすると、sには、tに現れる型変数しか現れてはならない。これで、tの型が既知であれば、sも一意に決定できることになる。
</para>
<para>
従属性情報を書くことの利点は、曖昧性の問題無しに、より一般的な多引数型クラスを書くことができ、より精密な型の恩恵に与ることができることである。これを解り易く示すために、集まりのクラスの例に戻り、<literal>Collects</literal>の定義に単純な従属性注釈を付け加えよう。
<programlisting>
   class Collects e ce | ce -> e where
      empty  :: ce
      insert :: e -> ce -> ce
      member :: e -> ce -> Bool
</programlisting>
ここで、<literal>ce -&gt; e</literal>という従属関係は、要素の型eが集まりの型ceによって一意に定まることを指定している。引数の類はどちらも*であることに注意してほしい。つまりこれは構築子クラスではない。また、最初に挙げたCollectsのインスタンスは全てこの新しい定義の下で有効である。
</para>
<para>
元々の定義を使ったときに現れた曖昧性の問題はどうだろうか。empty関数の型はCollects e ce => ceのままだが、もはやこれを曖昧だとみなす必要はない。変数eは=>記号の右辺に現れていないが、Collectsクラスの従属関係から、これがceによって一意に決定されることがわかる。ceは=>記号の右側に現れているので、emptyが使われるときの文脈から得られる情報で、ceとeの両方の型を曖昧さなく決定できる。一般的に、ある型が曖昧だとされるのは、=>の左辺に、右辺の変数によって(直接または間接に)一意に決定されない変数が存在するときだけである。
</para>
<para>
利用者定義の関数により正確な型を与えることにも従属性は寄与する。これにより、より早く誤りを見つけることができるようになり、プログラマがぐちゃぐちゃな型と格闘しなくても良いようになる。前に挙げたfの定義を思い出して欲しい。
<programlisting>
   f x y = insert x y = insert x . insert y
</programlisting>
これに対して、最初に得た型は次であった。
<programlisting>
   f :: (Collects a c, Collects b c) => a -> b -> c -> c
</programlisting>
しかし、Collectsについての従属性情報を使うと、aとbが等しくなければならないと推論できる。両者とも、同じように第一引数がcであるCollects制約<!-- 訳注: 引数の順序がおかしい -->の第二引数に現れているからである。これにより、fに対して、より短く、より本性を反映した型を推論することができる。
<programlisting>
   f :: (Collects a c) => a -> a -> c -> c
</programlisting>
同様の方法で、前に挙げたgの定義は型エラーとして処理される。
</para>
<para>
ここでは少しの例しか挙げなかったが、多引数型クラスは、従属性情報を付け加えることで、より実用的になり、曖昧さの問題が排除され、より一般的なインスタンスの集合を受け入れられるようになった、ということが明らかだろう。
</para>
</sect4>
</sect3>
</sect2>

<sect2 id="instance-decls">
<title>インスタンス宣言</title>

<sect3 id="instance-rules">
<title>インスタンス宣言に関する規則の緩和</title>

<para>インスタンス宣言は以下のような形をとる
<screen>
  instance ( <replaceable>assertion</replaceable><subscript>1</subscript>, ..., <replaceable>assertion</replaceable><subscript>n</subscript>) =&gt; <replaceable>class</replaceable> <replaceable>type</replaceable><subscript>1</subscript> ... <replaceable>type</replaceable><subscript>m</subscript> where ...
</screen>
「<literal>=&gt;</literal>」より前の部分は<emphasis>文脈</emphasis>であり、「<literal>=&gt;</literal>」より後の部分はこのインスタンス宣言の<emphasis>頭部</emphasis>と呼ばれる。
</para>

<para>
Haskell 98では、インスタンス宣言の頭部は<literal>C (T a1 ... an)</literal>という形でなければならない。ここで、<literal>C</literal>はクラス、<literal>T</literal>は型構築子、<literal>a1 ... an</literal>は相異なる型変数である。さらに、インスタンス宣言中の文脈における表明は<literal>C a</literal>という形でなければならない。ここで<literal>a</literal>は頭部に出現する型変数である。
</para>
<para>
<option>-XFlexibleInstances</option>フラグが使われていると、この規則は大幅に緩められる。まず、複数引数の型クラスが許される。次に、インスタンス宣言の文脈および頭部は、下記の規則に従う限り、(類の正しい)任意の表明<literal>(C t1 ... tn)</literal>から成っていてよい。
<orderedlist>
<listitem><para>
Paterson条件: 文脈中の各表明に対して、次が求められる。
<orderedlist>
<listitem><para>その表明に、頭部よりも多く出現する型変数があってはならない</para></listitem>
<listitem><para>その表明中の構築子と変数の数の合計(同じ物でも複数回数える)が、頭部中のそれよりも少なくなければならない。</para></listitem>
</orderedlist>
</para></listitem>

<listitem><para>対応範囲条件(Coverage Condition)。クラス中のそれぞれの関数従属<replaceable>tvs</replaceable><subscript>left</subscript> <literal>-&gt;</literal> <replaceable>tvs</replaceable><subscript>right</subscript>に対して、S(<replaceable>tvs</replaceable><subscript>right</subscript>)中の型変数は全てS(<replaceable>tvs</replaceable><subscript>left</subscript>)にも現れなければならない。ただし、Sは、クラス宣言中の型変数を対応するインスタンス宣言中の型に対応させる置換写像である。
</para></listitem>
</orderedlist>
これらの制約により、文脈の簡約に終わりがあることが保証される。一回簡約するごとに最悪でも構築子一つ分問題が小さくなるからである。<option>-XUndecidableInstances</option>フラグ(<xref linkend="undecidable-instances"/>)を与えれば、Paterson条件と対応範囲条件の両方が撤廃される。これらの制限がある理由についての沢山の背景資料が、論文<ulink  url="http://research.microsoft.com/%7Esimonpj/papers/fd%2Dchr/">Understanding functional dependencies via Constraint Handling Rules</ulink>に見つかる。</para>

<para>
例を挙げると、以下のものは問題ない。
<programlisting>
  instance C Int [a]          -- 複数引数
  instance Eq (S [a])         -- 頭部に構造のある型

      -- 頭部に同じ型変数が複数回出現
  instance C4 a a => C4 [a] [a] 
  instance Stateful (ST s) (MutVar s)

      -- 頭部は型変数のみから成っていても良い
  instance C a
  instance (Eq a, Show b) => C2 a b

      -- 文脈中に型変数以外のものがあっても良い
  instance Show (s a) => Show (Sized s a)
  instance C2 Int a => C3 Bool [a]
  instance C2 Int a => C3 [a] b
</programlisting>
一方で、下記は禁止される。
<programlisting>
      -- 文脈の表明が頭部より小さくない
  instance C a => C a where ...
      -- (C b b)に頭部よりも多くのbの出現がある
  instance C b b => Foo [b] where ...
</programlisting>
</para>

<para>
これと同じ制約が、<literal>deriving</literal>節で生成されたインスタンスにも適用される。従って、下記のものは許される。
<programlisting>
  data MinHeap h a = H a (h a)
    deriving (Show)
</programlisting>
これは、導出された以下のインスタンスが上記の規則に整合するからである。
<programlisting>
  instance (Show a, Show (h a)) => Show (MinHeap h a)
</programlisting>
</para>

<para>
上記の規則によって、ある便利なイディオムが可能になる。重複インスタンス宣言を許すとき、より特化したインスタンスが当てはまらないときに適用される「デフォルトのインスタンス」があると非常に便利である。
<programlisting>
  instance C a where
    op = ... -- デフォルト
</programlisting>
</para>
</sect3>

<sect3 id="undecidable-instances">
<title>決定不能インスタンス</title>

<para>
<xref linkend="instance-rules"/>の規則でさえも厄介なことがある。例えば、次のようにして「クラスシノニム」のような効果を得たいと思うかもしれない。
<programlisting>
  class (C1 a, C2 a, C3 a) => C a where { }

  instance (C1 a, C2 a, C3 a) => C a where { }
</programlisting>
次のようなシグネチャがあったとする。
<programlisting>
  f :: (C1 a, C2 a, C3 a) => ...
</programlisting>
これは上記のものを使えば次のように書ける。
<programlisting>
  f :: C a => ...
</programlisting>
関数従属(<xref linkend="functional-dependencies"/>)についての制約は特に面倒である。通常の規則では禁止されているものの、頭部に現れない型変数を文脈中で使いたいと思うことがあるだろう。以下のような場合である。
<programlisting>
  class HasConverter a b | a -> b where
     convert :: a -> b
   
  data Foo a = MkFoo a

  instance (HasConverter a b,Show b) => Show (Foo a) where
     show (MkFoo value) = show (convert value)
</programlisting>
しかし、これは危険な領域である。例えば、以下のものは、型検査器をループさせる。
<programlisting>
  class D a
  class F a b | a->b
  instance F [a] [[a]]
  instance (D c, F a c) => D [a]   -- 「c」は頭部で言及されていない
</programlisting>
同様に、対応範囲条件を撤廃したいと思うかもしれない。
<programlisting>
  class Mul a b c | a b -> c where
  	(.*.) :: a -> b -> c

  instance Mul Int Int Int where (.*.) = (*)
  instance Mul Int Float Float where x .*. y = fromIntegral x * y
  instance Mul a b c => Mul a [b] [c] where x .*. v = map (x.*.) v
</programlisting>
三番目のインスタンス宣言は対応範囲条件に従っていない。実際、以下の(やや奇妙な)例では、型推論がループに陥る。これは、<literal>(Mul a [b] b)</literal>という制約を要求するからである。 
<programlisting>
  f = \ b x y -> if b then x .*. [y] else y
</programlisting>
</para>
<para>
これにもかかわらず、GHCは、より自由な規則の下で実験することを許している。<option>-XUndecidableInstances</option> <indexterm><primary>-XUndecidableInstances option</primary></indexterm>という実験的なフラグを使えば、Paterson条件と対応範囲条件(<xref linkend="instance-rules"/>に記述がある)の両方が撤廃される。停止性は、深さ固定の再帰スタックを使うことで保証される。スタックの深さを超過した場合、バックトレースのようなものが表示される。この時、<option>-fcontext-stack=</option><emphasis>N</emphasis>で、スタックをより深くすることもできる。
</para>

</sect3>


<sect3 id="instance-overlap">
<title>重複インスタンス</title>
<para>
一般に、<emphasis>GHCでは、型クラス制約を解決するのにどのインスタンス宣言を使えば良いかが曖昧さなく決まることが要求される</emphasis>。この挙動を変更するフラグが二つある。<option>-XOverlappingInstances</option> <indexterm><primary>-XOverlappingInstances </primary></indexterm>と<option>-XIncoherentInstances</option> <indexterm><primary>-XIncoherentInstances </primary></indexterm>である。この節ではこれらを扱う。これらは両方とも動的フラグであり、(望むなら<literal>OPTIONS_GHC</literal>プラグマを使って)モジュール単位で設定することができる。(<xref linkend="source-file-options"/>)</para>
<para>
例えば、<literal>C Int Bool</literal>という制約を解決しようとするときは、全てのインスタンス宣言について、その頭部を具体化して、この制約と照合しようと試みられる。例として、以下のようなインスタンス宣言があったとしよう。
<programlisting>
  instance context1 => C Int a     where ...  -- (A)
  instance context2 => C a   Bool  where ...  -- (B)
  instance context3 => C Int [a]   where ...  -- (C)
  instance context4 => C Int [Int] where ...  -- (D)
</programlisting>
インスタンス(A)および(B)は制約<literal>C Int Bool</literal>に適合するが、(C)や(D)は適合しない。照合の際、インスタンス宣言の文脈(<literal>context1</literal>など)は無視される。GHCのデフォルトの振る舞いは、<emphasis>解決中の制約に適合するインスタンスがただ一つ存在しなければならない</emphasis>というものである。<emphasis>潜在的な</emphasis>重複(例えば(A)と(B)の両方がスコープにある場合)があっても問題はない。特定の制約に複数のインスタンスが適合して初めてエラーが報告される。
</para>

<para>
<option>-XOverlappingInstances</option>フラグは、最も特殊性の高いインスタンスが存在することを条件に、複数のインスタンスの適合を認めるものである。例えば、<literal>C Int [Int]</literal>には(A)、(C)、(D)の各インスタンスが適合するが、最後のものの特殊性が最も高いので、これが選ばれる。最も特殊性の高いものがない場合は、プログラムが拒絶される。
</para>
<para>
ただし、GHCは重複インスタンスから特定のものを選ぶことに関しては保守的である。例。
<programlisting>
  f :: [b] -> [b]
  f x = ...
</programlisting>
<literal>f</literal>の右辺から、<literal>C Int [b]</literal>という制約を得たとしよう。しかし、GHCはインスタンス(C)を使うことはない。なぜなら、<literal>f</literal>の呼び出しによっては、<literal>b</literal>が<literal>Int</literal>に実体化するかも知れず、その場合は(D)が最も特殊性の高いインスタンスになるからである。よって、GHCはこのプログラムを拒絶する。(<option>-XIncoherentInstances</option>フラグを追加すると、GHCは、後々のインスタンス化についての問題を指摘することなく、(C)を選ぶようになる)。
</para>
<para>
<literal>f</literal>に型シグネチャを与えたので、<literal>f</literal>が指定した型を持っていることをGHCが<emphasis>検査</emphasis>せねばならなかったことに注意。そうでなく、型シグネチャを与えず、GHCに<emphasis>推論</emphasis>してもらったとしよう。この場合、GHCは<literal>C Int [b]</literal>という制約を単純化することは避ける(前と同じ理由)が、プログラムを拒絶することはなく、以下の型を推論する。
<programlisting>
  f :: C Int [b] => [b] -> [b]
</programlisting>
これは、どのインスタンスを選ぶかの問題を<literal>f</literal>の呼び出し側まで遅延する。その時には、型<literal>b</literal>についてより多くが知られているだろう。
<link linkend="flexible-contexts"><option>-XFlexibleContexts</option></link>フラグを使えば、この型シグネチャを自分で書くことができる。
</para>
<para>
インスタンス宣言自体についても、まったく同じ状況が発生し得る。以下のものがあるとしよう。
<programlisting>
  class Foo a where
     f :: a -> a
  instance Foo [b] where
     f x = ...
</programlisting>
さらに、前と同じように、制約<literal>C Int [b]</literal>が<literal>f</literal>の右辺から発生するとする。制約<literal>C Int [b]</literal>は複数のインスタンス宣言に適合するので、前と同様にGHCはこの制約を解決する方法が分からないとしてこのインスタンスを拒絶する。解決策は、インスタンス宣言の文脈にこの制約を加えて、選択を後回しにすることである。次のように。
<programlisting>
  instance C Int [b] => Foo [b] where
     f x = ...
</programlisting>
(これをするには<link linkend="instance-rules"><option>-XFlexibleInstances</option></link>が必要である)
</para>
<para>
重複インスタンスや非整合(incoherent)インスタンスになるかどうかは、<emphasis>インスタンス宣言</emphasis>の性質であり、そのモジュールがコンパイルされるときに<option>-XOverlappingInstances</option>と<option>-XIncoherentInstances</option>が有効になっていたかどうかで決まる。インスタンス宣言をインポートし、利用するモジュールでは、フラグはどちらも必要ない。特に、インスタンス発見の過程では、以下が成り立つ。
<itemizedlist>
<listitem><para>
この過程で、あるインスタンス宣言が無視されるのは、(a)より特殊性の高いものが見付かった、かつ(b)そのインスタンス宣言が<option>-XOverlappingInstances</option>付きでコンパイルされていた場合である。特殊性の高い方のインスタンスがコンパイルされたときのフラグは関係ない。
</para></listitem>
<listitem><para>
問題となっている制約に対して、あるインスタンス宣言が、適合はしないものの単一化する場合を考えてみよう。この場合、制約がさらに具体化すると、そのインスタンス宣言が適合する可能性がある。通常、GHCは、これを理由として、他の制約<!-- 訳注: インスタンスの誤り? -->を採用しない。しかし、もしそのインスタンス宣言が<option>-XIncoherentInstances</option>付きでコンパイルされているなら、GHCはこの「単一化するか？」の検査を行わない。
</para></listitem>
</itemizedlist>
これらの規則によって、ライブラリの作者は、重複インスタンスに依存したライブラリを、利用者がそれについて知らなくても良いように設計することができる。
</para>
<para>
あるインスタンスが<option>-XOverlappingInstances</option>なしでコンパイルされると、より特殊性の高いインスタンスでそのインスタンスを部分的に覆い隠すことは不可能である。場合によってはこれは不便かもしれない。もしかしたら、<emphasis>覆い隠される</emphasis>方のインスタンスではなく<emphasis>覆い隠す</emphasis>方のインスタンスがフラグ付きでコンパイルされなければならない、という規則にした方が良いのかもしれない。あるいは、利用地点で<option>-XOverlappingInstances</option>フラグが使われていれば、元のインスタンス宣言がどのようにコンパイルされたかにかかわらず、利用地点においてそれを覆い隠すインスタンスを宣言し、使うことを認めるべきかもしれない。(ただし、利用地点の正確な位置を特定するのは難しいことがあるのに注意)。我々はこれらの点に関するフィードバックを待っている。
</para>
<para><option>-XIncoherentInstances</option>フラグを使うと、<option>-XOverlappingInstances</option>フラグは自動的に有効になる。逆は真でない。
</para>
</sect3>

<sect3>
<title>インスタンス頭部に型シノニムを使う</title>

<para>
<emphasis>Haskell 98と異なり、インスタンスの頭部には型シノニムを使っても良い</emphasis>。(インスタンスの「頭部」とはインスタンス宣言中で「=>」より後の部分である)。他の場合と同様、型シノニムは、その定義の右辺の型を書くための略記法に過ぎない。例えば、以下は合法である。


<programlisting>
  type Point = (Int,Int)
  instance C Point   where ...
  instance C [Point] where ...
</programlisting>


一方、以下のものを付け加えると、コンパイラは、重複(実は全く同じ)インスタンスだとして文句をいう。


<programlisting>
  instance C (Int,Int) where ...
</programlisting>


他の場合と同様に、型シノニムは完全に適用されていなければならない。例えば、以下のように書くことはできない。


<programlisting>
  type P a = [[a]]
  instance Monad P where ...
</programlisting>


この設計上の決定は、他の全てのものと独立であり、簡単に覆すことができるが、私には合理的に思える。

</para>
</sect3>

</sect2>

<sect2 id="overloaded-strings">
<title>文字列リテラルの多重定義</title>

<para>
GHCは<emphasis>文字列リテラルの多重定義</emphasis>に対応している。通常、文字列リテラルは型<literal>String</literal>を持つが、文字列リテラルの多重定義を有効にする(<literal>-XOverloadedStrings</literal>で)と、文字列リテラルが<literal>(IsString a) => a</literal>という型を持つようになる。
</para>
<para>
これは、通常の文字列構文を使って、パックされた文字列やその他の文字列的な型を書くことができるということである。文字列リテラルは整数リテラルとほとんど同じように振る舞う。つまり、式とパターンの両方で使うことができる。リテラルがパターンで使われた場合、整数リテラルと同じ方法で、等値性のテストに置き換えられる。
</para>
<para>
クラス<literal>IsString</literal>は次のように定義されている。
<programlisting>
class IsString a where
    fromString :: String -> a
</programlisting>
定義済みのインスタンスは一つだけで、文字列が通常通りに使えるようにする、自明なものである。
<programlisting>
instance IsString [Char] where
    fromString cs = cs
</programlisting>
<literal>IsString</literal>クラスはデフォルトでスコープに無い。明示的に言及したい(例えば、インスタンス宣言のために)なら、<literal>GHC.Exts</literal>モジュールからインポートすることができる。
</para>
<para>
<option>-XOverloadedStrings</option>が指定されたときは、Haskellのデフォルト化機構が拡張されて、文字列リテラルにも対応するようになる。具体的には以下の通り。
<itemizedlist>
<listitem><para>
デフォルト宣言におけるそれぞれの型は、<literal>Num</literal><emphasis>または</emphasis><literal>IsString</literal>のインスタンスでなければならない。
</para></listitem>

<listitem><para>
標準のデフォルト化規則(<ulink url="http://www.haskell.org/onlinereport/decls.html#sect4.3.4">Haskell Report, Section 4.3.4</ulink>)は次のように拡張される。デフォルト化は、全ての未解決の制約が標準のクラス<emphasis>または</emphasis><literal>IsString</literal>についてであって、少くとも一つが数値クラス<emphasis>または</emphasis><literal>IsString</literal>である場合に適用される。
</para></listitem>
</itemizedlist>
</para>
<para>
小さい例を示す。
<programlisting>
module Main where

import GHC.Exts( IsString(..) )

newtype MyString = MyString String deriving (Eq, Show)
instance IsString MyString where
    fromString = MyString

greet :: MyString -> MyString
greet "hello" = "world"
greet other = other

main = do
    print $ greet "hello"
    print $ greet "fool"
</programlisting>
</para>
<para>
パターン照合は等値比較に翻訳されるので、パターン照合のためには<literal>Eq</literal>を導出することが必要だということに注意。
</para>
</sect2>
</sect1>

<sect1 id="type-families">
<title>型の族</title>

<para><firstterm>添字付けされた型の族</firstterm>は、型レベルのプログラミングを容易にするための新しいGHC拡張である。型の族は、<firstterm>関連データ型</firstterm>(&ldquo;<ulink url="http://www.cse.unsw.edu.au/~chak/papers/CKPM05.html">Associated Types with Class</ulink>&rdquo;, M. Chakravarty, G. Keller, S. Peyton Jones, and S. Marlow. In Proceedings of &ldquo;The 32nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL'05)&rdquo;, pages 1-13, ACM Press, 2005)および<firstterm>関連型シノニム</firstterm>(&ldquo;<ulink url="http://www.cse.unsw.edu.au/~chak/papers/CKP05.html">Type Associated Type Synonyms</ulink>&rdquo;. M. Chakravarty, G. Keller, and S. Peyton Jones. In Proceedings of &ldquo;The Tenth ACM SIGPLAN International Conference on Functional Programming&rdquo;, ACM Press, pages 241-253, 2005)の一般化である。型の族自体は論文&ldquo;<ulink url="http://www.cse.unsw.edu.au/~chak/papers/SPCS08.html">Type Checking with Open Type Functions</ulink>&rdquo;, T. Schrijvers, S. Peyton-Jones, M. Chakravarty, and M. Sulzmann, in Proceedings of &ldquo;ICFP 2008: The 13th ACM SIGPLAN International Conference on Functional Programming&rdquo;, ACM Press, pages 51-62, 2008 Functional Programming&rdquo;, ACM Press, pages 241-253, 2005)に記述されている。型の族は、要するに、型で添字付けされたデータ型と、型についての名前の付いた関数を提供する。これらは、総称(generic)プログラミングや高度にパラメタ化されたライブラリインタフェース、さらには、依存型と同様に、静的な情報の強化されたインタフェースに有用である。また、型の族は関数従属の代わりとなるものとも見なされている。関数従属では型レベルのプログラミングを関係的に行うのに対して、型の族はより関数的な様式を可能にする。
</para>
<para>添字付けされた型の族(indexed type family)、短くいうと型族(type family)は、型の集合を表すような型構築子である。集合の要素は、型族構築子に型引数(<firstterm>型添字</firstterm>と呼ぶ)を与えることで記述される。通常のパラメタ付きの型構築子と族構築子との違いは、パラメタ多相な関数と型クラスの(アドホック多相な)メソッドとの違いによく似ている。パラメタ多相な関数はあらゆる具体的な型に対して等しく振る舞うのに対し、クラスのメソッドはクラスの型パラメタに依存して振る舞いを変える。同様に、通常の型構築子はあらゆる具体的な型に対して同じデータ表現を使うことになるが、型族構築子は異なる型添字に対して異なる表現型を持つことができる。</para>
<para>添字付けされた型の族には二つの系統がある。<firstterm>データ族</firstterm>と<firstterm>型シノニム族</firstterm>である。これらは、それぞれ代数的データ型と型シノニムを添字付けされた型の族にしたものである。データの族のインスタンスとしてはデータ型とnewtypeがありえる。
</para>
<para>型の族は<option>-XTypeFamilies</option>フラグによって有効になる。GHCで型の族を使うことについてのさらなる情報が<ulink url="http://www.haskell.org/haskellwiki/GHC/Indexed_types">型の族についてのHaskell wikiのページ</ulink>にある。
</para>

<sect2 id="data-families">
  <title>データ族</title>

  <para>データ族には次の二つの系統がある。(1)最上位で定義されるもの (2)型クラスの中に現れるもの(この場合、これは関連型と言われる)。前者の方が一般性の高い系統である。なぜなら、型添字がクラスのパラメータと一致する必要がないからである。一方、後者の方が明確に構造化されたコードにつながりやすく、なんらかの型インスタンスが(もしかすると意図せずに)省略された場合、コンパイラが警告を発する。以下では常に、まず一般的な最上位の形式について議論し、その後で関連型に課せられる追加の制約を扱う。
  </para>

  <sect3 id="data-family-declarations"> 
    <title>データ族宣言</title>

    <para>添字付けされたデータ族は次のようなシグネチャによって導入される。
<programlisting>
data family GMap k :: * -> *
</programlisting>
この特別な<literal>family</literal>が、族を標準的なデータ宣言から区別する。結果の類注釈は省略可能であり、省かれた場合は通常同様に<literal>*</literal>が使われる。例を示す。
<programlisting>
data family Array e
</programlisting>
名前の付いた引数にも必要なら明示的な類シグネチャを与えることができる。[http://www.haskell.org/ghc/docs/latest/html/users_guide/gadt.html GADT宣言]の場合と同様、名前付き引数は完全に省略可能なので、<literal>Array</literal>を次のように宣言することもできる。
<programlisting>
data family Array :: * -> *
</programlisting>
    </para>

    <sect4 id="assoc-data-family-decl">
      <title>関連データ族宣言</title>
      <para>データ族が型クラスの一部として宣言される場合、特別子<literal>family</literal>は使わない。<literal>GMap</literal>の宣言は次のような形をとる。
<programlisting>
class GMapKey k where
  data GMap k :: * -> *
  ...
</programlisting>
最上位の宣言とは対照的に、型添字として使われる予定の全ての型パラメタについて、名前付き引数が用いられねばならない。さらに、それらの引数名はクラスのパラメタでなければならない。それぞれのクラスパラメタは一つの関連型につき一回しか使えないが、使われないクラスパラメタがあってもよく、順序はクラス頭部と異っていてもよい。従って、以下の人為的な例は正当である。
<programlisting>
  class C a b c where
  data T c a :: *
</programlisting>
      </para>
    </sect4>
  </sect3>

  <sect3 id="data-instance-declarations"> 
    <title>データインスタンス宣言</title>

    <para>データとnewtypeの族についてのインスタンス宣言は、通常のデータおよびnewtypeの宣言と良く似ている。ただ二つの違いは、<literal>data</literal>あるいは<literal>newtype</literal>キーワードの後に<literal>instance</literal>が書かれることと、型引数の一部または全てが変数でない型であってもよいということである。ただし、これにforall型や型シノニム族が含まれていてはいけない。しかし、一般にデータ族が型パラメタ中にあってもよく、型シノニムも、それが完全に適用されていて、しかも展開結果が合法であるなら、認められる。これはクラスインスタンスのパラメタにおいて型シノニムが現れてよい条件と全く同じである。例として、<literal>GMap</literal>の<literal>Either</literal>インスタンスは次のようになる。
<programlisting>
data instance GMap (Either a b) v = GMapEither (GMap a v) (GMap b v)
</programlisting>
この例では、宣言にただ一つのvariantしかないが、一般にはいくつあってもよい(訳注: データ構築子が複数あってもいいということ？)。
    </para>
    <para>データインスタンス宣言およびnewtypeインスタンス宣言は適切な族宣言がスコープにある場合のみ認められる。これはちょうど、クラスインスタンスにクラス宣言が可視であることが必要なのと同じである。さらに、各インスタンス宣言は、その族宣言によって決まる類に準拠していなければならない。つまり、インスタンス宣言のパラメタの個数は、その族の類から決まるアリティと一致するということである。全てのデータ族は<literal>data</literal>キーワードを使って宣言されるが、インスタンスは<literal>data</literal>であっても<literal>newtype</literal>であってもよく、両者の混合であってもよい。
    </para>
    <para>
型族が最上位の宣言によって定義されている場合でも、異なる族インスタンスに対して異なる計算を行う関数は相変らず型クラスのメソッドとして定義されねばならない。特に、以下は不可能である。
<programlisting>
data family T a
data instance T Int  = A
data instance T Char = B
nonsence :: T a -> Int
nonsence A = 1             -- 間違い: この二つの等式をいっしょにすると...
nonsence B = 2             -- ...型エラーが発生する
</programlisting>
GADT(一般化代数的データ型)の提供する機能を見ると、上のような定義が可能であるべきだと思えるかもしれない。しかし、型族は、GADTとは対照的に、<emphasis>開かれて</emphasis>いる。つまり、常に新しいインスタンスを加えることが可能な(しかも別モジュールでかもしれない)のである。異なるデータインスタンスに跨がるパターン照合に対応するには、一種の拡張可能なcase構造が必要になることだろう。
    </para>

    <sect4 id="assoc-data-inst">
      <title>関連データインスタンス</title>
      <para>関連データ族インスタンスが型クラスインスタンスの中で宣言される場合、族インスタンスにおける<literal>instance</literal>キーワードは使わない。そのため、<literal>GMap</literal>の<literal>Either</literal>インスタンスは次のようになる。
<programlisting>
instance (GMapKey a, GMapKey b) => GMapKey (Either a b) where
  data GMap (Either a b) v = GMapEither (GMap a v) (GMap b v)
  ...
</programlisting>
関連族インスタンスに関して最も重要な点は、クラスパラメタに対応する型添字が、インスタンス頭部で与えられる型と同一でなければならないということである。この例ではこれは<literal>GMap</literal>の第一引数である<literal>Either a b</literal>であるが、これは(一つしかない)クラスパラメタと同じになっている。族構築子の引数のうち、クラスパラメタに対応しないものは、すべてのインスタンスにおいて変数でなければならない。ここではこれは変数<literal>v</literal>である。
      </para>
      <para>関連族のインスタンスは、その族が宣言されたクラスのインスタンス宣言の一部としてしか、現れることができない。これはクラスのメソッドの等式についてと同じである。また、これもメソッドの扱いと対応するが、クラスインスタンスにおいて関連型の宣言を省略することができる。関連族インスタンスが省略された場合、それに対応するインスタンス型は無内容(not inhabited)になる。すなわち、<literal>undefined</literal>などの発散する式のみがその型を持てる。
      </para>
    </sect4>

    <sect4 id="scoping-class-params">
      <title>クラスパラメタのスコープ規則</title>
      <para>複数引数の型クラスの場合、クラスパラメタが関連族インスタンスの右辺から可視かどうかは、そのデータ族のパラメタによって<emphasis>のみ</emphasis>決まる。例として、次の単純なクラス宣言を考える。
<programlisting>
class C a b where
  data T a
</programlisting>
二つのクラスパラメタのうち一つだけがデータ族のパラメタになっている。このため、次のインスタンス宣言は不正である。
<programlisting>
instance C [c] d where
  data T [c] = MkT (c, d)    -- 間違ってるよ!!  「d」はスコープにない
</programlisting>
ここでは、データインスタンスの左辺に現れない型変数<literal>d</literal>が右辺で言及されている。このようなデータインスタンスを認めると型安全性を犠牲にすることになるので、これは認められていない。
      </para>
    </sect4>

    <sect4 id="family-class-inst">
      <title>族インスタンスについての型クラスインスタンス</title>
      <para>データ族のインスタンスについての型クラスインスタンスは通常と同じように定義できる。特に、データインスタンス宣言は<literal>deriving</literal>節を持つことができる。例えば、以下のように書くことができる。
<programlisting>
data GMap () v = GMapUnit (Maybe v)
               deriving Show
</programlisting>
これは、以下のような形のインスタンスを暗黙に定義する。
<programlisting>
instance Show v => Show (GMap () v) where ...
</programlisting>
      </para>
      <para>クラスインスタンスは常にデータ族の特定の<emphasis>インスタンス</emphasis>を対象にするのであって、族全体を対象にするのではないことに注意。この理由は、本質的には、一つの型族の<emphasis>異なる</emphasis>インスタンスのデータ構築子についてパターン照合を行う最上位の関数を定義できない理由と同じである。これには、一種の拡張可能なcase構造が必要になるだろう。
      </para>
    </sect4>

    <sect4 id="data-family-overlap">
      <title>データインスタンスの重複</title>
      <para>一つのプログラムの中で、あるデータ族のインスタンス宣言に少しでも重複部分があってはならない。このことは関連族かそうでないかによらない。型クラスのインスタンスの場合と異なり、これは単なる整合性の問題ではなく、型安全性の問題である。
      </para>
    </sect4>

  </sect3>

  <sect3 id="data-family-import-export">
    <title>インポートとエクスポート</title>

    <para>型族とデータ構築子の関連は、通常のデータ型とnewtypeの宣言の場合と比べて動的である。通常の場合、インポートリストやエクスポートリストにおける<literal>T(..)</literal>という記法は、その型構築子と、その宣言で導入された全てのデータ構築子を記述するものである。一方、族宣言はデータ構築子を導入することがない。代わりに、データ構築子は族インスタンスによって導入される。結果として、ある型族にどのデータ構築子が関連しているかは、その族についてのインスタンス宣言として現在どれが可視であるかに依存する。従って、<literal>T(..)</literal>という形のインポート/エクスポート項目は、その族構築子と、それの現在可視である全てのデータ構築子を意味する。エクスポート項目の場合は、これはそのモジュールにインポートされたか、そのモジュールで定義されたものである。<literal>GMap(GMapEither)</literal>のように、データ構築子を明示的に列挙したエクスポート/インポート項目の扱いも同様である。
    </para>

    <sect4 id="data-family-impexp-assoc">
      <title>関連族</title>
      <para>期待される通り、<literal>C(..)</literal>という形式のインポート/エクスポート項目は、そのクラスのメソッドと関連型全てを示す。しかし、クラスの部分項目として関連型が明示的に列挙される場合、なんらかの新しい構文が必要になる。なぜなら、大文字の部分項目は通常データ構築子であって型構築子ではないからである。ここで型を示しているということを明確にするために、個々の関連型の名前の前に<literal>type</literal>を置く必要がある。よって、例えば、<literal>GMapKey</literal>クラスの内容を明示的に列挙する場合、<literal>GMapKey(type GMap, empty, lookup, insert)</literal>と書く。
      </para>
    </sect4>

    <sect4 id="data-family-impexp-examples">
      <title>例</title>
      <para>ここまで使ってきた<literal>GMapKey</literal>クラスの例を使って、エクスポートリストとその意味をいくつか見てみよう。
	<itemizedlist>
	  <listitem>
	    <para><literal>module GMap (GMapKey) where...</literal>: クラス名だけをエクスポートする。</para>
	  </listitem>
	  <listitem>
	    <para><literal>module GMap (GMapKey(..)) where...</literal>: クラスと、関連型<literal>GMap</literal>と、メンバ関数<literal>empty</literal>、<literal>lookup</literal>、<literal>insert</literal>をエクスポートする。データ構築子は全くエクスポートされない。</para>
	  </listitem> 
	  <listitem>
	    <para><literal>module GMap (GMapKey(..), GMap(..)) where...</literal>: 上と同じだが、データ構築子<literal>GMapInt</literal>、<literal>GMapChar</literal>、<literal>GMapUnit</literal>、<literal>GMapPair</literal>、<literal>GMapUnit</literal>をもエクスポートする。</para>
	  </listitem>
	  <listitem>
	    <para><literal>module GMap (GMapKey(empty, lookup, insert), GMap(..)) where...</literal>: 上と同じ。</para>
	  </listitem>
	  <listitem>
	    <para><literal>module GMap (GMapKey, empty, lookup, insert, GMap(..)) where...</literal>: 上と同じ。</para>
	  </listitem>
	</itemizedlist>
      </para>
      <para>最後に、<literal>GMapKey(type GMap)</literal>と書くことで、クラス<literal>GMapKey</literal>とその関連型<literal>GMap</literal>の両方を示すことができる。しかし、<literal>GMapKey(type GMap(..))</literal>と書くことはできない。つまり、部分要素は入れ子にできないのである。<literal>GMap</literal>のデータ構築子を指定するなら、<literal>GMap</literal>を(訳注: <literal>GMapKey</literal>とは)別に書かねばならない。
      </para>
    </sect4>

    <sect4 id="data-family-impexp-instances">
      <title>インスタンス</title>
      <para>クラスインスタンスと同様に、族インスタンスは暗黙にインポートされる。ただし、これはインスタンスの頭部についてだけで、インスタンスが定義するデータ構築子には適用されない。
      </para>
    </sect4>

  </sect3>

</sect2>

<sect2 id="synonym-families">
  <title>シノニム族</title>

  <para>型族が出現する方法には二通りの系統がある。(1)最上位で定義されるか、(2)型クラスの内部に出現する(この場合、これは関連型シノニムと言われる)かである。前者の系統は、型添字がクラスパラメタと一致しなければならないという制限がないので、より一般性が高い。一方、後者の方が明確に構造化されたコードにつながりやすく、なんらかの型インスタンスが(もしかしたら意図せず)省略された場合、コンパイラが警告を発する。以下では常に、まず一般的な最上位の形式について議論し、その後で関連型に課せられる追加の制約を扱う。
  </para>

  <sect3 id="type-family-declarations">
    <title>型族宣言</title>

    <para>添字付けされた型族は次のようなシグネチャによって導入される。
<programlisting>
type family Elem c :: *
</programlisting>
この特別な<literal>family</literal>によって、通常の型宣言と族宣言が区別される。結果の類注釈は省略可能であり、通常と同様に、省略された場合は<literal>*</literal>が使われる。例えば次のようになる。
<programlisting>
type family Elem c
</programlisting>
必要ならパラメタにも明示的な類シグネチャを付けることができる。型族宣言におけるパラメタの数をその族のアリティと呼び、その型族の適用は全てそのアリティに対して完全に飽和していなければ(訳注: つまり部分適用であっては)ならない。この制限は通常の型シノニムにはないものである<!-- 訳注: ほんとか？ -->。これにより、型族の類を知っただけではその族のアリティを決定できないので、型族の適用が正しいものかどうかも一般的には判断できない。例として、次の宣言を考える。
<programlisting>
type family F a b :: * -> *   -- Fの類は全体として見れば * -> * -> * -> *
                              -- しかし、アリティは2である
</programlisting>
この宣言のもとで、以下に正しい型と間違った型の例を示す。
<programlisting>
F Char [Int]       -- 正 類: * -> *
F Char [Int] Bool  -- 正 類: *
F IO Bool          -- 誤 最初の引数で類が不一致
F Bool             -- 誤 適用が飽和していない
</programlisting>
      </para>

    <sect4 id="assoc-type-family-decl">
      <title>関連型族宣言</title>
      <para>型族が型クラスの一部として宣言される場合、<literal>family</literal>特別子は使わない。<literal>Elem</literal>の宣言は次のような形になる。
<programlisting>
class Collects ce where
  type Elem ce :: *
  ...
</programlisting>
型族の引数名はクラスパラメタでなければならない。各クラスパラメタは一つの関連型について一回しか出現してはならないが、一回も出現しないものがあったり、クラスの頭部と異なる順序であっても良い。よって、以下の人為的な例は認められる。
<programlisting>
class C a b c where
  type T c a :: *
</programlisting>
これらの規則は関連データ族の場合とまったく同じである。
      </para>
    </sect4>
  </sect3>

  <sect3 id="type-instance-declarations">
    <title>型インスタンス宣言</title>
    <para>型族のインスタンス宣言は通常の型シノニム宣言によく似ている。違いは、<literal>type</literal>キーワードの後に<literal>instance</literal>が書かれることと、型引数の一部または全部が変数でなくてもよいことの二点だけである。ただし、型引数は、forall型や型シノニム族を含んでいてはならない。一方、一般にデータ族はあってもよく、型シノニムも、完全に適用されており、かつ展開結果が合法であるなら認められる。これらはデータインスタンスの場合と全く同じ制限である。例として、<literal>[e]</literal>の<literal>Elem</literal>インスタンスは次のようになる。
<programlisting>
type instance Elem [e] = e
</programlisting>
    </para>
    <para>型族インスタンス宣言は、適切な族宣言がスコープにあるときのみ認められる。これはちょうど、クラスインスタンスにはクラス宣言が可視であることが必要なのと同じである。さらに、個々のインスタンス宣言は、その族宣言によって決まる類に準拠していなければならず、インスタンス宣言の型パラメタの数は族宣言の型パラメタの数と一致していなければならない。最後に、型インスタンスの右辺は単相型でなければ(つまり、forallを含んでいては)ならず、また飽和した通常の(訳注: vanilla; 型シノニム族でない)型シノニムを全て展開した時点で、族シノニム以外のシノニムが残っていてはならない。許される型インスタンスとそうでない型インスタンスの例をいくつか挙げる。
<programlisting>
type family F a :: *
type instance F [Int]              = Int         -- OK!
type instance F String             = Char        -- OK!
type instance F (F a)              = a           -- 誤: 型パラメタが型族に言及している
type instance F (forall a. (a, b)) = b           -- 誤: 型パラメタの中にforall型がある
type instance F Float              = forall a.a  -- 誤: 右辺がforall型であってはならない

type family G a b :: * -> *
type instance G Int            = (,)     -- 誤: 引数は二つでないといけない
type instance G Int Char Float = Double  -- 誤: 引数は二つでないといけない
</programlisting>
    </para>

    <sect4 id="assoc-type-instance">
      <title>関連型インスタンス宣言</title>
      <para>型クラスインスタンスの中で関連族インスタンスを宣言するときは、族インスタンス中に<literal>instance</literal>キーワードを使わない。よって、<literal>Elem</literal>の<literal>[e]</literal>インスタンスは次のようになる。
<programlisting>
instance (Eq (Elem [e])) => Collects ([e]) where
  type Elem [e] = e
  ...
</programlisting>
関連族インスタンスに関して最も重要なのは、クラスパラメタに対応する型添字が、インスタンス頭部で与えられたものと同一であることである。これはここでは<literal>[e]</literal>であり、一つしかないクラスパラメタと一致している。
      </para>
      <para>
関連族のインスタンスは、その族が宣言されたクラスについてのインスタンス宣言の一部としてしか現れ得ない。クラスのメソッドの等式とちょうど同じである。また、同じくメソッドの扱いに対応することとして、クラスインスタンス中での関連型の宣言を省くことができる。関連型族インスタンスが省かれた場合、対応するインスタンス型は無内容(not inhabited)になる。すなわち、<literal>undefined</literal>のような発散する式以外に、その型を持てる式は存在しない。
      </para>
    </sect4>

    <sect4 id="type-family-overlap">
      <title>型シノニムインスタンスの重複</title>
      <para>
ある一つのプログラム内で使われる型族のインスタンス宣言に関して、重複が許されるのは、重複するインスタンスの右辺が共通部分の型に対しては一致する場合だけである。より形式的に言うと、二つのインスタンス宣言が重複するとは、インスタンスの左辺を構文的に一致させるような代入(substitution)が存在するときである。これに該当する場合は必ず、この同じ代入のもとでインスタンスの右辺も構文的に同じにならなければならない。この条件は族が関連族であるかどうかに拠らない。また、これは単なる整合性の問題ではなく、型安全性の問題である。
      </para>
      <para>
重複が許される条件を説明するために二つの例を用意した。
<programlisting>
type instance F (a, Int) = [a]
type instance F (Int, b) = [b]   -- 重複が許される

type instance G (a, Int)  = [a]
type instance G (Char, a) = [a]  -- 非合法な重複、[Char] /= [Int]であるため
</programlisting>
      </para>
    </sect4>

    <sect4 id="type-family-decidability">
      <title>型シノニムインスタンスの決定可能性</title>
      <para>
	      型族の存在下での型推論が決定可能であることを保証するため、型インスタンス宣言の形式に追加で制限を課す必要がある。(&ldquo;<ulink url="http://www.cse.unsw.edu.au/~chak/papers/SPCS08.html">Type Checking with Open Type Functions</ulink>&rdquo;のDefinition 5 (Relaxed Condition)も参照)。インスタンス宣言の一般形式は次の通りである。
<programlisting>
type instance F t1 .. tn = t
</programlisting>
ここで、<literal>t</literal>中のすべての型族適用<literal>(G s1 .. sm)</literal>に対して、以下のことを要求する。
	<orderedlist>
	  <listitem>
		  <para><literal>s1 .. sm</literal>に、型族構築子が一つも含まれない。</para>
	  </listitem>
	  <listitem>
		  <para><literal>s1 .. sm</literal>中のシンボル(データ型構築子および型変数)の数が、<literal>t1 .. tn</literal>における数よりも厳密に小さい。</para>
	  </listitem>
	  <listitem>
		  <para>全ての型変数<literal>a</literal>について、aが<literal>s1 .. sm</literal>に現れる回数が、<literal>t1 .. tn</literal>に現れる回数を超えない。</para>
	  </listitem>
	</orderedlist>
これらの制限は容易に検査することができ、型インスタンスが停止することを保証する。しかし、<literal>a ~ [F a]</literal>のように、型構築子が族適用とデータ構築子適用の下にある、いわゆる「ループ的同値」の存在下では、型推論の完全性を保証するのに足りない。詳細については上で挙げた論文を参照のこと。</para>
      <para><option>-XUndecidableInstances</option>オプションがコンパイラに渡されると、上記の制約は強制されず、型推論中に型族の正規化が停止することを保証するのはプログラマの責任になる。
      </para>
    </sect4>
  </sect3>

  <sect3 id-="equality-constraints">
    <title>同値性制約</title>
    <para>型文脈には<literal>t1 ~ t2</literal>という形の同値性制約を含めることができる。これは、<literal>t1</literal>と<literal>t2</literal>の二つの型が同じでなければならないということを示す。型族の存在下では、一般に二つの型が等しいかどうかを局所的に決めることは出来ない。このため、次の例のように、関数のシグネチャの文脈に同値性制約が使われることがある。
<programlisting>
sumCollects :: (Collects c1, Collects c2, Elem c1 ~ Elem c2) => c1 -> c2 -> c2
</programlisting>
ここでは、<literal>c1</literal>と<literal>c2</literal>の要素の型が同じであることを要求している。一般に、同値性制約における<literal>t1</literal>と<literal>t2</literal>は任意の単相型であってよい。単相型であるというのは、ランクの高い型が有効になっているかどうかにかかわらず、量化子を含んでいてはならないということである。
    </para>
    <para>
同値性制約は、クラスとインスタンスの文脈でも使うことができる。前者によって、関数従属を使うプログラムから、代わりに族シノニムを使うプログラムへの、単純な翻訳が出来るようになる。一般的な考え方として、次のような形のクラス宣言があったとする。
<programlisting>
class C a b | a -> b
</programlisting>
これを、以下のように書き換える。
<programlisting>
class (F a ~ b) => C a b where
  type F a
</programlisting>
つまり、すべての<literal>a1 .. an -> b</literal>という関数従属性(FD)について、これを<literal>F a1 .. an</literal>というFD型族と<literal>F a1 .. an ~ b</literal>というスーパークラス文脈の同値性で表現することで、実質的に関数従属性に名前を与えている。クラスインスタンスでは、FD族の型インスタンスをクラス頭部に沿った形で定義する。この過程でメソッドのシグネチャは影響を受けない。
    </para>
    <para>
注意: スーパークラス文脈における同値性はGHC 6.10では完全には実装されていない。
    </para>
  </sect3>

</sect2>

</sect1>

<sect1 id="other-type-extensions">
<title>型システムへのその他の拡張</title>

<sect2 id="type-restrictions">
<title>型シグネチャ</title>

<sect3 id="flexible-contexts"><title>型シグネチャの文脈</title>
<para>
<option>-XFlexibleContexts</option>フラグを使うと、型シグネチャ中の型クラス制約が<emphasis>(class type-variable)</emphasis>または<emphasis>(class (type-variable type-variable ...))</emphasis>という形でなければならないという、Haskell 98の制限を撤廃する。<option>-XFlexibleContexts</option>が有効な場合、以下のような型シグネチャは完全に正しい。
<programlisting>
  g :: Eq [a] => ...
  g :: Ord (T a ()) => ...
</programlisting>
</para>
<para>
GHCは、型シグネチャに関して以下の制限を課す。次の型を考える。

<programlisting>
  forall tv1..tvn (c1, ...,cn) => type
</programlisting>

(ここでは「forall」を明示的に書いたが、Haskellソース言語では省略される。Haskell 98では、ソース言語中の明示的な型シグネチャにおける型変数は全て全称量化される(クラス宣言中のクラス型変数の場合を除く)。ただし、GHCでは、望むならforallを与えても良い。<xref linkend="universal-quantification"/>を見よ)
</para>

<para>

<orderedlist>
<listitem>

<para>
 <emphasis>全ての全称量化された型変数<literal>tvi</literal>は<literal>type</literal>から到達可能でなければならない</emphasis>。型変数<literal>a</literal>が「到達可能」なのは、<literal>type</literal>に現れる型変数または別の到達可能な型変数と、その型変数が、同じ制約の中に現れるときである。この到達可能性制限に従わない型を持つ値は、曖昧性を導入することなく使うことができない。これがこういう型が禁止される理由である。例えば、以下の型は許されない。


<programlisting>
  forall a. Eq a => Int
</programlisting>


この型の値が使われるとき、<literal>tv</literal>を新しい型変数として、<literal>Eq tv</literal>という制約が導入され、(辞書渡し実装では)この値が<literal>Eq tv</literal>の辞書に適用される。問題は、<literal>tv</literal>についてこれ以上情報を得ることができないため、どの<literal>Eq</literal>のインスタンスを使うべきか決して知ることがきないということである。
</para>
<para>
この到達可能条件は「<literal>a</literal>が<literal>type</literal>中の型変数に関数従属している(<xref linkend="functional-dependencies"/>を見よ)」という条件よりも弱いことに注意。これは、場合によっては、スーパークラスに「隠された」従属性があり得るからである。従って、到達可能性は関数従属性に対する保守的な近似である。例えば、以下の例を考えてみよう。
<programlisting>
  class C a b | a -> b where ...
  class C a b => D a b where ...
  f :: forall a b. D a b => a -> a
</programlisting>
これは問題ない。実際、<literal>a</literal>は関数的に<literal>b</literal>を決定する。しかし、このことは<literal>f</literal>の型だけからは明らかでない。
</para>
</listitem>
<listitem>

<para>
 <emphasis>制約<literal>ci</literal>は全て、少なくとも一つの全称量化された型変数<literal>tvi</literal>に言及せねばならない</emphasis>。例えば、以下の型は、<literal>C a b</literal>が、全称量化された型変数<literal>b</literal>に言及しているので問題ない。


<programlisting>
  forall a. C a b => burble
</programlisting>


次に示す型は、制約<literal>Eq b</literal>が<literal>a</literal>に言及していないので不正である。


<programlisting>
  forall a. Eq b => burble
</programlisting>

この制限がある理由は、上のものほど深刻ではない。この制限によって排除されるのは、有用でも必要でもない型だけである。(この制約に反する文脈は、その位置にある必要がなく、より外側に移動させることができるからである)。さらに、これらを外側に移すことで共有が促進される。最後に、これを除外するというのは保守的な選択であり、後で必要になるかもしれない領域を取っておくことになる。

</para>
</listitem>

</orderedlist>

</para>
</sect3>

</sect2>

<sect2 id="implicit-parameters">
<title>暗黙パラメタ</title>

<para>
暗黙パラメタは、"Implicit parameters: dynamic scoping with static types", J Lewis, MB Shields, E Meijer, J Launchbury, 27th ACM Symposium on Principles of Programming Languages (POPL'00), Boston, Jan 2000に述べられている通りに実装されている。
</para>

<para>(以下の文書(まだかなり不完全だが)はJeff Lweisによる)</para>

<para>暗黙パラメタのサポートは<option>-XImplicitParams</option>オプションで有効になる。</para>

<para>
変数は、それが関数の呼び出し元の文脈によって束縛されているとき<emphasis>動的に束縛されている</emphasis>と言い、呼ばれた関数の文脈によって束縛されているとき<emphasis>静的に束縛されている</emphasis>と言う。Haskellでは全ての変数が静的に束縛される。変数の動的束縛の概念はLispにまで遡るが、Schemeのような現代的な現れにおいては捨てられることとなった。動的束縛は型のない言語においては非常に混乱的であるし、残念なことに、型のある言語においてもそうである。特に、HaskellのようにHindley-Milterの型システムの付けられた言語は、変数について静的スコープしか認めない。
</para>
<para>
ところが、Haskellの型クラスの構造に単純な拡張を施すことで、動的束縛を手に入れることができる。基本的には、動的に束縛された変数を使うということを、型への制約として表現するのである。このような制約を使うと、型は<literal>(?x::t') => t</literal>という形になるが、これは「この関数は動的に束縛された型<literal>t'</literal>の変数<literal>?x</literal>を使っている」という意味である。例えば、以下に示すのは、<literal>cmp</literal>という名前の比較関数で暗黙にパラメタ化されたソート関数の型である。
<programlisting>
  sort :: (?cmp :: a -> a -> Bool) => [a] -> [a]
</programlisting>
動的束縛制約は、型クラス機構に追加された、一つの新しい形の述語に過ぎない。
</para>
<para>
暗黙パラメタは<literal>?x</literal>という特殊形式を使った式に現れる。ここで<literal>x</literal>は有効な識別子である。(例えば、<literal>ord ?x</literal>は正しい式である)。この要素を使うことで、式の型も影響され、新しい動的束縛制約が導入される。例えば、以下では、明示的にパラメタ化された<literal>sortBy</literal>関数を基にして暗黙にパラメタ化されたソート関数を定義している。
<programlisting>
  sortBy :: (a -> a -> Bool) -> [a] -> [a]

  sort   :: (?cmp :: a -> a -> Bool) => [a] -> [a]
  sort    = sortBy ?cmp
</programlisting>
</para>

<sect3>
<title>暗黙パラメタ型制約</title>
<para>
動的束縛制約は自動的に伝播される。この点で、型クラス制約と同じ振る舞いである。つまり、ある関数が使われるとき、その関数の暗黙パラメタはその関数を呼んだ関数に受け継がれる。例えば、上記の<literal>sort</literal>関数は、リストの最小要素を得るのに使うことができる。
<programlisting>
  least   :: (?cmp :: a -> a -> Bool) => [a] -> a
  least xs = head (sort xs)
</programlisting>
特に何もしなくても、<literal>?cmp</literal>パラメタは伝播され、<literal>least</literal>のパラメタにもなっている。明示的なパラメタでは、パラメタを明示的に受け渡さなければならないのがデフォルトであるのに対し、暗黙パラメタでは、常に伝播するのがデフォルトである。
</para>
<para>
暗黙パラメタ型制約と通常のクラス制約の違いは以下の通りである。特定の暗黙パラメタは、何回使われようと、同じ型を持っていなければならない。つまり、<literal>(?x, ?x)</literal>の型は<literal>(?x::a) => (a, a)</literal>であり、クラス制約の場合のように<literal>(?x::a, ?x::b) => (a, b)</literal>となることはない。
</para>

<para>クラス宣言やインスタンス宣言の文脈で暗黙パラメタを使うことはできない。例えば、以下の宣言はどちらも不正である。
<programlisting>
  class (?x::Int) => C a where ...
  instance (?x::a) => Foo [a] where ...
</programlisting>
理由: 暗黙パラメタとしてどれを選ぶかはどこで関数を呼ぶかに依存する。しかし、インスタンス宣言を「呼ぶ」のはコンパイラによって裏で行われることであり、それがどこで行われているか正確なことを決めるのは難しい。最も簡単なのは、これに違反する型を非合法化することである。</para>
<para>
暗黙パラメタ制約は曖昧性を引き起こさない。以下の例を考えてみよう。
<programlisting>
   f :: (?x :: [a]) => Int -> Int
   f n = n + length ?x

   g :: (Read a, Show a) => String -> String
   g s = show (read s)
</programlisting>
ここで、<literal>g</literal>の型は曖昧であり、受け付けられない。一方、<literal>f</literal>は問題ない。<literal>f</literal>の呼び出し地点での<literal>?x</literal>の束縛は全く曖昧でなく、<literal>a</literal>の型を固定する。
</para>
</sect3>

<sect3>
<title>暗黙パラメタの束縛</title>

<para>
暗黙パラメタは通常の<literal>let</literal>や<literal>where</literal>束縛形式を使って<emphasis>束縛する</emphasis>ことができる。例として、<literal>cmp</literal>を束縛することで<literal>min</literal>関数を定義する。
<programlisting>
  min :: [a] -> a
  min  = let ?cmp = (&lt;=) in least
</programlisting>
</para>
<para>
暗黙パラメタの束縛グループは、通常のHaskellの束縛グループが出現できるところなら、最上位を除いてどこに現れても良い。つまり、<literal>let</literal>(リスト内包表記、do記法、パターンガード中のものも含む)または<literal>where</literal>節に現れることができる。以下のことに注意。
<itemizedlist>
<listitem><para>
暗黙パラメタの束縛グループは暗黙形式の変数への単純束縛の集まり(関数形式は禁止。型シグネチャも禁止)でなければならない。これらの束縛は多相的であってはならず、再帰的であってもならない。
</para></listitem>
<listitem><para>
一つの<literal>let</literal>式に暗黙パラメタ束縛と通常の束縛を混ぜることはできない。代わりに入れ子になった<literal>let</literal>を使うこと。(<literal>where</literal>の場合はどうしようもない。<literal>where</literal>節を入れ子にすることはできないので)
</para></listitem>

<listitem><para>
単一の束縛グループに複数の暗黙パラメタ束縛を配置することは可能だが、それらは(通常の<literal>let</literal>束縛のような)相互再帰的なグループとはみなされない。それらは、非再帰的なグループで、全ての暗黙引数を同時に束縛するものとして扱われる。束縛は入れ子になっておらず、順番を入れ替えてもプログラムの意味は変わらない。例として以下の例を考えよ。
<programlisting>
  f t = let { ?x = t; ?y = ?x+(1::Int) } in ?x + ?y
</programlisting>
<literal>?y</literal>の束縛中で<literal>?x</literal>が使われているが、直前の<literal>?x</literal>の束縛はそこからは「見え」ないので、<literal>f</literal>の型は以下のようになる。
<programlisting>
  f :: (?x::Int) => Int -> Int
</programlisting>
</para></listitem>
</itemizedlist>
</para>

</sect3>

<sect3><title>暗黙パラメタと多相再帰</title>

<para>
次の二つの定義を考えてみよう。
<programlisting>
  len1 :: [a] -> Int
  len1 xs = let ?acc = 0 in len_acc1 xs

  len_acc1 [] = ?acc
  len_acc1 (x:xs) = let ?acc = ?acc + (1::Int) in len_acc1 xs

  ------------

  len2 :: [a] -> Int
  len2 xs = let ?acc = 0 in len_acc2 xs

  len_acc2 :: (?acc :: Int) => [a] -> Int
  len_acc2 [] = ?acc
  len_acc2 (x:xs) = let ?acc = ?acc + (1::Int) in len_acc2 xs
</programlisting>
この二つのグループの違いは、二番目のグループでは<literal>len_acc</literal>に型シグネチャが与えられているという点だけである。前者では、<literal>len_acc1</literal>はその右辺について単相的であり、再帰呼び出しでは暗黙パラメタ<literal>?acc</literal>が渡されない。後者では、<literal>len_acc2</literal>に型シグネチャがあるので、再帰呼び出しは<emphasis>多相的</emphasis>になり、<literal>?acc</literal>を暗黙パラメタとして取る。よって、GHCiで試してみると、以下の結果が得られる。
<programlisting>
  Prog> len1 "hello"
  0
  Prog> len2 "hello"
  5
</programlisting>
型シグネチャを追加することで結果が劇的に変わってしまった。これはかなり直観に反する現象であり、注意するに値する。
</para>
</sect3>

<sect3><title>暗黙パラメタと単相性</title>

<para>GHCは、例の恐るべき単相性限定(Haskellレポートの4.5.5節)を暗黙パラメタにも適用する。例として以下を考えよう。
<programlisting>
 f :: Int -> Int
  f v = let ?x = 0     in
        let y = ?x + v in
        let ?x = 5     in
        y
</programlisting>
<literal>y</literal>の束縛は単相性限定の適用下にあり、一般化されないので、<literal>y</literal>の型は単なる<literal>Int</literal>であり、<literal>(?x::Int) => Int</literal>ではない。従って、<literal>(f 9)</literal>は結果<literal>9</literal>を返す。<literal>y</literal>に型シグネチャを追加すると、<literal>y</literal>の型は<literal>(?x::Int) => Int</literal>になり、<literal>let</literal>の本体における<literal>y</literal>の出現は内側の<literal>?x</literal>の束縛を見ることになるので、<literal>(f 9)</literal>は<literal>14</literal>を返す。
</para>
</sect3>
</sect2>

    <!--   ======================= COMMENTED OUT ========================

    We intend to remove linear implicit parameters, so I'm at least removing
    them from the 6.6 user manual

<sect2 id="linear-implicit-parameters">
<title>Linear implicit parameters</title>
<para>
Linear implicit parameters are an idea developed by Koen Claessen,
Mark Shields, and Simon PJ.  They address the long-standing
problem that monads seem over-kill for certain sorts of problem, notably:
</para>
<itemizedlist>
<listitem> <para> distributing a supply of unique names </para> </listitem>
<listitem> <para> distributing a supply of random numbers </para> </listitem>
<listitem> <para> distributing an oracle (as in QuickCheck) </para> </listitem>
</itemizedlist>

<para>
Linear implicit parameters are just like ordinary implicit parameters,
except that they are "linear"; that is, they cannot be copied, and
must be explicitly "split" instead.  Linear implicit parameters are
written '<literal>%x</literal>' instead of '<literal>?x</literal>'.  
(The '/' in the '%' suggests the split!)
</para>
<para>
For example:
<programlisting>
    import GHC.Exts( Splittable )

    data NameSupply = ...
    
    splitNS :: NameSupply -> (NameSupply, NameSupply)
    newName :: NameSupply -> Name

    instance Splittable NameSupply where
	split = splitNS


    f :: (%ns :: NameSupply) => Env -> Expr -> Expr
    f env (Lam x e) = Lam x' (f env e)
		    where
		      x'   = newName %ns
		      env' = extend env x x'
    ...more equations for f...
</programlisting>
Notice that the implicit parameter %ns is consumed 
<itemizedlist>
<listitem> <para> once by the call to <literal>newName</literal> </para> </listitem>
<listitem> <para> once by the recursive call to <literal>f</literal> </para></listitem>
</itemizedlist>
</para>
<para>
So the translation done by the type checker makes
the parameter explicit:
<programlisting>
    f :: NameSupply -> Env -> Expr -> Expr
    f ns env (Lam x e) = Lam x' (f ns1 env e)
		       where
	 		 (ns1,ns2) = splitNS ns
			 x' = newName ns2
			 env = extend env x x'
</programlisting>
Notice the call to 'split' introduced by the type checker.
How did it know to use 'splitNS'?  Because what it really did
was to introduce a call to the overloaded function 'split',
defined by the class <literal>Splittable</literal>:
<programlisting>
	class Splittable a where
	  split :: a -> (a,a)
</programlisting>
The instance for <literal>Splittable NameSupply</literal> tells GHC how to implement
split for name supplies.  But we can simply write
<programlisting>
	g x = (x, %ns, %ns)
</programlisting>
and GHC will infer
<programlisting>
	g :: (Splittable a, %ns :: a) => b -> (b,a,a)
</programlisting>
The <literal>Splittable</literal> class is built into GHC.  It's exported by module 
<literal>GHC.Exts</literal>.
</para>
<para>
Other points:
<itemizedlist>
<listitem> <para> '<literal>?x</literal>' and '<literal>%x</literal>' 
are entirely distinct implicit parameters: you 
  can use them together and they won't intefere with each other. </para>
</listitem>

<listitem> <para> You can bind linear implicit parameters in 'with' clauses. </para> </listitem>

<listitem> <para>You cannot have implicit parameters (whether linear or not)
  in the context of a class or instance declaration. </para></listitem>
</itemizedlist>
</para>

<sect3><title>Warnings</title>

<para>
The monomorphism restriction is even more important than usual.
Consider the example above:
<programlisting>
    f :: (%ns :: NameSupply) => Env -> Expr -> Expr
    f env (Lam x e) = Lam x' (f env e)
		    where
		      x'   = newName %ns
		      env' = extend env x x'
</programlisting>
If we replaced the two occurrences of x' by (newName %ns), which is
usually a harmless thing to do, we get:
<programlisting>
    f :: (%ns :: NameSupply) => Env -> Expr -> Expr
    f env (Lam x e) = Lam (newName %ns) (f env e)
		    where
		      env' = extend env x (newName %ns)
</programlisting>
But now the name supply is consumed in <emphasis>three</emphasis> places
(the two calls to newName,and the recursive call to f), so
the result is utterly different.  Urk!  We don't even have 
the beta rule.
</para>
<para>
Well, this is an experimental change.  With implicit
parameters we have already lost beta reduction anyway, and
(as John Launchbury puts it) we can't sensibly reason about
Haskell programs without knowing their typing.
</para>

</sect3>

<sect3><title>Recursive functions</title>
<para>Linear implicit parameters can be particularly tricky when you have a recursive function
Consider
<programlisting>
        foo :: %x::T => Int -> [Int]
        foo 0 = []
        foo n = %x : foo (n-1)
</programlisting>
where T is some type in class Splittable.</para>
<para>
Do you get a list of all the same T's or all different T's
(assuming that split gives two distinct T's back)?
</para><para>
If you supply the type signature, taking advantage of polymorphic
recursion, you get what you'd probably expect.  Here's the
translated term, where the implicit param is made explicit:
<programlisting>
        foo x 0 = []
        foo x n = let (x1,x2) = split x
                  in x1 : foo x2 (n-1)
</programlisting>
But if you don't supply a type signature, GHC uses the Hindley
Milner trick of using a single monomorphic instance of the function
for the recursive calls. That is what makes Hindley Milner type inference
work.  So the translation becomes
<programlisting>
        foo x = let
                  foom 0 = []
                  foom n = x : foom (n-1)
                in
                foom
</programlisting>
Result: 'x' is not split, and you get a list of identical T's.  So the
semantics of the program depends on whether or not foo has a type signature.
Yikes!
</para><para>
You may say that this is a good reason to dislike linear implicit parameters
and you'd be right.  That is why they are an experimental feature. 
</para>
</sect3>

</sect2>

================ END OF Linear Implicit Parameters commented out -->

<sect2 id="kinding">
<title>明示的に類付けされた量化</title>

<para>
Haskellでは全ての型変数の類は推論される。(機械で検査できる)文書化のために、類を明示的に与えるのが良いことがある。これは関数に型シグネチャを与えると良いのと同様である。場合によっては、これが本質的に必要になることもある。例えば、John Hughesは、彼の論文"Restricted Data Types in Haskell" (Haskell Workshop 1999)のなかで、次のようにデータ型を定義しなければならなかった。
<screen>
     data Set cxt a = Set [a]
                    | Unused (cxt a -> ())
</screen>
構築子<literal>Unused</literal>は、型変数<literal>cxt</literal>が正しい類を与えられるようにするためだけに存在する。
</para>
<para>
GHCでは、このようなことをしなくても、<option>-XKindSignatures</option>を使えば、型変数が明示的に束縛されるときはいつでも、その型変数の類を直接指定できるようになった。</para>
<para>
このフラグによって、以下の場所で類シグネチャを使えるようになる。
<itemizedlist>
<listitem><para><literal>data</literal>宣言。
<screen>
  data Set (cxt :: * -> *) a = Set [a]
</screen></para></listitem>
<listitem><para><literal>type</literal>宣言。
<screen>
  type T (f :: * -> *) = f Int
</screen></para></listitem>
<listitem><para><literal>class</literal>宣言。
<screen>
  class (Eq a) => C (f :: * -> *) a where ...
</screen></para></listitem>
<listitem><para>型シグネチャ中の<literal>forall</literal>。
<screen>
  f :: forall (cxt :: * -> *). Set cxt Int
</screen></para></listitem>
</itemizedlist>
</para>

<para>
括弧は必須である。いくつかのスペースも、字句要素を分離するために必要である。<literal>(f::*->*)</literal>と書いたとすると、「<literal>::*->*</literal>」はHaskellでは一つの字句要素なので、パースエラーになる。
</para>

<para>
この拡張の一部として、型に類注釈を加えることもできる。
<screen>
   f :: (Int :: *) -> Int
   g :: forall a. a -> (a :: *)
</screen>
構文は以下のとおり。
<screen>
   atype ::= '(' ctype '::' kind ')
</screen>
括弧は必須である。
</para>
</sect2>


<sect2 id="universal-quantification">
<title>任意ランク多相
</title>

<para>
Haskellの型シグネチャは暗黙に量化される。新しいキーワード<literal>forall</literal>を使うと、これが正確にどういう意味なのか言えるようになる。例えば、以下のものを考える。
</para>
<para>
<programlisting>
        g :: b -> b
</programlisting>
これは以下のものを意味している。
<programlisting>
        g :: forall b. (b -> b)
</programlisting>
この二つは同じものとして扱われる。
</para>

<para>
一方、GHCの型システムでは、型に対して<emphasis>任意ランク</emphasis>の明示的な量化が認められる。例えば、以下の例は全て合法である。
<programlisting>
    f1 :: forall a b. a -> b -> a
    g1 :: forall a b. (Ord a, Eq  b) => a -> b -> a

    f2 :: (forall a. a->a) -> Int -> Int
    g2 :: (forall a. Eq a => [a] -> a -> Bool) -> Int -> Int

    f3 :: ((forall a. a->a) -> Int) -> Bool -> Bool

    f4 :: Int -> (forall a. a -> a)
</programlisting>
ここで、<literal>f1</literal>と<literal>g1</literal>はランク1の型で、標準のHaskellで書くことができる。(例えば、<literal>f1 :: a->b->a</literal>)。これらの<literal>forall</literal>は、Haskellが暗黙に加える全称量化を明示的なものにしている。
</para>
<para>
関数<literal>f2</literal>と<literal>g2</literal>の型はランク2である。<literal>forall</literal>が関数矢印の左にあるからである。<literal>g2</literal>を見れば分かるとおり、関数矢印の左の多相型は多重定義されていても良い。
</para>
<para>
関数<literal>f3</literal>はランク3の型を持っている。関数矢印の左にランク2の型があるからである。
</para>
<para>
GHCには、ランクの高い型を制御するための三つのフラグがある。
<itemizedlist>
<listitem><para>
 <option>-XPolymorphicComponents</option>: データ構築子(だけ)が、多相的な引数の型を持てる。
</para></listitem>
<listitem><para>
 <option>-XRank2Types</option>: あらゆる関数(データ構築子を含む)が、ランク2の型を持てる。
</para></listitem>
<listitem><para>
 <option>-XRankNTypes</option>: あらゆる関数(データ構築子を含む)が、任意のランクの型を持てる。つまり、関数矢印に必要なだけ深く<literal>forall</literal>を入れ子にすることができる。特に、forallの付いた型(「型スキーム」とも呼ばれる)は、<!-- 訳注: including operational type class context -->型クラス文脈も含めて、以下の場所で使える。
<itemizedlist>
<listitem> <para>関数矢印の左側または右側(例えば<literal>f4</literal>を見よ)</para> </listitem>
<listitem> <para>データ型宣言で、構築子の引数として、またはフィールドの型として。例えば、上記の<literal>f1,f2,f3,g1,g2</literal>はどれも、フィールドの型シグネチャとして合法である。</para> </listitem>
<listitem> <para>暗黙パラメタの型として</para> </listitem>
<listitem> <para>パターン型シグネチャ(<xref linkend="scoped-type-variables"/>を見よ)の中 </para> </listitem>
</itemizedlist>
</para></listitem>
</itemizedlist>
もちろん、<literal>forall</literal>はキーワードになる。型変数として<literal>forall</literal>を使うことはもはやできない。
</para>


<sect3 id="univ">
<title>例
</title>

<para>
<literal>data</literal>宣言や<literal>newtype</literal>宣言において、構築子の引数の型を量化することができる。いくつか例を挙げる。
</para>

<para>

<programlisting>
data T a = T1 (forall b. b -> b -> b) a

data MonadT m = MkMonad { return :: forall a. a -> m a,
                          bind   :: forall a b. m a -> (a -> m b) -> m b
                        }

newtype Swizzle = MkSwizzle (Ord a => [a] -> [a])
</programlisting>

</para>

<para>
これらの構築子は、以下のように、ランク2の型を持つ。
</para>

<para>

<programlisting>
T1 :: forall a. (forall b. b -> b -> b) -> a -> T a
MkMonad :: forall m. (forall a. a -> m a)
                  -> (forall a b. m a -> (a -> m b) -> m b)
                  -> MonadT m
MkSwizzle :: (Ord a => [a] -> [a]) -> Swizzle
</programlisting>

</para>

<para>
明示的な文脈があるなら<literal>forall</literal>を使う必要はないということに注意。例えば、構築子<function>MkSwizzle</function>の第一引数について、引数の型には暗黙に「<literal>forall a.</literal>」が付いているとみなされる。このような暗黙の<literal>forall</literal>は、問題の型に言及されているもののスコープにない型変数全てを量化する。
</para>

<para>
型シグネチャと同様に、多重定義されていない型についても暗黙の量化は発生する。次のように書いたとする。

<programlisting>
  data T a = MkT (Either a b) (b -> b)
</programlisting>

これは、次のように書いたのと同じである。

<programlisting>
  data T a = MkT (forall b. Either a b) (forall b. b -> b)
</programlisting>

つまり、型変数<literal>b</literal>はスコープにないので、暗黙に全称量化される。(もしかしたら、必要な場合には構築子引数についての明示的な量化を<emphasis>必須</emphasis>にした方が良いのかもしれない。フィードバック歓迎)
</para>

<para>
型<literal>T1, MonadT, Swizzle</literal>の値を構築するには、通常と同じように、構築子を適切な値に適用すれば良い。例を示す。
</para>

<para>

<programlisting>
    a1 :: T Int
    a1 = T1 (\xy->x) 3
    
    a2, a3 :: Swizzle
    a2 = MkSwizzle sort
    a3 = MkSwizzle reverse
    
    a4 :: MonadT Maybe
    a4 = let r x = Just x
	     b m k = case m of
		       Just y -> k y
		       Nothing -> Nothing
         in
         MkMonad r b

    mkTs :: (forall b. b -> b -> b) -> a -> [T a]
    mkTs f x y = [T1 f x, T1 f y]
</programlisting>

</para>

<para>
<literal>(MkSwizze reverse)</literal>の例から分かるように、構築子の引数は、通常と同じく、必要以上に一般的な型をもっていても良い。(<function>reverse</function>は<literal>Ord</literal>制約を必要としない)
</para>

<para>
パターン照合を使うとき、束縛される変数が多相型を持つことがあり得る。例を示す。
</para>

<para>

<programlisting>
    f :: T a -> a -> (a, Char)
    f (T1 w k) x = (w k x, w 'c' 'd')

    g :: (Ord a, Ord b) => Swizzle -> [a] -> (a -> b) -> [b]
    g (MkSwizzle s) xs f = s (map f (s xs))

    h :: MonadT m -> [m a] -> m [a]
    h m [] = return m []
    h m (x:xs) = bind m x          $ \y ->
                 bind m (h m xs)   $ \ys ->
                 return m (y:ys)
</programlisting>

</para>

<para>
関数<function>h</function>では、<literal>MonadT</literal>データ構造から多相的なbindとreturn関数を抽出するのに、パターン照合ではなく、レコード選択関数である<literal>return</literal>と<literal>bind</literal>を使っている。
</para>
</sect3>

<sect3>
<title>型推論</title>

<para>
一般に、任意ランクの型に対する型推論は決定不能である。GHCでは、OderskyとLauferによって提案されたアルゴリズム("Putting type annotations to work", POPL'96)を使って、プログラマの助けを当てにすることでアルゴリズムを決定可能にしている。「プログラマの助け」についての形式的な仕様はまだないが、規則はこうである。
</para>
<para>
<emphasis>ラムダ束縛された、あるいはcase束縛された変数xについて、プログラマがxに多相的な型を明示的に与えない限り、GHCの型推論は、xの型にforallが含まれないとみなす</emphasis>。
</para>
<para>
xに明示的な型を「与える」とはどういう意味か。まず、xに直接型シグネチャを与えることができる。これにはパターン型シグネチャ(<xref linkend="scoped-type-variables"/>を見よ)を使う。
<programlisting>
     \ f :: (forall a. a->a) -> (f True, f 'c')
</programlisting>
別の方法として、これを取り巻く文脈に型シグネチャを与えることもできる。GHCはこれを「押し進め」て、その変数の型を知ることができる。
<programlisting>
     (\ f -> (f True, f 'c')) :: (forall a. a->a) -> (Bool,Char)
</programlisting>
この例では、式の型シグネチャを内側に押し進めることで、fの型シグネチャを得ることができる。同様に、(こちらの方が良く使われるが)関数自体に型シグネチャを与えても良い。
<programlisting>
     h :: (forall a. a->a) -> (Bool,Char)
     h f = (f True, f 'c')
</programlisting>
ラムダ束縛された変数が構築子の引数なら型シグネチャは必要ない。以下は既に見た例である。
<programlisting>
    f :: T a -> a -> (a, Char)
    f (T1 w k) x = (w k x, w 'c' 'd')
</programlisting>
ここで<literal>w</literal>に型シグネチャを与える必要はない。これは構築子<literal>T1</literal>の引数であり、必要なことは全てこのことから分かる。
</para>

</sect3>


<sect3 id="implicit-quant">
<title>暗黙の量化</title>

<para>
GHCが暗黙の量化を行う手順は次のとおり。<emphasis>ユーザが書いた型の最上位(のみ)において、明示的な<literal>forall</literal>がないなら、またその時に限り、その型で言及されているもののスコープにない型変数を調べ上げ、それらを全称量化する。</emphasis>例えば、以下の組は互いに同等である。
<programlisting>
  f :: a -> a
  f :: forall a. a -> a

  g (x::a) = let
                h :: a -> b -> b
                h x y = y
             in ...
  g (x::a) = let
                h :: forall b. a -> b -> b
                h x y = y
             in ...
</programlisting>
</para>
<para>
GHCは、可能な最も内側の量化点を探したり<emphasis>しない</emphasis>ことに注意。例を示す。
<programlisting>
  f :: (a -> a) -> Int
           -- は
  f :: forall a. (a -> a) -> Int
           -- のことであり
  f :: (forall a. a -> a) -> Int
           -- ではない


  g :: (Ord a => a -> a) -> Int
           -- は
  g :: forall a. (Ord a => a -> a) -> Int
           -- という不正な型のことであり
  g :: (forall a. Ord a => a -> a) -> Int
           -- ではない
</programlisting>
後者は不正な型になる。これは馬鹿げていると思うかもしれないが、少なくとも規則は単純である。後者の型が欲しいなら、明示的にforallを書けば良い。実際、ランク2型についてはそうすることが強く推奨される。
</para>
</sect3>
</sect2>


<sect2 id="impredicative-polymorphism">
<title>非叙述的多相
</title>
<para>GHCは<emphasis>非叙述的多相</emphasis>(impredicative polymorphism)を扱え、<option>-XImpredicativeTypes</option>で有効になる。これは、多相的関数を多相型で呼ぶことができ、データ構造に多相的な型をパラメタとして与えることができるということである。例を挙げる。
<programlisting>
  f :: Maybe (forall a. [a] -> [a]) -> Maybe ([Int], [Char])
  f (Just g) = Just (g [3], g "hello")
  f Nothing  = Nothing
</programlisting>
<literal>Maybe</literal>に<emphasis>多相的</emphasis>な型である<literal>(forall a. [a] -> [a])</literal>が与えられていることに注意。</para>
<para>この拡張についての技術的な詳細は、論文<ulink url="http://research.microsoft.com/%7Esimonpj/papers/boxy/">Boxy types: type inference for higher-rank types and impredicativity</ulink>にある。これはICFP 2006に現れた。
</para>
</sect2>

<sect2 id="scoped-type-variables">
<title>字句的スコープを持つ型変数
</title>

<para>
GHCは<emphasis>字句的スコープを持つ型変数</emphasis>をサポートしている。これがないと、ある種の型シグネチャは書く方法が全くない。例を挙げる。
<programlisting>
f :: forall a. [a] -> [a]
f xs = ys ++ ys
     where
       ys :: [a]
       ys = reverse xs
</programlisting>
<literal>f</literal>の型シグネチャが型変数<literal>a</literal>をスコープに導入している。この型変数のスコープは<literal>f</literal>の定義全体である。特に、<varname>ys</varname>の型シグネチャの位置ではこれがスコープに入っている。Haskell 98では、<varname>ys</varname>の型を宣言するのは不可能であった。これが可能になったことは、型変数が字句的スコープを持つことの重要な利点の一つである。
</para>
<para>字句的スコープを持つ型変数は<option>-XScopedTypeVariables</option>で有効になる。このフラグを指定すると、<option>-XRelaxedPolyRec</option>も有効になる。</para>
<para>注意: GHC 6.6では、字句的スコープを持つ型変数の挙動について大幅な変更が加えられた。この節を注意深く読んでほしい。</para>

<sect3>
<title>概観</title>
<para>以下の原則に沿って設計されている。
<itemizedlist>
<listitem><para>スコープを持つ型変数は型<emphasis>変数</emphasis>を表すものであり、<emphasis>型</emphasis>を表すものではない。(これはGHCの以前の設計との相異点である)</para></listitem>
<listitem><para>さらに、異なる字句的な型変数は異なる型変数を表す。従って、プログラマの書いた型シグネチャ(スコープを持つ型変数を含む物も)は<emphasis>固い</emphasis>(rigid)型を表す。つまり、その型は型検査器にとって完全に既知であり、推論は関与しない。</para></listitem>
<listitem><para>字句的スコープを持つ型変数は、プログラムの意味を変えることなく、自由にα改名できる。</para></listitem>
</itemizedlist>
</para>
<para>
<emphasis>字句的スコープを持つ型変数</emphasis>は以下の方法で束縛できる。
<itemizedlist>
<listitem><para>宣言型シグネチャ(<xref linkend="decl-type-sigs"/>)</para></listitem>
<listitem><para>式型シグネチャ(<xref linkend="exp-type-sigs"/>)</para></listitem>
<listitem><para>パターン型シグネチャ(<xref linkend="pattern-type-sigs"/>)</para></listitem>
<listitem><para>クラス宣言およびインスタンス宣言(<xref linkend="cls-inst-scoped-tyvars"/>)</para></listitem>
</itemizedlist>
</para>
<para>
Haskellでは、プログラマの書いた型シグネチャは、その自由変数について暗黙に量化される(Haskellレポートの<ulink url="http://www.haskell.org/onlinereport/decls.html#sect4.1.2">4.1.2節</ulink>(<ulink url="http://www.sampou.org/haskell/report-revised-j/decls.html#sect4.1.2">和訳</ulink>))。字句的スコープを持つ型変数がこの暗黙量化規則に与える影響として、スコープにある型変数は全称量化されない。例えば、型変数<literal>a</literal>がスコープにあるとすると、
<programlisting>
  (e :: a -> a)     は     (e :: a -> a)          を意味する
  (e :: b -> b)     は     (e :: forall b. b->b)  を意味する
  (e :: a -> b)     は     (e :: forall b. a->b)  を意味する
</programlisting>
</para>


</sect3>


<sect3 id="decl-type-sigs">
<title>宣言型シグネチャ</title>
<para><emphasis>明示的な</emphasis>量化(<literal>forall</literal>を使ったもの)を伴う型シグネチャがあると、その明示的に量化された型変数は、その関数の定義内において、スコープに導入される。例を挙げる。
<programlisting>
  f :: forall a. [a] -> [a]
  f (x:xs) = xs ++ [ x :: a ]
</programlisting>
<literal>forall a</literal>によって、<literal>a</literal>が<literal>f</literal>の定義内でスコープに導入されている。
</para>
<para>これは、以下の場合にのみ発生する。
<itemizedlist>
<listitem><para><literal>f</literal>の型シグネチャにおける量化が明示的である。例えば、
<programlisting>
  g :: [a] -> [a]
  g (x:xs) = xs ++ [ x :: a ]
</programlisting>
このプログラムは拒絶される。<literal>a</literal>は<literal>f</literal>の定義においてスコープにないので、<literal>x::a</literal>は、通常のHaskellの暗黙量化規則に従って、<literal>x::forall a. a</literal>と解釈される。
</para></listitem>
<listitem><para>シグネチャの対象とする束縛が関数束縛または裸の変数束縛であって、パターン束縛でない。例えば、
<programlisting>
  f1 :: forall a. [a] -> [a]
  f1 (x:xs) = xs ++ [ x :: a ]   -- 良い

  f2 :: forall a. [a] -> [a]
  f2 = \(x:xs) -> xs ++ [ x :: a ]   -- 良い

  f3 :: forall a. [a] -> [a] 
  Just f3 = Just (\(x:xs) -> xs ++ [ x :: a ])   -- これは駄目！
</programlisting>
<literal>f3</literal>の束縛はパターン束縛なので、この型シグネチャは<literal>a</literal>をスコープに導入しない。一方、<literal>f1</literal>は関数束縛で、<literal>f2</literal>は裸の変数を束縛している。したがって、これらでは両方ともシグネチャが<literal>a</literal>をスコープに導入している。
</para></listitem>
</itemizedlist>
</para>
</sect3>

<sect3 id="exp-type-sigs">
<title>式型シグネチャ</title>

<para><emphasis>明示的な</emphasis>(forallを使った)量化を伴った式型シグネチャがあると、それらの型変数は、その型シグネチャの付いた式の内部において、スコープに導入される。例を挙げる。
<programlisting>
  f = runST ( (op >>= \(x :: STRef s Int) -> g x) :: forall s. ST s Bool )
</programlisting>
この場合、<literal>forall s. ST s Bool</literal>という型シグネチャによって、型変数<literal>s</literal>が、シグネチャの付いた式<literal>(op >>= \(x :: STRef s Int) -> g x)</literal>の内部においてスコープに導入される。</para>
</sect3>

<sect3 id="pattern-type-sigs">
<title>パターン型シグネチャ</title>
<para>
型シグネチャは任意のパターンの中に現れても良い。これは<emphasis>パターン型シグネチャ</emphasis>と呼ばれる。例を挙げる。
<programlisting>
  -- f と g では、'a'が既にスコープにあることを期待している
  f = \(x::Int, y::a) -> x
  g (x::a) = x
  h ((x,y) :: (Int,Bool)) = (y,x)
</programlisting>
パターン型シグネチャに現れる型変数がすべて既にスコープにある場合(つまり、外側の文脈で束縛されている場合)、事態は簡単である。そのシグネチャは、パターンの型を当たり前の方法で制限するだけのものである。
</para>
<para>
式型シグネチャや宣言型シグネチャと違って、パターン型シグネチャは暗黙に一般化されることがない。<emphasis>パターン束縛</emphasis>中のパターンは、既にスコープにある型変数にしか言及してはならない。例を示す。
<programlisting>
  f :: forall a. [a] -> (Int, [a])
  f xs = (n, zs)
    where
      (ys::[a], n) = (reverse xs, length xs) -- OK
      zs::[a] = xs ++ ys                     -- OK

      Just (v::b) = ...  -- 駄目。bがスコープにないので。
</programlisting>
ここで、<literal>ys</literal>と<literal>zs</literal>のパターンシグネチャは問題ないが、<literal>v</literal>のパターンシグネチャは、<literal>b</literal>がスコープにないので、不正である。
</para>
<para>
一方、パターン束縛<emphasis>以外</emphasis>の全てのパターンでは、パターン型シグネチャがスコープにない型変数に言及しても良い。この場合、<emphasis>このシグネチャがこの型変数をスコープに導入する</emphasis>。これは、存在的データ構築子の場合に特に重要である。例えば以下のような場合。
<programlisting>
  data T = forall a. MkT [a]

  k :: T -> T
  k (MkT [t::a]) = MkT t3
                 where
                   t3::[a] = [t,t,t]
</programlisting>
ここで、パターン型シグネチャ<literal>(t::a)</literal>は、スコープにない字句的型変数に言及している。実際、これはスコープにあっては<emphasis>ならない</emphasis>。このパターン照合で束縛されるからである。このような状況では(そしてこのような状況でのみ)、パターン型シグネチャがまだスコープにない型変数に言及できる、というのがGHCの規則である。作用として、その型変数はスコープに導入され、存在的に束縛された型変数を表すことになる。
</para>
<para>
パターン型シグネチャがこの方法で型変数を束縛する場合、GHCはその型変数が<emphasis>固い</emphasis>(完全に既知の)型変数に束縛されたと見なす。これによって、ユーザの書いた型シグネチャが全て完全に既知の型を表すことになる。
</para>
<para>
このあたりのことは少し奇妙に思えるかもしれない。我々もそう思う。しかし、このような型変数をスコープに導入する<emphasis>なんらかの</emphasis>方法は必要であり、さもなくば、後続の型シグネチャから存在束縛された型変数を名前で呼ぶことができなくなってしまう。
</para>
<para>
これはパターン型シグネチャがスコープにない字句的型変数に言及できる<emphasis>唯一の</emphasis>状況(になった)である。例えば、<literal>a</literal>がまだスコープにないなら、<literal>f</literal>と<literal>g</literal>は両方とも不正である。
</para>


</sect3>

<!-- ==================== Commented out part about result type signatures 

<sect3 id="result-type-sigs">
<title>Result type signatures</title>

<para>
The result type of a function, lambda, or case expression alternative can be given a signature, thus:

<programlisting>
  {- f assumes that 'a' is already in scope -}
  f x y :: [a] = [x,y,x]

  g = \ x :: [Int] -> [3,4]

  h :: forall a. [a] -> a
  h xs = case xs of
	    (y:ys) :: a -> y
</programlisting>
The final <literal>:: [a]</literal> after the patterns of <literal>f</literal> gives the type of 
the result of the function.  Similarly, the body of the lambda in the RHS of
<literal>g</literal> is <literal>[Int]</literal>, and the RHS of the case
alternative in <literal>h</literal> is <literal>a</literal>.
</para>
<para> A result type signature never brings new type variables into scope.</para>
<para>
There are a couple of syntactic wrinkles.  First, notice that all three
examples would parse quite differently with parentheses:
<programlisting>
  {- f assumes that 'a' is already in scope -}
  f x (y :: [a]) = [x,y,x]

  g = \ (x :: [Int]) -> [3,4]

  h :: forall a. [a] -> a
  h xs = case xs of
	    ((y:ys) :: a) -> y
</programlisting>
Now the signature is on the <emphasis>pattern</emphasis>; and
<literal>h</literal> would certainly be ill-typed (since the pattern
<literal>(y:ys)</literal> cannot have the type <literal>a</literal>.

Second, to avoid ambiguity, the type after the &ldquo;<literal>::</literal>&rdquo; in a result
pattern signature on a lambda or <literal>case</literal> must be atomic (i.e. a single
token or a parenthesised type of some sort).  To see why,
consider how one would parse this:
<programlisting>
  \ x :: a -> b -> x
</programlisting>
</para>
</sect3>

 -->

<sect3 id="cls-inst-scoped-tyvars">
<title>クラス宣言とインスタンス宣言</title>
<para>
<literal>class</literal>または<literal>instance</literal>宣言の頭部の中の型変数は、対応する<literal>where</literal>部分の全体に渡るスコープを持つ。例。


<programlisting>
  class C a where
    op :: [a] -> a

    op xs = let ys::[a]
                ys = reverse xs
            in
            head ys
</programlisting>
</para>
</sect3>

</sect2>

<sect2 id="typing-binds">
<title>相互再帰的な束縛に対する型付けの一般化</title>

<para>
Haskellレポートでは、束縛のグループ(最上位、または<literal>let</literal>や<literal>where</literal>中のもの)は、まず強連結な成分に分割され、次に依存性の順に型検査されると規定されている(<ulink url="http://www.haskell.org/onlinereport/decls.html#sect4.5.1">Haskellレポートの4.5.1節</ulink>(<ulink url="http://www.sampou.org/haskell/report-revised-j/decls.html#sect4.5.1">和訳</ulink>))。個々のグループが型検査されるとき、グループの中の明示的な型シグネチャのある束縛は、指定された多相型を持つものとして型環境に入れられ、そうでないものは全て、グループが一般化されるまで単相的でありつづける。(<ulink url="http://www.haskell.org/onlinereport/decls.html#sect4.5.2">Haskellレポートの4.5.2節</ulink>(<ulink url="http://www.sampou.org/haskell/report-revised-j/decls.html#sect4.5.2">和訳</ulink>))
</para>

<para>Mark Jonesの論文<ulink url="http://citeseer.ist.psu.edu/424440.html">Typing Haskell in Haskell</ulink>での提案に従って、GHCはより一般的な様式を実装している。<option>-XRelaxedPolyRec</option>が指定されているとき、<emphasis>依存性解析において、明示的な型シグネチャのある変数への参照は無視される</emphasis>。依存性解析がこのように変更される結果、依存性グループは小さくなり、より多くの束縛が型検査を通るようになる。例として以下を考える。
<programlisting>
  f :: Eq a =&gt; a -> Bool
  f x = (x == x) || g True || g "Yes"
  
  g y = (y &lt;= y) || f True
</programlisting>
Haskell 98ではこれは不正であるが、Jonesの様式の元では、まず<literal>g</literal>の定義の型検査が、<literal>f</literal>とは独立に行われる。これは、<literal>g</literal>の右辺での<literal>f</literal>への参照が依存性解析に無視されるからである。次に<literal>g</literal>の型が一般化され、以下のものが得られる。
<programlisting>
  g :: Ord a =&gt; a -> Bool
</programlisting>
今度は、<literal>g</literal>の型を型環境に置いて、<literal>f</literal>の定義が型検査される。
</para>

<para>
また、この改良された依存性解析によって、相互再帰的な関数のシグネチャが互いに異なる文脈を持つことができるようになった。これはHaskell 98では不正である(4.5.2節の最後の文)。<option>-XRelaxedPolyRec</option>が使われているとき、GHCは<emphasis>改良された</emphasis>グループについてのみ、シグネチャが同じ文脈を持っていることを要求する。これは実際的には、同じ文脈を持たなければならないのは、一つのパターン束縛で束縛された複数の変数だけだということである。例えば、以下のものは問題ない。
<programlisting>
  f :: Eq a =&gt; a -> Bool
  f x = (x == x) || g True
  
  g :: Ord a =&gt; a -> Bool
  g y = (y &lt;= y) || f True
</programlisting>
</para>
</sect2>

</sect1>
<!-- ==================== End of type system extensions =================  -->

<!-- ====================== TEMPLATE HASKELL =======================  -->

<sect1 id="template-haskell">
<title>Template Haskell</title>

<para>Template HaskellはHaskellでコンパイル時メタプログラミングをすることを可能にする。主要な技術的革新の背景は"<ulink url="http://research.microsoft.com/~simonpj/papers/meta-haskell/">Template Meta-programming for Haskell</ulink>" (Proc Haskell Workshop 2002)で議論されている。
</para>
<para>
Template Haskellに関するwikiページが<ulink url="http://www.haskell.org/haskellwiki/Template_Haskell">http://www.haskell.org/haskellwiki/Template_Haskell/</ulink>にある。また、<ulink url="http://www.haskell.org/ghc/docs/latest/html/libraries/index.html">オンラインHaskellライブラリリファレンス</ulink>を参照することもできる(<literal>Language.Haskell.TH</literal>というモジュールを探すと良い)。元の設計からの多くの変更点が<ulink url="http://research.microsoft.com/~simonpj/tmp/notes2.ps">Notes on Template Haskell version 2</ulink>に記されている。しかし、これらの変更点が全てGHCにある訳ではない。
</para>

<para>下(<xref linkend="th-example"/>)では、入門用の例として、論文の最初の例を使っている。
</para>

<para>
この文書は、GHCにおいてTemplate Haskellがどういう形で実現されているかを述べるものであり、Template Haskellを理解できるほど詳細ではない。<ulink url="http://haskell.org/haskellwiki/Template_Haskell">Wikiページ</ulink>を見よ。
</para>

    <sect2>
      <title>構文</title>

      <para>Template Haskellには以下に述べる新しい構文要素がある。これらの構文的拡張を有効にするにはフラグ<option>-XTemplateHaskell</option><indexterm><primary><option>-XTemplateHaskell</option></primary></indexterm>を使う必要がある。(<option>-XTemplateHaskell</option>は、<option>-fglasgow-exts</option>を使っていても、もはや自動的に有効にならない)</para>

	<itemizedlist>
	      <listitem><para>接合は、<literal>$x</literal>(「<literal>x</literal>」は識別子)または<literal>$(...)</literal>(「...」は任意の式)と書く。「$」と識別子や括弧の間には空白があってはならない。「$」のこの使いかたは中置演算子としての意味より優先される。「MM.x」が中置演算子としての「.」よりも優先されるのと同じである。中置演算子が必要なら、周りにスペースを置くこと。
		  </para>
	      <para>接合は次の場所に現れ得る。
		  <itemizedlist>
		    <listitem><para>式。接合される式の型は<literal>Q Exp</literal>でなければならない。</para></listitem>
		    <listitem><para>トップレベル宣言のリスト。接合される式の型は<literal>Q [Dec]</literal>でなければならない。</para></listitem>
		    </itemizedlist>
		</para>
接合の中ではインポートしたモジュールで定義された関数しか呼ぶことができず、同じモジュールの別の場所で定義された関数は呼ぶことが出来ない。</listitem>


	      <listitem><para>
                  式クォートは次のようにオックスフォード角括弧で囲んで書かれる。
		  <itemizedlist>
		    <listitem><para> <literal>[| ... |]</literal>、ただし「...」は式。このクォートの型は<literal>Q Exp</literal>である。</para></listitem>
		    <listitem><para> <literal>[d| ... |]</literal>、ただし「...」は最上位の宣言の列。このクォートの型は<literal>Q [Dec]</literal>である。</para></listitem>
		    <listitem><para> <literal>[t| ... |]</literal>、ただし「...」は型。このクォートの型は<literal>Q Typ</literal>である。</para></listitem>
		  </itemizedlist></para></listitem>

	      <listitem><para>
準クォートはパターン文脈または式文脈に出現可能で、これもオックスフォード括弧を使って書く。
		  <itemizedlist>
		    <listitem><para> <literal>[:<replaceable>varid</replaceable>| ... |]</literal>、
ただし「...」は任意の文字列である。準クォート機能の完全な記述は<xref linkend="th-quasiquotation"/>にある。</para></listitem>
		  </itemizedlist></para></listitem>

	      <listitem><para>
名前は、一つか二つの一重引用符を前置することで、クォートすることができる。
		  <itemizedlist>
		    <listitem><para> <literal>'f</literal>の型は<literal>Name</literal>であり、関数<literal>f</literal>を指す。同様に<literal>'C</literal>の型は<literal>Name</literal>であり、データ構築子<literal>C</literal>を指す。一般に、<literal>'</literal><replaceable>thing</replaceable>は<replaceable>thing</replaceable>を式文脈の中で解釈する。
		     </para></listitem> 
		    <listitem><para> <literal>''T</literal>の型は<literal>Name</literal>であり、型構築子<literal>T</literal>を指す。つまり、<literal>''</literal><replaceable>thing</replaceable>は<replaceable>thing</replaceable>を型文脈の中で解釈する。
		     </para></listitem> 
		  </itemizedlist>
	          これらの<literal>Name</literal>は、Template Haskellの式やパターンや宣言などを構築するのに使うことができる。また、関数<literal>reify</literal>へ引数として与えることもできる。
	         </para>
		</listitem>

		  
	</itemizedlist>
(元の論文と比較すると、細部に多くの違いがある。宣言接合では「<literal>splice</literal>」でなく「<literal>$</literal>」が使われる。中身の式の型は<literal>[Q Dec]</literal>でなく<literal>Q [Dec]</literal>でなければならない。型接合は実装されておらず、パターン接合やクォーテーションも同じである。
</sect2>

<sect2 id="th-example">  <title>Template Haskellを使う</title>
<para>
<itemizedlist>
    <listitem><para>Template Haskell用のデータ型とモナド構築関数はライブラリ<literal>Language.Haskell.THSyntax</literal>にある。
    </para></listitem>

    <listitem><para>ある関数をコンパイル時に走らせることができるのは、その関数が別のモジュールからインポートされているときだけである。言い替えると、あるモジュールで関数を定義し、同じモジュールの接合でその関数を呼ぶということはできない。(そうすることに意味がない訳ではない。ただ実装が難しい)
   </para></listitem>

    <listitem><para>ある関数をコンパイル時に走らせることができるのは、その関数のインポート元モジュールが、<emphasis>コンパイル中のモジュールと同じ相互再帰グループに属していない</emphasis>場合だけである。さらに、その相互再帰グループの全てのモジュールが、接合が実行されるモジュールから非SOURCEなインポートを介して到達可能でなければならない。</para>
    <para>例として、Aというモジュールをコンパイルしているとき、BからインポートされたTemplate Haskellの関数を走らせることができるのは、BがAを(直接または間接に)インポートしていない場合だけである。理由は明白なはずである。Bを走らせるにはAをコンパイルして走らせねばならないが、我々は今まさにAを型検査しているのだから。</para></listitem>

    <listitem><para>
            <literal>-ddump-splices</literal>フラグを使うと、最上位の接合が展開されるたびにそれが表示される。
   </para></listitem>
    <listitem><para>
            GHCをソースからビルドしているなら、Template Haskellを使うには少なくともstage-2のブートストラップコンパイラが必要である。stage-1コンパイラはTHの要素を受け付けない。これは次のような理由による。THコンパイラはプログラムを実行し、その結果を見る。そのため、コンパイルされるプログラムの出力がコンパイラのものと同じ表現を持っていることが重要である。
   </para></listitem>
</itemizedlist>
</para>
<para>Template Haskellはどのモード(<literal>--make</literal>、<literal>--interactive</literal>、ファイル毎)でも動作する。過去には前者二つについて制限があったが、これは撤廃された。
</para>
</sect2>
 
<sect2>  <title>Template Haskellの実例</title>
<para>自信障壁(confidence barrier)を乗り越えるために、以下の、枠組を理解してもらうための例を試してみてほしい。まず、下の二つのモジュールを「Main.hs」と「Printf.hs」とにコピペする。</para>

<programlisting>

{- Main.hs -}
module Main where

-- 後で定義する「pr」というテンプレートをインポートする。
import Printf ( pr )

-- 接合演算子$は、prによってコンパイル時に生成された
-- Haskellのソースコードをとり、これをputStrLnの引数とし
-- て接合する。
main = putStrLn ( $(pr "Hello") )


{- Printf.hs -}
module Printf where

-- printfの枠組。論文より。
-- 使うモジュールとは別の場所で定義されていなければなら
-- ない。

-- Template Haskellの構文をインポートする
import Language.Haskell.TH

-- 書式文字列を記述する
data Format = D | S | L String

-- 書式文字列をパースする。ここでの目的は我々の最初の
-- Template Haskellのプログラムを組み上げることであり、
-- printfを組むことではないので、大部分未実装のまま残し
-- てある。
parse :: String -> [Format]
parse s   = [ L s ]

-- パースされた書式文字列の表現からHaskellのソースコー
-- ドを生成する。生成されたコードは、「pr」を呼んだモジ
-- ュールにコンパイル時に接合される。
gen :: [Format] -> Q Exp
gen [D]   = [| \n -> show n |]
gen [S]   = [| \s -> s |]
gen [L s] = stringE s

-- 入力の書式文字列から、接合するHaskellコードを生成する。
pr :: String -> Q Exp
pr s = gen (parse s)
</programlisting>

<para>次にコンパイラを走らせる。(これはWindows上のCygwinプロンプトである)
</para>
<programlisting>
$ ghc --make -XTemplateHaskell main.hs -o main.exe
</programlisting>

<para>「main.exe」を走らせれば出力が得られる。</para>

<programlisting>
$ ./main
Hello
</programlisting>

</sect2>

<sect2>
<title>Template Haskellをプロファイルと併用する</title>
<indexterm><primary>profiling</primary><secondary>with Template Haskell</secondary></indexterm>
 
<para>Template Haskellは、接合する式を走らせるのに、GHCの組込みのバイトコードコンパイラと解釈実行器に依存している。バイトコードの解釈実行器は、コンパイルされた式を実行する際、GHC自身が土台としているのと同じランタイムを使う。従って、解釈される式から参照されるコンパイル済みコードは、このランタイムと互換性がなければならない。特に、プロファイルのためにコンパイルされたオブジェクトコードを接合式からロードして実行することは<emphasis>できない</emphasis>。プロファイル版のオブジェクトコードはプロファイル版のランタイムとしか互換性がないからである。</para>

<para>Template Haskellのコードを含む、複数のモジュールからなるプログラムがあって、それをプロファイル用にコンパイルする必要があるとき、このことが問題になる。接合を実行するときにプロファイル用オブジェクトコードをロードして用いることができないからである。幸運にも、GHCは回避策を提供している。基本的な考え方は、プログラムを二回コンパイルするというものである。</para>

<orderedlist>
<listitem>
  <para><option>-prof</option><indexterm><primary><option>-prof</option></primary></indexterm>なしで、通常の方法でそのプログラムまたはライブラリをコンパイルする。</para>
</listitem>
<listitem>
  <para><option>-pdof</option>付きで、さらにオブジェクトファイルの名前を別のものにするために<option>-osuf p_o</option><indexterm><primary><option>-osuf</option></primary></indexterm>(通常の接尾辞以外なら何を使っても良い)も付けて、もう一度コンパイルする。GHCは、接合式を実行する際、最初の手順で構築されたオブジェクトファイルを自動的にロードする。<option>-prof</option>付きでコンパイルするとき、<option>-osuf</option>を使わず、かつTemplate Haskellが使われているなら、GHCはエラーメッセージを出力する。</para>

</listitem>
</orderedlist>
</sect2>

<sect2 id="th-quasiquotation">  <title>Template Haskellの準クォート</title>
<para>準クォートは、パターンおよび式をプログラマが定義した具象構文を使って書くことを可能にする。この拡張の背後にある動機といくつかの例が"<ulink url="http://www.eecs.harvard.edu/~mainland/ghc-quasiquoting/">Why It's Nice to be Quoted: Quasiquoting for Haskell</ulink>" (Proc Haskell Workshop 2007)に述べられている。以下の例では、単純な式言語のための準クォータをどうやって書くかを紹介する。</para>

<para>
この例において、準クォータ<literal>expr</literal>は<literal>Language.Haskell.TH.Quote.QuasiQuoter</literal>型の値に束縛されている。この型は二つの関数を含み、それぞれ式とパターンをクォートするのに用いられる。それぞれのクォータの最初の引数はオックスフォード括弧で囲まれた(任意の)文字列であり、準クォート文の文脈によって二つのパーサのどちらが呼ばれるかが決まる。準クォートが式文脈で現れたなら式パーサが呼ばれ、パターン文脈で現れたならパターンパーサが呼ばれる。</para>

<para>
以下では、<literal>'int:n</literal>という構文を使って、変数<literal>n</literal>を逆クォートしたものを表していることに注意(逆クォートにこの構文を使うことはこのパーサの作者が決めたことであり、GHCによって決められたことでは<emphasis>ない</emphasis>)。パターン照合の際、これは<literal>n</literal>を構築子<literal>IntExpr</literal>の整数引数に束縛する。逆クォートに関する更なる詳細については参照した論文を見てほしい。この論文には<literal>String -> a</literal>という型の単一のパーサを活用して、<literal>Q Exp</literal>型の値を返す式パーサと、<literal>Q Pat</literal>型の値を返すパターンパーサの両方を生成するためのSYBを使ったテクニックの説明もある。
</para>

<para>一般に、準クォートは<literal>[$<replaceable>quoter</replaceable>| <replaceable>string</replaceable> |]</literal>という形をしている。<replaceable>quoter</replaceable>はインポートされたクォータの名前でなければならない。ここでは任意の式が使える訳ではない。クォートされる<replaceable>string</replaceable>は任意のものであってよく、改行を含んでいてもよい。
</para>
<para>
準クォータはTemplate Haskellと同じステージ制限に従わねばならない。たとえば、この例において<literal>expr</literal>は<literal>Main.hs</literal>で使われているので、そこで定義されることはできず、インポートされねばならない。
</para>

<programlisting>

{- Main.hs -}
module Main where

import Expr

main :: IO ()
main = do { print $ eval [$expr|1 + 2|]
          ; case IntExpr 1 of
              { [$expr|'int:n|] -> print n
              ;  _              -> return ()
              }
          }


{- Expr.hs -}
module Expr where

import qualified Language.Haskell.TH as TH
import Language.Haskell.TH.Quote

data Expr  =  IntExpr Integer
           |  AntiIntExpr String
           |  BinopExpr BinOp Expr Expr
           |  AntiExpr String
    deriving(Show, Typeable, Data)

data BinOp  =  AddOp
            |  SubOp
            |  MulOp
            |  DivOp
    deriving(Show, Typeable, Data)

eval :: Expr -> Integer
eval (IntExpr n)        = n
eval (BinopExpr op x y) = (opToFun op) (eval x) (eval y)
  where
    opToFun AddOp = (+)
    opToFun SubOp = (-)
    opToFun MulOp = (*)
    opToFun DivOp = div

expr = QuasiQuoter parseExprExp parseExprPat

-- Exprをパースし、その表現をQ ExpまたはQ Patとして返す。
-- 二つのパーサを別々に書くことなく、一つのString -> Expr
-- という型のパーサを書くだけで済ますために、
-- SYBをどう使えばよいかについては、参照先の論文を見よ。

parseExprExp :: String -> Q Exp
parseExprExp ...

parseExprPat :: String -> Q Pat
parseExprPat ...
</programlisting>

<para>ではコンパイラを走らせよう。
</para>
<programlisting>
$ ghc --make -XQuasiQuotes Main.hs -o main
</programlisting>

<para>
"main"を走らせれば次のような出力になる。
</para>

<programlisting>
$ ./main
3
1
</programlisting>

</sect2>

</sect1>

<!-- ===================== Arrow notation ===================  -->

<sect1 id="arrow-notation">
<title>アロー記法
</title>

<para>アローはモナドの一般化であり、John Hughesによって導入された。詳細については、以下のものを見よ。
<itemizedlist>

<listitem>
<para>
&ldquo;Generalising Monads to Arrows&rdquo;,
John Hughes, in <citetitle>Science of Computer Programming</citetitle> 37,
pp67&ndash;111, May 2000。アローを導入した論文である。平易な入門であり、動機付けとしてプログラミングの例が使われている。
</para>
</listitem>

<listitem>
<para>
&ldquo;<ulink url="http://www.soi.city.ac.uk/~ross/papers/notation.html">A New Notation for Arrows</ulink>&rdquo;,
Ross Paterson, in <citetitle>ICFP</citetitle>, Sep 2001。
ここで記述されている記法を導入した。
</para>
</listitem>

<listitem>
<para>
&ldquo;<ulink url="http://www.soi.city.ac.uk/~ross/papers/fop.html">Arrows and Computation</ulink>&rdquo;,
Ross Paterson, in <citetitle>The Fun of Programming</citetitle>,
Palgrave, 2003.
</para>
</listitem>

<listitem>
<para>
&ldquo;<ulink url="http://www.cs.chalmers.se/~rjmh/afp-arrows.pdf">Programming with Arrows</ulink>&rdquo;,
John Hughes, in <citetitle>5th International Summer School on
Advanced Functional Programming</citetitle>,
<citetitle>Lecture Notes in Computer Science</citetitle> vol. 3622,
Springer, 2004。
この論文にもこの記法への入門が含まれており、実際的な例もついている。
</para>
</listitem>

<listitem>
<para>
&ldquo;<ulink url="http://www.haskell.org/ghc/docs/papers/arrow-rules.pdf">Type and Translation Rules for Arrow Notation in GHC</ulink>&rdquo;,
Ross Paterson and Simon Peyton Jones, September 16, 2004.
形式的な規則を簡潔に列挙したもの(ソースコード中のコメントから抽出された)。
</para>
</listitem>

<listitem>
<para><ulink url="http://www.haskell.org/arrows/"><literal>http://www.haskell.org/arrows/</literal></ulink>にアローのウェブページがある。</para>
</listitem>

</itemizedlist>
<option>-XArrows</option>フラグが与えられると、GHCは二番目の論文に記述されているアロー記法をサポートする。この記法は、<ulink url="../libraries/base/Control-Arrow.html"><literal>Control.Arrow</literal></ulink>モジュールのコンビネータを使って通常のHaskellに翻訳される。以下に示すのは、この記法の短い紹介である。Hughesの論文を読まないとあまり意味が分からないだろう。
</para>

<para>この拡張によって、アローを定義するための新しい種類の式が追加される。
<screen>
<replaceable>exp</replaceable><superscript>10</superscript> ::= ...
       |  proc <replaceable>apat</replaceable> -> <replaceable>cmd</replaceable>
</screen>
ここで、<literal>proc</literal>は新しいキーワードである。パターン中の変数は<literal>proc</literal>式の本体において束縛されている。本体は、<firstterm>コマンド</firstterm>と呼ばれる、新しい種類のものである。コマンドの構文は以下のとおりである。
<screen>
<replaceable>cmd</replaceable>   ::= <replaceable>exp</replaceable><superscript>10</superscript> -&lt;  <replaceable>exp</replaceable>
       |  <replaceable>exp</replaceable><superscript>10</superscript> -&lt;&lt; <replaceable>exp</replaceable>
       |  <replaceable>cmd</replaceable><superscript>0</superscript>
</screen>
加えて、<replaceable>cmd</replaceable><superscript>0</superscript>から<replaceable>cmd</replaceable><superscript>9</superscript>までが、式の場合と同じように、中置演算子を使って定義される。
<screen>
<replaceable>cmd</replaceable><superscript>10</superscript> ::= \ <replaceable>apat</replaceable> ... <replaceable>apat</replaceable> -> <replaceable>cmd</replaceable>
       |  let <replaceable>decls</replaceable> in <replaceable>cmd</replaceable>
       |  if <replaceable>exp</replaceable> then <replaceable>cmd</replaceable> else <replaceable>cmd</replaceable>
       |  case <replaceable>exp</replaceable> of { <replaceable>calts</replaceable> }
       |  do { <replaceable>cstmt</replaceable> ; ... <replaceable>cstmt</replaceable> ; <replaceable>cmd</replaceable> }
       |  <replaceable>fcmd</replaceable>

<replaceable>fcmd</replaceable>  ::= <replaceable>fcmd</replaceable> <replaceable>aexp</replaceable>
       |  ( <replaceable>cmd</replaceable> )
       |  (| <replaceable>aexp</replaceable> <replaceable>cmd</replaceable> ... <replaceable>cmd</replaceable> |)

<replaceable>cstmt</replaceable> ::= let <replaceable>decls</replaceable>
       |  <replaceable>pat</replaceable> &lt;- <replaceable>cmd</replaceable>
       |  rec { <replaceable>cstmt</replaceable> ; ... <replaceable>cstmt</replaceable> [;] }
       |  <replaceable>cmd</replaceable>
</screen>
ここで、<replaceable>calts</replaceable>は<replaceable>alts</replaceable>と同様だが、本体が式ではなくコマンドだという点が異なる。
</para>

<para>
コマンドは値を生み出すが、(モナドな計算と同じく)複数の値を生み出すこともあるし、零個のこともあるし、同時に別のことを行うこともある。大部分において、モナド記法に親しんでいればコマンドを使う上での良い助けになる。ただし、式(モナドなものも含めて)の値は含まれる変数の値によって決定されるのに対し、コマンドでは必ずしもそうではない。
</para>

<para>
次に示すのは、この新しい記法の簡単な例である。
<screen>
proc x -> f -&lt; x+1
</screen>
これを、<firstterm>手続き</firstterm>または<firstterm>アロー抽象</firstterm>と呼ぶ。ラムダ式の場合と同様、変数<literal>x</literal>は<literal>proc</literal>式の内部で束縛される新しい変数である。この変数はアローへの入力を参照する。上の例で、<literal>-&lt;</literal>は識別子ではなく、新しい予約シンボルであり、アロー型の式とそのアローに食わせる式とからコマンドを構築するのに使う。(見た目が変だが、これについてはあとで納得できるだろう)。これはアローの適用に相当するものだと考えることもできる。上の例は次のHaskellの式に等しい。
<screen>
arr (\ x -> x+1) >>> f
</screen>
これは、<literal>-&lt;</literal>の左の式に束縛変数<literal>x</literal>が現れていたらおかしなことになる。一般に、<literal>-&lt;</literal>の左側の式には<firstterm>局所変数</firstterm>(現在のアロー抽象で束縛された変数)が現れてはならない。このような場合のために、<literal>-&lt;&lt;</literal>という変種があり、次のように使える。
<screen>
proc x -> f x -&lt;&lt; x+1
</screen>
これは以下のものと同じである。
<screen>
arr (\ x -> (f x, x+1)) >>> app
</screen>
よってこの場合のアローは<literal>ArrowApply</literal>クラスに属していなければならない。このようなアローはモナドと同等なので、モナドとして定式化した方が便利かも知れない。
</para>

<sect2>
<title>コマンドのdo記法</title>

<para>
コマンドは<literal>do</literal>記法の形をとることもある。例えば次のように書くことができる。
<screen>
proc x -> do
        y &lt;- f -&lt; x+1
        g -&lt; 2*y
        let z = x+y
        t &lt;- h -&lt; x*z
        returnA -&lt; t+z
</screen>
これは通常の<literal>do</literal>記法と大体同じように読むことができる。ただし、モナドな式の代わりにコマンドが使われている。最初の行では、<literal>x+1</literal>の値がアロー<literal>f</literal>に入力として送られ、出力が<literal>y</literal>に対して照合される。次の行では、出力は捨てられている。<function>returnA</function>というアローは、<ulink url="../libraries/base/Control-Arrow.html"><literal>Control.Arrow</literal></ulink>(訳注: 未訳。<ulink url="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html">web上の最新版</ulink>)モジュールで、<literal>arr id</literal>として定義されている。上の例は次のものの略記として扱われる。
<screen>
arr (\ x -> (x, x)) >>>
        first (arr (\ x -> x+1) >>> f) >>>
        arr (\ (y, x) -> (y, (x, y))) >>>
        first (arr (\ y -> 2*y) >>> g) >>>
        arr snd >>>
        arr (\ (x, y) -> let z = x+y in ((x, z), z)) >>>
        first (arr (\ (x, z) -> x*z) >>> h) >>>
        arr (\ (t, z) -> t+z) >>>
        returnA
</screen>
それ以降使われない変数は射影で捨てられていることに注意。これに<ulink url="../libraries/base/Control-Arrow.html"><literal>Control.Arrow</literal></ulink>で定義されている書き換え規則(<xref linkend="rewrite-rules"/>を見よ)を使って単純化を施すと、以下のように簡約される。
<screen>
arr (\ x -> (x+1, x)) >>>
        first f >>>
        arr (\ (y, x) -> (2*y, (x, y))) >>>
        first g >>>
        arr (\ (_, (x, y)) -> let z = x+y in (x*z, z)) >>>
        first h >>>
        arr (\ (t, z) -> t+z)
</screen>
手で書くなら最初からこう書いたであろう。アロー記法を使えば、GHCがあなたの代わりにこれらの変数のタプルたちを管理してくれる。</para>

<para>
なお、上の変換では、<literal>let</literal>束縛された変数(たとえば<literal>z</literal>)が単相的でなければならないように見えるが、実際の変換で生成されるのはcoreなので、変数は多相的であり得る。
</para>

<para>
相互再帰的な束縛を使うこともできる。これには、<literal>rec</literal>という新しいキーワードを使う。以下のようになる。
<programlisting>
counter :: ArrowCircuit a => a Bool Int
counter = proc reset -> do
        rec     output &lt;- returnA -&lt; if reset then 0 else next
                next &lt;- delay 0 -&lt; output+1
        returnA -&lt; output
</programlisting>
このような形式は、変換すると、<function>loop</function>コンビネータを使ったものになるので、その場合のアローは<literal>ArrowLoop</literal>クラスに属していなければならない。
</para>

</sect2>

<sect2>
<title>条件コマンド</title>

<para>
前の例では、アローへの入力を構築するために条件式を使った。場合によっては、以下のように、条件によって異なるコマンドを実行したいことがある。
<screen>
proc (x,y) ->
        if f x y
        then g -&lt; x+1
        else h -&lt; y+2
</screen>
これは次のように変換される。
<screen>
arr (\ (x,y) -> if f x y then Left x else Right y) >>>
        (arr (\x -> x+1) >>> f) ||| (arr (\y -> y+2) >>> g)
</screen>
変換結果で<function>|||</function>が使われているので、この場合のアローは<literal>ArrowChoice</literal>クラスに属していなければならない。
</para>

<para>
以下のような<literal>case</literal>コマンドもある。
<screen>
case input of
    [] -> f -&lt; ()
    [x] -> g -&lt; x+1
    x1:x2:xs -> do
        y &lt;- h -&lt; (x1, x2)
        ys &lt;- k -&lt; xs
        returnA -&lt; y:ys
</screen>
構文は<literal>case</literal>式と同じであるが、選択肢の本体が式でなくコマンドである点が異なる。変換は<literal>if</literal>で行われるものに似ている。
</para>

</sect2>

<sect2>
<title>制御構造を自分で定義する</title>

<para>
既に見たように、アロー記法には、逐次実行、値再帰、および条件分岐について、式のものを手本とした構文要素が提供されている。しかし、適切なコンビネータ(これはHaskellで普通に定義できる)があれば、それを、既存のコマンドから新しいコマンドをつくり出すのに使うこともできる。基本的な考え方としては、コマンドを、環境から値へのアローとみなすのである。環境は、コマンド中の自由な局所変数に値を割り当てる。これにより、アローからアローをつくり出すコンビネータは、コマンドからコマンドを構築するのにも使える。例えば、<literal>ArrowChoice</literal>クラスには次のコンビネータがある。
<programlisting>
ArrowChoice a => (&lt;+>) :: a e c -> a e c -> a e c
</programlisting>
よって、これを使ってコマンドを組み立てることができる。
<programlisting>
expr' = proc x -> do
                returnA -&lt; x
        &lt;+> do
                symbol Plus -&lt; ()
                y &lt;- term -&lt; ()
                expr' -&lt; x + y
        &lt;+> do
                symbol Minus -&lt; ()
                y &lt;- term -&lt; ()
                expr' -&lt; x - y
</programlisting>
(最初の行の<literal>do</literal>は、最初の<literal>&lt;+> ...</literal>が、直前の行の式の一部だとみなされるのを防ぐために必要である)。これは以下のものと同等である。
<programlisting>
expr' = (proc x -> returnA -&lt; x)
        &lt;+> (proc x -> do
                symbol Plus -&lt; ()
                y &lt;- term -&lt; ()
                expr' -&lt; x + y)
        &lt;+> (proc x -> do
                symbol Minus -&lt; ()
                y &lt;- term -&lt; ()
                expr' -&lt; x - y)
</programlisting>
この演算子が<literal>e</literal>(そのコマンドへの環境入力。必然的にそのサブコマンドへの環境入力にもなる)について多相的であって、少なくとも正格な<literal>k</literal>については以下の自然性を満たす、ということが本質的に重要である。
<screen>
arr k >>> (f &lt;+> g) = (arr k >>> f) &lt;+> (arr k >>> g)
</screen>
(<function>seq</function>を使っていないなら自動的にこうなるはずである)。これにより、サブコマンドが見る環境がコマンド全体の環境と同じだということ、および変換において環境のうちの不要な部分を捨てても安全だということが保証される。また、この演算子は、現在のアロー抽象の中で定義された変数を使っていてはならない。
</para>

<para>
次のように自分で演算子を定義し、同様の方法で使うこともできる。
<programlisting>
untilA :: ArrowChoice a => a e () -> a e Bool -> a e ()
untilA body cond = proc x ->
        b &lt;- cond -&lt; x
        if b then returnA -&lt; ()
        else do
                body -&lt; x
                untilA body cond -&lt; x
</programlisting>
もちろん、この中置記法の構文は二項演算子についてしかうまく働かない。特別な括弧を使った、より一般的な構文が存在する。
<screen>
proc x -> do
        y &lt;- f -&lt; x+1
        (|untilA (increment -&lt; x+y) (within 0.5 -&lt; x)|)
</screen>
</para>

</sect2>

<sect2>
<title>プリミティブな構成要素</title>

<para>
演算子によっては、サブコマンドに追加の引数を渡す必要がある。例えば、例外を扱えるアローにおいて、例外ハンドラを付加する演算子では、発生した例外をハンドラに渡したいと思うだろう。このような演算子は次のような型を持っていると考えられる。
<screen>
handleA :: ... => a e c -> a (e,Ex) c -> a e c
</screen>
ここで、<literal>Ex</literal>は扱われる例外の型である。このとき、次のようなコマンドを書くことで、これをアロー記法中で使うことができる。
<screen>
body `handleA` \ ex -> handler
</screen>
意図は、コマンド<literal>body</literal>が例外を発生させたら、変数<literal>ex</literal>がその例外の値に束縛され、コマンド<literal>handler</literal>(通常<literal>ex</literal>を参照する)に進入する、というものである。この構文は関数のラムダに似ているが、ここで扱われているのはコマンドであって、やっていることが異なる。コマンドが表すアローの入力は、コマンド中の自由な局所変数の値に加えて、無名の値のスタックから成る。ここまでの例ではこのスタックは全て空だった。<function>handleA</function>の第二引数では、このスタックは一つの値、すなわち例外の値から成る。コマンド用のラムダはこの値に名前を与えているに過ぎない。
</para>

<para>
より具体的にいうと、このスタック中の値は環境と一緒に対にされる。値は右側である。<function>handleA</function>のような、サブコマンドに追加の入力を渡す演算子は、その値を環境と一緒に対にすることでこの記法で使えるようになる。正確に言うと、演算子のそれぞれの引数(および結果)の型は以下の形をしているべきである。
<screen>
a (...(e,t1), ... tn) t
</screen>
ここで、<replaceable>e</replaceable>は(環境を表す)多相変数であり、<replaceable>ti</replaceable>はスタック中の値の型であり、<replaceable>t1</replaceable>が「先頭」である。多相変数<replaceable>e</replaceable>は<replaceable>a</replaceable>、<replaceable>ti</replaceable>、<replaceable>t</replaceable>に現れてはならない。一方、関係するアローが同じである必要はない。適切な演算子の例をもう少し示す。
<screen>
bracketA :: ... => a e b -> a (e,b) c -> a (e,c) d -> a e d
runReader :: ... => a e c -> a' (e,State) c
runState :: ... => a e c -> a' (e,State) (c,State)
</screen>
後ろ二者で作られたコマンドが必要とする追加の引数は、そのコマンドを通常の式に適用することで与えることができる。次のように。
<screen>
proc x -> do
        s &lt;- ...
        (|runReader (do { ... })|) s
</screen>
これは、<function>runReader</function>を使って作られたコマンドの入力のスタックに<literal>s</literal>を加えている。
</para>

<para>
コマンド版のラムダ抽象と適用は式におけるそれに似ている。特に、β規則とη規則がコマンドの同等性を記述する。これらの三つの機能(演算子、ラムダ抽象、適用)がこの記法の核である。他のものは全てこれらを使って(不格好になるだろうが)構築することができる。例えば、次のように定義することによって<literal>do</literal>記法をシミュレートできる。
<programlisting>
bind :: Arrow a => a e b -> a (e,b) c -> a e c
u `bind` f = returnA &amp;&amp;&amp; u >>> f

bind_ :: Arrow a => a e b -> a e c -> a e c
u `bind_` f = u `bind` (arr fst >>> f)
</programlisting>
次のように定義することで<literal>if</literal>をシミュレートできる。
<programlisting>
cond :: ArrowChoice a => a e b -> a e b -> a (e,Bool) b
cond f g = arr (\ (e,b) -> if b then Left e else Right e) >>> f ||| g
</programlisting>
</para>

</sect2>

<sect2>
<title>論文との差異</title>

<itemizedlist>

<listitem>
<para>一種類のアロー適用(アロー尾部)に二通りの変換を用意する代わりに、実装では二種類、すなわち「<literal>-&lt;</literal>」(一階)と「<literal>-&lt;&lt;</literal>」(高階)が提供されている。
</para>
</listitem>

<listitem>
<para>ユーザ定義の演算子を明示するのに、<literal>form</literal>という新しいキーワードではなく、バナナ括弧を使っている。
</para>
</listitem>

</itemizedlist>

</sect2>

<sect2>
<title>可搬性</title>

<para>
アロー記法を直接実装しているのはGHCだけであるが、アロー記法をHaskell 98に変換することで別のHaskellシステムでも使える前処理器(<ulink url="http://www.haskell.org/arrows/">arrows web page</ulink>から入手可能)もある。それでも、アローを使ったプログラムをGHCで検査したいと思うかもしれない。前処理器の出力から型エラーを追跡するのは簡単ではないからである。モジュールを、GHCとこの前処理器の両方で使えるようにする場合、いくつか余分な制約が科せられる。
<itemizedlist>

<listitem>
<para>
モジュールは<ulink url="../libraries/base/Control-Arrow.html"><literal>Control.Arrow</literal></ulink>(訳注: 未訳。<ulink url="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html">web上の最新版</ulink>)をインポートしなければならない。
</para>
</listitem>

<listitem>
<para>
前処理器は他のHaskell拡張に対応していないので、そういうものは別のモジュールに置かなければならない。
</para>
</listitem>

<listitem>
<para>
前処理器の出力はHaskell(Coreではなく)なので、<literal>let</literal>束縛された変数は単相的になる。
</para>
</listitem>

</itemizedlist>
</para>

</sect2>

</sect1>

<!-- ==================== BANG PATTERNS =================  -->

<sect1 id="bang-patterns">
<title>びっくりパターン
<indexterm><primary>Bang patterns</primary></indexterm>
</title>
<para>GHCは<emphasis>びっくりパターン</emphasis>と呼ばれるパターン照合の拡張をサポートしている。これは<literal>!<replaceable>pat</replaceable></literal>と書く。びっくりパターンはHaskell Primeへの採用が検討されている。<ulink url="http://hackage.haskell.org/trac/haskell-prime/wiki/BangPatterns">Haskell primeの特徴まとめ</ulink>には、以下にあるのよりも多くの議論と例が載っている。
</para>
<para>
鍵となる変更は、<ulink url="http://haskell.org/onlinereport/exps.html#sect3.17.2">Haskell98レポート中のパターン照合の意味論</ulink>(<ulink url="http://www.sampou.org/haskell/report-revised-j/exps.html#sect3.17.2">和訳</ulink>)に規則を一つ追加するというものである。第十項目として次を付け加える。「パターン<literal>!pat</literal>の値<literal>v</literal>への照合は、次のように振る舞う」
<itemizedlist>
<listitem><para>もし<replaceable>v</replaceable>がボトムなら、照合は発散する</para></listitem>
<listitem><para>そうでなければ、<replaceable>pat</replaceable>が<replaceable>v</replaceable>へと照合される</para></listitem>
</itemizedlist>
</para>
<para>
びっくりパターンはフラグ<option>-XBangPatterns</option>で有効になる。
</para>

<sect2 id="bang-patterns-informal">
<title>びっくりパターンについての非形式的な説明
</title>
<para>この拡張の要点は、パターンの構文に一つの新しい生成規則を追加することである。
<programlisting>
  pat ::= !pat
</programlisting>
式<literal>e</literal>をパターン<literal>!p</literal>に対して照合するとき、まず<literal>e</literal>が(WHNFまで)評価され、その結果が<literal>p</literal>に対して照合される。例を挙げる。
<programlisting>
f1 !x = True
</programlisting>
この定義では、<literal>f1</literal>が<literal>x</literal>について正格になっている。びっくりパターンがなければ遅延であったところだ。もちろん、びっくりパターンは入れ子にすることができる。
<programlisting>
f2 (!x, y) = [x,y]
</programlisting>
ここで、<literal>f2</literal>は<literal>x</literal>について正格だが、<literal>y</literal>については正格でない。びっくりパターンが実質的に効果を持つのは、変数パターンやワイルドカードパターンの前に置かれたときだけである。
<programlisting>
f3 !(x,y) = [x,y]
f4 (x,y)  = [x,y]
</programlisting>
ここでは、<literal>f3</literal>と<literal>f4</literal>は等しい。もともと評価を強制するパターンの前にびっくりマークを置いても何も変わらない。
</para>
<para>
この、「びっくりマークは変数かワイルドカードの前に置かれたときのみ違いがある」という一般的な法則には、(見掛け上の)例外が一つある。<literal>let</literal>または<literal>where</literal>束縛の最上位におけるびっくりマークは、パターンに関係なく、その束縛を正格にする。例を示す。
<programlisting>
let ![x,y] = e in b
</programlisting>
これは正格な束縛である。操作的に言うと、まず<literal>e</literal>が評価され、パターン<literal>[x,y]</literal>に対して照合され、そして<literal>b</literal>が評価される。(「見掛け上の」例外と言ったのは、束縛の最上位にあるびっくりマークは<emphasis>パターン</emphasis>の一部ではないと考えるのが正しいからである。そうではなく、これは<emphasis>束縛</emphasis>の構文の一部である。)
パターン束縛中に入れ子になったびっくりパターンは、他のあらゆる形式のパターンと同様に振る舞う。例を挙げる。
<programlisting>
let (!x,[y]) = e in b
</programlisting>
これは以下と同等である。
<programlisting>
let { t = case e of (x,[y]) -> x `seq` (x,y)
      x = fst t
      y = snd t }
in b
</programlisting>
この束縛は遅延するが、<literal>x</literal>か<literal>y</literal>のいずれかが<literal>b</literal>によって評価されると、パターン全体が照合され、それに伴って<literal>x</literal>の評価が強制される。
</para>
<para>
もちろん、びっくりパターンは<literal>case</literal>式でも使える。
<programlisting>
g5 x = let y = f x in body
g6 x = case f x of { y -&gt; body }
g7 x = case f x of { !y -&gt; body }
</programlisting>
関数<literal>g5</literal>と<literal>g6</literal>は全く同じである。一方、<literal>g7</literal>では<literal>(f x)</literal>が評価され、その結果が<literal>y</literal>に束縛された後、<literal>body</literal>が評価される。
</para>
</sect2>


<sect2 id="bang-patterns-sem">
<title>構文と意味論
</title>
<para>

パターンの構文に一つの新しい生成規則を加える。
<programlisting>
  pat ::= !pat
</programlisting>
これには一つ構文的な曖昧さの問題がある。以下の例を考えよ。
<programlisting>
f !x = 3
</programlisting>
これは中置関数「<literal>(!)</literal>」の定義なのだろうか。それともびっくりパターンを使った「<literal>f</literal>」の定義なのだろうか。GHCは、この曖昧さを、後者を優先することで解決する。びっくりパターンが有効な状態で<literal>(!)</literal>を定義したいなら、前置記法を使わなければならない。
<programlisting>
(!) f x = 3
</programlisting>
Haskellのパターン照合の意味論はHaskellレポートの<ulink url="http://www.haskell.org/onlinereport/exps.html#sect3.17.2">3.17.2節</ulink>(<ulink url="http://www.sampou.org/haskell/report-revised-j/exps.html#sect3.17.2">和訳</ulink>)に書かれている。この記述に、第十項目として以下のものを付け加える。
<itemizedlist><listitem><para>パターン<literal>!pat</literal>の値<literal>v</literal>への照合は、次のように振る舞う:
<itemizedlist><listitem><para>もし、<literal>v</literal>がボトムなら、照合は発散する。</para></listitem>
		<listitem><para>そうでなければ、<literal>pat</literal>は<literal>v</literal>と照合する。</para></listitem>
</itemizedlist>
</para></listitem></itemizedlist>
同様に、<ulink url="http://www.haskell.org/onlinereport/exps.html#sect3.17.3">3.17.3節</ulink>(<ulink url="http://www.sampou.org/haskell/report-revised-j/exps.html#sect3.17.3">和訳</ulink>)の図4に、新しい場合(t)を追加する。
<programlisting>
case v of { !pat -> e; _ -> e' }
   = v `seq` case v of { pat -> e; _ -> e' }
</programlisting>
</para><para>
残りはlet式である。これの変換はHaskellレポートの<ulink url="http://www.haskell.org/onlinereport/exps.html#sect3.12">3.12節</ulink>(<ulink url="http://www.sampou.org/haskell/report-revised-j/exps.html#sect3.12">和訳</ulink>)で与えられている。そこにある変換の箱において、まず以下の変換を施す。<literal>!qi = ei</literal>という形をした全てのパターン<literal>pi</literal>について、これを<literal>(xi,!qi) = ((),ei)</literal>に変換し、<literal>e0</literal>を<literal>(xi `seq` e0)</literal>で置き換える。次に、左辺のパターンがどれも先頭にびっくりマークを持たないようになったら、今ある箱の中にある規則を適用する。
</para>
<para>このlet規則の効果は、本体の評価が始まる前に、パターン<literal>qi</literal>の照合を完全に終わらせることである。以下のように、<literal>qi</literal>が変数である場合に備えて、びっくりマークは変換後の形においても保持される。
<programlisting>
  let !y = f x in b
</programlisting>

</para>
<para>
このようなlet束縛は再帰的になり得る。しかし、非再帰的であることの方がずっと多く、その場合以下の法則が成り立つ。
<literal>(let !p = rhs in body)</literal>は、<literal>(case rhs of !p -> body)</literal>と同等である。
</para>
<para>
びっくりマークが最も外側にあるようなパターンは、モジュールの最上位では許されない。
</para>
</sect2>
</sect1>

<!-- ==================== ASSERTIONS =================  -->

<sect1 id="assertions">
<title>アサーション
<indexterm><primary>Assertions</primary></indexterm>
</title>

<para>
標準Haskellのコードでアサーションを使いたいなら、次のような関数を定義することができるだろう。
</para>

<para>

<programlisting>
assert :: Bool -> a -> a
assert False x = error "assertion failed!"
assert _     x = x
</programlisting>

</para>

<para>
これは動作するが、発生するエラーメッセージは全く役に立たない。アサーションが失敗した。よろしい。しかしどこのどれが失敗したのだ？
</para>

<para>
一つの解決策は、<function>assert</function>を拡張して、エラーメッセージに含める文字列を受け取るようにし、例えばソース中で<function>assert</function>が使われている場所にソース位置を挿入する前処理器と組み合わせることである。
</para>

<para>
GHCはこれに対して救いの手を差しのべる。これら全てを代わりに行うことによって。ユーザのソースにおいて<function>assert</function>が使われているところ全てに対して、以下の処理を行う。
</para>

<para>

<programlisting>
kelvinToC :: Double -> Double
kelvinToC k = assert (k &gt;= 0.0) (k+273.15)
</programlisting>

</para>

<para>
上のようなものがあったとき、これを、アサーションが行われた地点を含むように書き換える。
</para>

<para>

<programlisting>
assert pred val ==> assertError "Main.hs|15" pred val
</programlisting>

</para>

<para>
このような書き換えが行われるのは、コンパイラが<function>Control.Exception.assert</function>の適用を見つけたときだけである。したがって、もし望むなら、自分で定義した<function>assert</function>を使うこともできる。そうでないなら、<function>assert</function>を使うときは<literal>Control.Exception</literal>をインポートせよ。
</para>

<para>
GHCは、<option>-O</option><indexterm><primary><option>-O</option></primary></indexterm>フラグで最適化が有効になっていると、アサーションを無視する。つまり、<literal>assert pred e</literal>という形の式は<literal>e</literal>に書き換えられる。<option>-fignore-asserts</option>オプション<indexterm><primary><option>-fignore-asserts</option></primary></indexterm>を使ってアサーションを無効にすることもできる。</para>

<para>
アサーションの失敗は補足することができる。詳細は<literal>Control.Exception</literal>の説明書きを見よ。
</para>

</sect1>


<!-- =============================== PRAGMAS ===========================  -->

  <sect1 id="pragmas">
    <title>プラグマ</title>

    <indexterm><primary>pragma</primary></indexterm>

    <para>GHCはいくつかのプラグマ(ソースコード中に置かれるコンパイラへの指示)に対応している。プラグマは通常プログラムの意味には影響を与えないが、生成されるコードの効率性には影響し得る。</para>

    <para>全てのプラグマは<literal>{-# <replaceable>word</replaceable> ... #-}</literal>という形を取る。ここで、<replaceable>word</replaceable>はプラグマの種類を表す。必要なら、この後に続けて、その種類のプラグマに特有の情報を書く。<replaceable>word</replaceable>では大文字小文字の区別はなされない。GHCが理解する種々のプラグマは以下の節で解説されている。認識できない<replaceable>word</replaceable>を持ったプラグマは無視される。プラグマ中ではレイアウト規則が適用されるので、閉じ括弧<literal>#-}</literal>は開き括弧<literal>{-#</literal>よりも右のカラムで始まっていなければならない。</para>

    <para>ある種のプラグマは<emphasis>ファイルヘッダプラグマ</emphasis>である。ファイルヘッダプラグマは、ファイル中で<literal>module</literal>キーワードよりも前になければならない。ファイルヘッダプラグマはいくつあっても良いし、コメントの前にあっても後にあっても良い。</para>

    <sect2 id="language-pragma">
      <title>LANGUAGEプラグマ</title>

      <indexterm><primary>LANGUAGE</primary><secondary>pragma</secondary></indexterm>
      <indexterm><primary>pragma</primary><secondary>LANGUAGE</secondary></indexterm>

      <para>このプラグマは、言語拡張を、可搬性のある方法で有効にできるようにするものである。意図としては、全てのコンパイラが同じ構文の<literal>LANGUAGE</literal>に対応する、というものである。もちろん、全ての拡張が全てのコンパイラで使える訳ではないが。可能なら、<literal>OPTIONS_GHC</literal>プラグマの代わりに<literal>LANGUAGE</literal>を使うべきである。</para>

      <para>例えば、FFIと、CPPを使った前処理を有効にするには、次のようにする。</para>

<programlisting>{-# LANGUAGE ForeignFunctionInterface, CPP #-}</programlisting>

      <para><literal>LANGUAGE</literal>はファイルヘッダプラグマ(<xref linkend="pragmas"/>を見よ)である。</para>

      <para>全ての言語拡張は、前に「<literal>-X</literal>」を付けることでコマンド行フラグになる。例えば<option>-XForeignFunctionInterface</option>のように。(同様に、全ての「<literal>-X</literal>」フラグは<literal>LANGUAGE</literal>プラグマとして書ける)
      </para>
      <para>対応している言語拡張の一覧は、<literal>ghc --supported-languages</literal>を実行することで得られる。(<xref linkend="modes"/>を見よ)</para>

      <para><ulink url="../libraries/Cabal/Language-Haskell-Extension.html"><literal>Language.Haskell.Extension</literal></ulink>(訳注: 未訳。<ulink url="http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal/Language-Haskell-Extension.html">web上の最新版</ulink>)で定義されている型<literal>Extension</literal>の構築子ならどれを使っても良い。指定された拡張がGHCでサポートされていないなら、エラーが報告される。</para>
    </sect2>

    <sect2 id="options-pragma">
      <title>OPTIONS_GHCプラグマ</title>
      <indexterm><primary>OPTIONS_GHC</primary>
      </indexterm>
      <indexterm><primary>pragma</primary><secondary>OPTIONS_GHC</secondary>
      </indexterm>

      <para><literal>OPTIONS_GHC</literal>プラグマは、そのソースファイルをコンパイルするときにコンパイラに与える追加のオプションを指定するのに使う。詳細は<xref linkend="source-file-options"/>を見よ。</para>

      <para>GHCの古い版では<literal>OPTIONS_GHC</literal>ではなく<literal>OPITONS</literal>を受け付けていたが、これはもはや非推奨である。</para>
    </sect2>

      <para><literal>OPTIONS_GHC</literal>はファイルヘッダプラグマ(<xref linkend="pragmas"/>を見よ)である。</para>

    <sect2 id="include-pragma">
      <title>INCLUDEプラグマ</title>

      <para><literal>INCLUDE</literal>プラグマは、(Cを介してコンパイルしているときに)モジュールをコンパイルしてできるCソースファイルが<literal>#include</literal>すべきCのヘッダを指定するためのものである。例を示す。</para>

<programlisting>
{-# INCLUDE "foo.h" #-}
{-# INCLUDE &lt;stdio.h&gt; #-}</programlisting>

      <para><literal>INCLUDE</literal>はファイルヘッダプラグマ(<xref linkend="pragmas"/>を見よ)である。</para>

      <para><literal>INCLUDE</literal>プラグマは、<option>-#include</option>オプション(<xref linkend="options-C-compiler" />)の、より良い代替手段である。<literal>INCLUDE</literal>プラグマは他のコンパイラでも解釈されるからである。<literal>foreign import</literal>宣言それぞれにインクルードファイルを書く方法もあるが、この方法はGHCでは推奨されない。</para>
    </sect2>

    <sect2 id="warning-deprecated-pragma">
      <title>WARNINGおよびDEPRECATEDプラグマ</title>
      <indexterm><primary>WARNING</primary></indexterm>
      <indexterm><primary>DEPRECATED</primary></indexterm>

      <para>WARNINGプラグマを使うと、特定の関数やクラスや型に任意の警告を付属させることができる。DEPRECATEDプラグマを使うと、特定の関数やクラスや型が、非推奨・廃止予定であると指定できる。これらのプラグマを使うには二つの方法がある。

      <itemizedlist>
	<listitem>
	  <para>モジュール全体を相手にすることができる。</para>
<programlisting>
   module Wibble {-# DEPRECATED "Use Wobble instead" #-} where
     ...
</programlisting>
      <para>あるいは、</para>
<programlisting>
   module Wibble {-# WARNING "This is an unstable interface." #-} where
     ...
</programlisting>
          <para><literal>Wibble</literal>をインポートしているモジュールをコンパイルするときはいつでも、GHCは指定されたメッセージを印字する。</para>
	</listitem>

	<listitem>
	  <para>次のような最上位の宣言を使うことで、関数、クラス、型、データ構築子に警告を付属させることができる。</para>
<programlisting>
   {-# DEPRECATED f, C, T "Don't use these" #-}
   {-# WARNING unsafePerformIO "This is unsafe; I hope you know what you're doing" #-}
</programlisting>
	  <para>指定された実体をインポートして使用しているモジュールをコンパイルするとき、GHCは指定されたメッセージを印字する。</para>
          <para>付属させることができるのは、コンパイル中のモジュールの最上位で宣言されている実体だけである。また、実体を宣言する際には未修飾名を使わなければならない。<literal>T</literal>のように大文字から始まる名前は、型構築子<literal>T</literal>かデータ構築子<literal>T</literal>かの<emphasis>いずれか</emphasis>であり、両方がスコープにあるなら両方である。両方がスコープにあるとき、片方だけを指定することは今のところできない。(<xref linkend="infix-tycons"/>と比較せよ)</para>
	</listitem>
      </itemizedlist>
警告と非推奨報告は次のものに対しては為されない。(a) 定義されたモジュール中での使用、および (b) エクスポートリスト中での使用。後者のおかげで、一つのモジュールが複数のモジュールがエクスポートしているものを集めて再エクスポートするという構造のライブラリで、余計な文句を言うことがない。</para>
      <para>フラグ<option>-fno-warn-warnings-deprecations</option>を使ってこの警告を抑制することができる。</para>
    </sect2>

    <sect2 id="inline-noinline-pragma">
      <title>INLINEおよびNOINLINEプラグマ</title>

      <para>これらのプラグマは関数定義のインライン化を制御する。</para>

      <sect3 id="inline-pragma">
	<title>INLINEプラグマ</title>
	<indexterm><primary>INLINE</primary></indexterm>

	<para>GHCは、(いつもと同様、<option>-O</option>が指定されているときだけ)「十分に小さい」関数・値をインライン化(または「展開(unfold)」)して、呼び出しのオーバーヘッドを回避し、場合によってはより素晴らしい最適化を可能にしようとする。通常、GHCがある関数をインライン化するのが「高くつきすぎる」と判断したときは、インライン化は行わないし、他のモジュールで使うために展開候補をエクスポートすることもない。</para>

        <para>ここで使える強力な武器が<literal>INLINE</literal><indexterm><primary>INLINE pragma</primary></indexterm>プラグマであり、次のように使う。</para>

<programlisting>
key_function :: Int -> String -> (Bool, Double)
{-# INLINE key_function #-}
</programlisting>

        <para><literal>INLINE</literal>プラグマの主要な効果は、ある関数の「コスト」がとても低いと宣言することである。これによって、通常の展開機構がインライン化に非常に積極的になる。一方、関数「<literal>f</literal>」に関する<literal>INLINE</literal>プラグマには、他の効果がいくつかある。
<itemizedlist>
<listitem><para>
関数が<literal>f</literal>にインライン化されることがない。こうなっていなければ、GHCは<literal>f</literal>の右辺に大きな関数をインライン化して、<literal>f</literal>を大きくし、その後で盲目的に<literal>f</literal>をインライン化するかもしれない。
</para></listitem>
<listitem><para>
<literal>f</literal>の本体において、float-in、float-out、共通部分式の変換が適用されない。
</para></listitem>
<listitem><para>
INLINE関数は正格性解析によってworker/wrapperされることがない。そうでなく、全部まとめてインライン化される。
</para></listitem>
</itemizedlist>
これらの効果はすべて、期待したものだけがインライン化され、インライン化が多すぎたり少なすぎたりしないようにすることが目的である。
</para>
<para>
GHCはインライン化が永遠に続くことがないことを保証する。相互再帰的な一団はすべて、一個以上の決してインライン化されない<emphasis>ループ破り</emphasis>によって切り離される。(<ulink url="http://research.microsoft.com/%7Esimonpj/Papers/inlining/index.htm"> Secrets of the GHC inliner, JFP 12(4) July 2002</ulink>を見よ)。GHCはループ破りとしてINLINEプラグマのついた関数を選ばないことを試みるが、選択肢がないときはINLINE関数でも選択され得、この場合INLINEプラグマは無視される。例えば、自己再帰的な関数では、ループ破りはその関数自体でしかありえないので、INLINEプラグマは常に無視される。</para>

        <para>構文的には、ある関数についての<literal>INLINE</literal>プラグマは、その関数の型シグネチャが置けるところならどこに置いても良い。</para>

        <para><literal>INLINE</literal>プラグマはモナドの<literal>then</literal>/<literal>return</literal>(または<literal>bind</literal>/<literal>unit</literal>)関数に特に有用である。例えば、GHCの<literal>UniqueSupply</literal>モナドのコードには次のものが含まれている。</para>

<programlisting>
#ifdef __GLASGOW_HASKELL__
{-# INLINE thenUs #-}
{-# INLINE returnUs #-}
#endif
</programlisting>

	<para><literal>NOINLINE</literal>プラグマ(<xref linkend="noinline-pragma"/>)も見よ。</para>

	<para>注意: HBCコンパイラは<literal>INLINE</literal>プラグマと相性が悪いので、コードをHBC互換にしたいなら<literal>#ifdef __GLASGOW_HASKELL__</literal>...<literal>#endif</literal>というCプリプロセッサ指令でプラグマを囲む必要があるだろう。</para>

      </sect3>

      <sect3 id="noinline-pragma">
	<title>NOINLINEプラグマ</title>
	
	<indexterm><primary>NOINLINE</primary></indexterm>
	<indexterm><primary>NOTINLINE</primary></indexterm>

        <para><literal>NOINLINE</literal>プラグマはまさに想像される通りのことを行う。すなわち、指定された関数がコンパイラによってインライン化されるのを防ぐ。コードの大きさについて非常に用心深くある場合をのぞけば、これが必要になることはないはずである。</para>

        <para><literal>NOTINLINE</literal>は<literal>NOINLINE</literal>の同義名である。(<literal>NOINLINE</literal>は、Haskell 98によって、インライン化を無効にするための標準的な方法として定められているので、コードの可搬性を気にするならこちらを使うべきである)</para>
      </sect3>

      <sect3 id="phase-control">
	<title>段階管理</title>

        <para>GHCのパイプライン中のどの段階でINLINEプラグマが有効になるかを制御したいことがあるだろう。インライン化が行われるのは、<emphasis>単純化器</emphasis>の実行過程だけである。単純化器は、毎回異なる<emphasis>段階番号</emphasis>で実行される。段階番号は零に向かって減少する。<option>-dverbose-core2core</option>を使えば、単純化器が連続して実行されるに際しての段階番号を見ることができる。次のように、INLINEプラグマに段階番号を指定することができる。
	<itemizedlist>
	  <listitem>
	    <para>"<literal>INLINE[k] f</literal>" : 段階<literal>k</literal>までは<literal>f</literal>をインライン化しないが、段階<literal>k</literal>以降は非常に積極的にインライン化する。
            </para></listitem>
	  <listitem>
	    <para>"<literal>INLINE[~k] f</literal>" : 段階<literal>k</literal>までは<literal>f</literal>を非常に積極的にインライン化するが、段階<literal>k</literal>以降はインライン化しない。
            </para></listitem>
	  <listitem>
	    <para>"<literal>NOINLINE[k] f</literal>" : 段階<literal>k</literal>までは<literal>f</literal>をインライン化しないが、段階<literal>k</literal>以降は(プラグマがないかのように)インライン化しようとする。
            </para></listitem>
	    <listitem>
	    <para>"<literal>NOINLINE[~k] f</literal>" : 段階<literal>k</literal>までは<literal>f</literal>をインライン化しようとするが、段階<literal>k</literal>以降はインライン化しない。
            </para></listitem>
	</itemizedlist>
以下に、上の情報をまとめる。
<programlisting>
                           --  段階2より前         段階2以降
  {-# INLINE   [2]  f #-}  --    しない              する
  {-# INLINE   [~2] f #-}  --     する              しない
  {-# NOINLINE [2]  f #-}  --    しない           場合による
  {-# NOINLINE [~2] f #-}  --  場合による           しない

  {-# INLINE   f #-}       --     する               する
  {-# NOINLINE f #-}       --    しない             しない
</programlisting>
「場合による」というのは、インライン化についての通常のヒューリスティクス(関数本体が小さいなら、とか、興味深い見た目の引数に適用されているなら、など)が適用されるということである。この規則は次のように捉えることもできる。
<itemizedlist>
<listitem><para>INLINEとNOINLINEの両方について、段階番号はインライン化が少しでも許されるかどうかを言っている。</para></listitem>
<listitem><para>これに加えて、INLINEプラグマには、関数本体を小さく見せる効果がある。したがって、インライン化が許されているときには、インライン化が発生する可能性が極めて高い。
</para></listitem>
</itemizedlist>
</para>
<para>これと同じ段階番号制御はRULES(<xref linkend="rewrite-rules"/>)についても使える。</para>
      </sect3>
    </sect2>

    <sect2 id="line-pragma">
      <title>LINEプラグマ</title>

      <indexterm><primary>LINE</primary><secondary>pragma</secondary></indexterm>
      <indexterm><primary>pragma</primary><secondary>LINE</secondary></indexterm>
      <para>このプラグマはCの<literal>#line</literal>プラグマに似ていて、自動生成されたHaskellコードで使うことを主に意図したものである。これを使うと、元々のコードの行番号とファイル名を指定することができる。例えば、ファイルが、<filename>Foo.vhs</filename>というファイルから生成され、その行が元のファイルの42行目に当たるなら、以下のように書けば良い。</para>

<programlisting>{-# LINE 42 "Foo.vhs" #-}</programlisting>

      <para>エラーメッセージが報告されるとき、<literal>LINE</literal>プラグマで指定された行・ファイルを参照するようになる。</para>
    </sect2>

    <sect2 id="rules">
      <title>RULESプラグマ</title>

      <para>RULESプラグマを使うと書き換え規則を指定することができる。これは<xref linkend="rewrite-rules"/>で解説されている。</para>
    </sect2>

    <sect2 id="specialize-pragma">
      <title>SPECIALIZEプラグマ</title>

      <indexterm><primary>SPECIALIZE pragma</primary></indexterm>
      <indexterm><primary>pragma, SPECIALIZE</primary></indexterm>
      <indexterm><primary>overloading, death to</primary></indexterm>

      <para>(英式にSPECIALISEでも良い) 鍵となる多重定義関数について、特定の型に特殊化された版を作ることができる。(注意: コードサイズは増大する)。次のような多重定義関数があったとしよう。</para>

<programlisting>
  hammeredLookup :: Ord key => [(key, value)] -> key -> value
</programlisting>

      <para>この関数が、keyの型を<literal>Widget</literal>として特に良く使われるなら、次のようにして特殊化することができる。</para>

<programlisting>
  {-# SPECIALIZE hammeredLookup :: [(Widget, value)] -> Widget -> value #-}
</programlisting>

      <para>関数についての<literal>SPECIALIZE</literal>プラグマは、その関数の型シグネチャが書けるところならどこにでも書ける。</para>

      <para><literal>SPECIALIZE</literal>の効果は、その関数の特殊化版を生成することと、およびその関数の未特殊化版の呼び出しを特殊化版の呼び出しに書き換える規則(<xref linkend="rewrite-rules"/>を見よ)を生成することである。</para>

      <para>SPECIALIZEプラグマ中の型は元の関数の型より多相性が低いものならなんでも良い。ちゃんとした言い方では次のようになる。元の関数が<literal>f</literal>だとする。
<programlisting>
  {-# SPECIALIZE f :: &lt;type&gt; #-}
</programlisting>
      このプラグマが正当なのは、以下の定義が正当な時だけである。
<programlisting>
  f_spec :: &lt;type&gt;
  f_spec = f
</programlisting>
      いくつか例を示す。(元の関数については型シグネチャだけを示し、コードは省略した)
<programlisting>
  f :: Eq a => a -> b -> b
  {-# SPECIALISE f :: Int -> b -> b #-}

  g :: (Eq a, Ix b) => a -> b -> b
  {-# SPECIALISE g :: (Eq a) => a -> Int -> Int #-}

  h :: Eq a => a -> a -> a
  {-# SPECIALISE h :: (Eq a) => [a] -> [a] -> [a] #-}
</programlisting>
最後の例では、生成されたRULSの左辺がかなり複雑なものになる(試してみよ)ので、あまりうまく発動しないかもしれない。この手の特殊化を使うことがあったら、どの程度うまくいったか知らせてほしい。
</para>

<para><literal>SPECIALIZE</literal>の後には<literal>INLINE</literal>か<literal>NOINLINE</literal>プラグマを続けることができる。さらに、<xref linkend="inline-noinline-pragma"/>にあるように段階を指定することもできる。このような<literal>INLINE</literal>プラグマはその関数の特殊化版(のみ)に影響し、その関数が再帰的であっても適用される。動機となる例はこれである。
<programlisting>
-- type-indexedな表現を持つ配列のGADT
data Arr e where
  ArrInt :: !Int -> ByteArray# -> Arr Int
  ArrPair :: !Int -> Arr e1 -> Arr e2 -> Arr (e1, e2)

(!:) :: Arr e -> Int -> e
{-# SPECIALISE INLINE (!:) :: Arr Int -> Int -> Int #-}
{-# SPECIALISE INLINE (!:) :: Arr (a, b) -> Int -> (a, b) #-}
(ArrInt _ ba)     !: (I# i) = I# (indexIntArray# ba i)
(ArrPair _ a1 a2) !: i      = (a1 !: i, a2 !: i)
</programlisting>
ここでは、<literal>(!:)</literal>は<literal>Arr e</literal>型の配列の添字演算を行う再帰関数である。<literal>(Int,Int)</literal>での<literal>(!:)</literal>の呼び出しを考えてみよう。二番目の特殊化が発動し、その特殊化された関数がインライン化される。それには<literal>(!:)</literal>の呼び出しが二つあり、どちらも<literal>Int</literal>型についてのものである。これらの呼び出しは両方とも最初の特殊化を発動させ、その本体も再びインライン化される。結果として、添字演算関数についての型によるアンロールができたことになる。</para>
<para>警告: <literal>SPECIALISE INLINE</literal>を非多相再帰な関数に対して使うと、GHCは発散する。</para>

      <para>参考: 古いGHCでは、特定の型についての特殊化を自分で指定することができた。

<programlisting>
{-# SPECIALIZE hammeredLookup :: [(Int, value)] -> Int -> value = intLookup #-}
</programlisting>

      より一般的な<literal>RULES</literal>プラグマ(<xref linkend="rule-spec"/>を見よ)ができたので、この機能は削除された。</para>

    </sect2>

<sect2 id="specialize-instance-pragma">
<title>SPECIALIZE instanceプラグマ
</title>

<para>
<indexterm><primary>SPECIALIZE pragma</primary></indexterm>
<indexterm><primary>overloading, death to</primary></indexterm>
考え方は同じで、対象がインスタンス宣言になっただけである。例を示す。

<programlisting>
instance (Eq a) => Eq (Foo a) where { 
   {-# SPECIALIZE instance Eq (Foo [(Int, Bar)]) #-}
   ... 通常と同じ ...
 }
</programlisting>
このプラグマはインスタンス宣言の<literal>where</literal>部に現れなければならない。
</para>
<para>
ところで、これはHBCと互換性がある。あるいはプラグマの配置場所については非互換かもしれないが。
</para>

</sect2>

    <sect2 id="unpack-pragma">
      <title>UNPACKプラグマ</title>

      <indexterm><primary>UNPACK</primary></indexterm>
      
      <para><literal>UNPACK</literal>は、コンパイラに対し、構築子フィールドの内容を構築子に直に収めることで、一段階の間接参照を排除することを指示するものである。例を示す。</para>

<programlisting>
data T = T {-# UNPACK #-} !Float
           {-# UNPACK #-} !Float
</programlisting>

      <para>これにより、二つの非ボックス化Floatを保持する構築子<literal>T</literal>ができる。これは常に最適化になっているとは限らない。例えば、構築子<function>T</function>の内容を調べて、そのfloatを非正格な関数に渡す場合、それらを再びボックス化しなければならない。(これはコンパイラによって自動的に行われる)</para>

      <para>構築子のアンパックは専ら<option>-O</option>と組み合わせて使われるべきである。再ボックス化をなるべく排除できるように展開候補をコンパイラに露出するためである。次の例を考える。</para>

<programlisting>
f :: T -&#62; Float
f (T f1 f2) = f1 + f2
</programlisting>

      <para>コンパイラは、floatについての<function>+</function>をインライン化することで、<function>f1</function>と<function>f2</function>を再ボックス化することを避けるが、これは<option>-O</option>が有効なときだけである。</para>

      <para>単一構築子のデータはどんなものでもアンパックし得る。</para>

<programlisting>
data T = T {-# UNPACK #-} !(Int,Int)
</programlisting>

      <para>この場合、構築子<function>T</function>は、対を平坦化して、二つの<literal>Int</literal>を直接保持することになる。複数水準のアンパックもサポートされている。

<programlisting>
data T = T {-# UNPACK #-} !S
data S = S {-# UNPACK #-} !Int {-# UNPACK #-} !Int
</programlisting>

      この場合、二つの非ボックス化<literal>Int#</literal>が構築子<function>T</function>に直接置かれる。アンパックはnewtypeを透過して起こる。</para>

      <para>フィールドがアンパックできないとき、警告は出力されないので、生成されたコードを<option>-ddump-simpl</option>で検査するのが良いかもしれない。</para>

      <para><option>-funbox-strict-fields</option>フラグも見よ。これは、簡単に言うと、あらゆる正格な構築子フィールドに<literal>{-#&nbsp;UNPACK&nbsp;#-}</literal>を加えるのと同じ効果がある。</para>
    </sect2>

    <sect2 id="source-pragma">
      <title>SOURCEプラグマ</title>

      <indexterm><primary>SOURCE</primary></indexterm>
     <para><literal>{-# SOURCE #-}</literal>は専ら<literal>import</literal>宣言の中で使われ、モジュールのループを断ち切る役割を果たす。詳しい説明は<xref linkend="mutual-recursion"/>にある。
     </para>
</sect2>

</sect1>

<!--  ======================= REWRITE RULES ======================== -->

<sect1 id="rewrite-rules">
<title>書き換え規則

<indexterm><primary>RULES pragma</primary></indexterm>
<indexterm><primary>pragma, RULES</primary></indexterm>
<indexterm><primary>rewrite rules</primary></indexterm></title>

<para>
プログラマは、ソースプログラムの一部として(プラグマで)書き換え規則を指定することができる。
以下に例を示す。

<programlisting>
  {-# RULES
  "map/map"    forall f g xs.  map f (map g xs) = map (f.g) xs
    #-}
</programlisting>
</para>
<para>
どの規則が発火したかを見るには<option>-ddump-simpl-stats</option>というデバッグフラグを使えばよい。もっと情報が必要な場合は、<option>-ddump-rule-firings</option>によって、個々の規則発火を詳細に見ることができる。
</para>

<sect2>
<title>構文</title>

<para>
構文の観点からは、以下がいえる。

<itemizedlist>

<listitem>
<para>
一つの<literal>RULES</literal>プラグマには零個以上の規則を書ける。規則の間はセミコロンで区切る。(このセミコロンはレイアウト規則によって生成されたものでもよい)
</para>
</listitem>

<listitem>
<para>
プラグマ内ではレイアウト規則が適用される。現在、新しいインデントの水準が設定されることはない。そのため、一つのRULESプラグマに複数の規則を書いて、レイアウトを使ってそれを区切りたい場合、外側の定義と同じ位置で開始するように配置しなければならない。
<programlisting>
  {-# RULES
  "map/map"    forall f g xs.  map f (map g xs) = map (f.g) xs
  "map/append" forall f xs ys. map f (xs ++ ys) = map f xs ++ map f ys
    #-}
</programlisting>
さらに、閉じ括弧<literal>#-}</literal>は開き括弧<literal>{-#</literal>よりも右で始まっているようにするべきである。
</para>
</listitem>
 
<listitem>
<para>
全ての規則には名前があり、二重引用符で囲って示される。名前自体には全く意味はない。規則が何回発動したかを報告する際に用いられるだけである。
</para>
</listitem>

<listitem>
<para>
規則名の直後に段階番号(<xref linkend="phase-control"/>を見よ)を書くこともできる。次のように。
<programlisting>
  {-# RULES
        "map/map" [2]  forall f g xs. map f (map g xs) = map (f.g) xs
    #-}
</programlisting>
ここでの「[2]」は、この規則が段階2以降(段階2を含む)で有効になることを意味している。逆の記法である「[~2]」を使うこともでき、規則が段階2まで有効(段階2自体は含まない)という意味である。
</para>
</listitem>

<listitem>
<para>
規則中で言及される変数は、スコープにある(<function>map</function>のように)か、<literal>forall</literal>で束縛される(<function>f</function>、<function>g</function>、<function>xs</function>のように)かのどちらかでなければならない。<literal>forall</literal>で束縛された変数は<emphasis>パターン</emphasis>変数と呼ばれる。パターン変数は、型の<literal>forall</literal>の場合と同じく、空白で区切る。
</para>
</listitem>
<listitem>

<para>
パターン変数には型シグネチャをつけても良い。パターン変数の型が多相的なら、その変数には型シグネチャが<emphasis>必須</emphasis>である。例えば、以下は<literal>foldr/build</literal>規則である。

<programlisting>
"fold/build"  forall k z (g::forall b. (a->b->b) -> b -> b) .
              foldr k z (build g) = g k z
</programlisting>

<function>g</function>の型は多相的なので、型シグネチャを与える必要がある。

</para>
</listitem>
<listitem>

<para>
規則の左辺は、最上位の変数を任意の式に適用したものでなければならない。例えば、以下のものは正しく<emphasis>ない</emphasis>。

<programlisting>
"wrong1"   forall e1 e2.  case True of { True -> e1; False -> e2 } = e1
"wrong2"   forall f.      f True = True
</programlisting>

<literal>"wrong1"</literal>では、左辺が適用でない。<literal>"wrong2"</literal>では、左辺の先頭がパターン変数である。
</para>
</listitem>
<listitem>

<para>
規則は、それが言及する変数(のどれか)と同じモジュールにある必要はない。もちろん、それらはスコープになければならないが。
</para>
</listitem>
<listitem>

<para>
規則は全て暗黙にモジュールからエクスポートされ、したがって規則を定義したモジュールを直接または間接にインポートしたモジュールの全てで有効である。(つまり、AがBをインポートしていて、BがCをインポートしている場合、AをコンパイルするときにCの規則が有効である)この状況はインスタンス宣言の場合と非常に良く似ている。
</para>
</listitem>

<listitem>

<para>
RULEの内部において、「<literal>forall</literal>」は他のフラグ設定の如何にかかわらずキーワードとして扱われる。さらに、RULE内部では、言語拡張<option>-XScopedTypeVariables</option>が自動的に有効になる。<xref linkend="scoped-type-variables"/>を見よ。
</para>
</listitem>
<listitem>
 
<para>
他のプラグマと同様、RULEプラグマは常にスコープの誤りを検査され、型検査される。型検査というのは、規則の左辺と右辺が型検査され、さらに同じ型でなければならないということである。しかし、規則が<emphasis>有効になる</emphasis>のは<option>-fenable-rewrite-rules</option>フラグが有効な時だけである(<xref linkend="rule-semantics"/>を見よ)。
</para>
</listitem>

</itemizedlist>

</para>

</sect2>

<sect2 id="rule-semantics">
<title>意味論</title>

<para>
意味論の観点からは以下のことが言える。

<itemizedlist>
<listitem>

<para>
規則は<option>-fenable-rewrite-rules</option>フラグによって有効になる(つまり、最適化に使われる)。このフラグは<option>-O</option>によって有効になり、(いつも通り)<option>-fno-enable-rewrite-rules</option>で解除できる。(注意: 一方、<option>-O</option>なしで<option>-fenable-rewrite-rules</option>を有効にしても期待通りにはならないかもしれない。なぜなら<option>-O</option>なしではGHCはインタフェースファイル中の全ての最適化情報を無視するからである。<option>-fignore-interface-pragmas</option>、<xref linkend="options-f"/>を見よ。)<option>-fenable-rewrite-rules</option>は<emphasis>最適化</emphasis>フラグであって、パースや型検査には効果を及ぼさないことに注意。
</para>
</listitem>

<listitem>
<para>
規則は左から右への書き換えの規則だとみなされる。規則の左辺の置換例であるような式が見付かると、その式は右辺(に適切な置換を施したもの)に置き換えられる。「置換例」というのは、左辺に、パターン変数について置換を施すことで、その式と等しくすることができる、という意味である。

</para>
</listitem>
<listitem>

<para>
規則の左辺と右辺が同じ意味かどうかについては、GHCは一切検証を試みない。これは一般的には決定不能であるし、興味深い場合について実行不可能である。これについて、責任は完全にプログラマにある。

</para>
</listitem>
<listitem>

<para>
GHCは規則が合流性や停止性を持つことを確かめようとはしない。例。

<programlisting>
  "loop"        forall x y.  f x y = f y x
</programlisting>

この規則はコンパイラを無限ループさせる。

</para>
</listitem>
<listitem>

<para>
一つの呼び出しに複数の規則が適合する場合は、恣意的に一つが選ばれる。

</para>
</listitem>
<listitem>
<para>
現在、GHCでは、規則の左辺を式と照合するに当たって、非常に単純で構文的な照合アルゴリズムが使われている。左辺と式を、α変換を法として構文的に等しくするような置換を探すのである。パターン(規則)は必要ならη展開されるが、式はされない。(式をη展開すると遅延性にかかわるバグにつながる)。また、β変換(高階照合と呼ばれる)は行わない。
</para>

<para>
照合はGHCの中間言語で行われる。この言語には型抽象と型適用があるので、規則は型が合うときのみ適合する。下の<xref linkend="rule-spec"/>を見よ。
</para>
</listitem>
<listitem>

<para>
GHCは、最適化過程において、常に規則を適用しようとする。例として以下のものを考えてみよう。

<programlisting>
  let s = map f
      t = map g
  in
  s (t xs)
</programlisting>

式<literal>s (t xs)</literal>は規則<literal>"map/map"</literal>に適合しないが、GHCは<varname>s</varname>と<varname>t</varname>を置換するので、結果として適合する式ができる。<varname>s</varname>や<varname>t</varname>が(a)二度以上使われていて、かつ(b)大きかったり簡約項だったりする、場合は、これらは置換されないので、規則が発動することもない。

</para>
</listitem>
<listitem>

<para>
通常のインライン化は規則による書き換えと同時に起きる。これによって予期せぬ結果につながることがある。次の(人為的な)例を考えよ。
<programlisting>
f x = x
{-# RULES "f" f True = False #-}

g y = f y

h z = g True
</programlisting>
<literal>f</literal>の右辺は小さいので、<literal>g</literal>へとインライン化され、次のような結果になる。
<programlisting>
g y = y
</programlisting>

次に<literal>g</literal>が<literal>h</literal>へとインライン化されるが、<literal>f</literal>のRULEが発火する機会はない。GHCが逆にまず<literal>g</literal>を<literal>h</literal>へとインライン化していたら、<literal>f</literal>のRULEが発火する機会はより大きかっただろう。
</para>
<para>
振る舞いを予測可能にするには、<literal>f</literal>にNOINLINEプラグマを使って、RULEに発火の機会があるうちにインライン化されることがないようにすれば良い。
</para>
</listitem>

</itemizedlist>

</para>

</sect2>

<sect2>
<title>リストの融合変換</title>

<para>
RULES機構は、良く使われるリスト関数についての融合変換(伐採)を実装するのに使われている。「優良消費者」が「優良生産者」の構築した中間リストを消費する場合、このリストは完全に排除されるはずである。
</para>

<para>
以下のものが優良生産者である。

<itemizedlist>
<listitem>

<para>
リスト内包表記
</para>
</listitem>
<listitem>

<para>
<literal>Int</literal>および<literal>Char</literal>についての列挙(例えば<literal>['a'..'z']</literal>)。
</para>
</listitem>
<listitem>

<para>
明示的なリスト(例: <literal>[True, False]</literal>)
</para>
</listitem>
<listitem>

<para>
cons構築子(例: <literal>3:4:[]</literal>)
</para>
</listitem>
<listitem>

<para>
 <function>++</function>
</para>
</listitem>

<listitem>
<para>
 <function>map</function>
</para>
</listitem>

<listitem>
<para>
<function>take</function>, <function>filter</function>
</para>
</listitem>
<listitem>

<para>
 <function>iterate</function>, <function>repeat</function>
</para>
</listitem>
<listitem>

<para>
 <function>zip</function>, <function>zipWith</function>
</para>
</listitem>

</itemizedlist>

</para>

<para>
以下は優良消費者である。

<itemizedlist>
<listitem>

<para>
リスト内包表記
</para>
</listitem>
<listitem>

<para>
 <function>array</function> (第二引数について)
</para>
</listitem>
<listitem>

<para>
 <function>++</function> (第一引数について)
</para>
</listitem>

<listitem>
<para>
 <function>foldr</function>
</para>
</listitem>

<listitem>
<para>
 <function>map</function>
</para>
</listitem>
<listitem>

<para>
<function>take</function>, <function>filter</function>
</para>
</listitem>
<listitem>

<para>
 <function>concat</function>
</para>
</listitem>
<listitem>

<para>
 <function>unzip</function>, <function>unzip2</function>, <function>unzip3</function>, <function>unzip4</function>
</para>
</listitem>
<listitem>

<para>
 <function>zip</function>, <function>zipWith</function> (ただし引数一つについてのみ。両方が優良生産者の場合、<function>zip</function>は片方のみと融合する)
</para>
</listitem>
<listitem>

<para>
 <function>partition</function>
</para>
</listitem>
<listitem>

<para>
 <function>head</function>
</para>
</listitem>
<listitem>

<para>
 <function>and</function>, <function>or</function>, <function>any</function>, <function>all</function>
</para>
</listitem>
<listitem>

<para>
 <function>sequence&lowbar;</function>
</para>
</listitem>
<listitem>

<para>
 <function>msum</function>
</para>
</listitem>
<listitem>

<para>
 <function>sortBy</function>
</para>
</listitem>

</itemizedlist>

</para>

 <para>
 よって、例えば以下のものは中間リストを生成しないはずである。

<programlisting>
array (1,10) [(i,i*i) | i &#60;- map (+ 1) [0..9]]
</programlisting>

</para>

<para>
この一覧を拡張することはいつでもできる。良く使うPrelude関数でここに含まれていないものがあったら教えてほしい。
</para>

<para>
自分で優良生産者や優良消費者を書きたいときは、上の関数のPreludeでの定義を見てどうするか知ると良い。
</para>

</sect2>

<sect2 id="rule-spec">
<title>特殊化
</title>

<para>
書き換え規則を使って、GHCの昔の版で使えた、ある機能と同等のことを行える。例として、以下のものを考えよ。

<programlisting>
genericLookup :: Ord a => Table a b   -> a   -> b
intLookup     ::          Table Int b -> Int -> b
</programlisting>

ここで、<function>intLookup</function>は、キーが<literal>Int</literal>の時に非常に高速に動作する<function>genericLookup</function>の実装である。<function>genericLookup</function>が型<literal>Table Int b -&gt; Int -&gt; b</literal>で呼ばれたときは代わりに<function>intLookup</function>を使うようにさせたいと思うかもしれない。次のように書くことが可能だった。

<programlisting>
{-# SPECIALIZE genericLookup :: Table Int b -> Int -> b = intLookup #-}
</programlisting>

この機能はもはやGHCにはないが、書き換え規則を使って同等のことができる。

<programlisting>
{-# RULES "genericLookup/Int" genericLookup = intLookup #-}
</programlisting>

この少々奇妙な規則は、<function>genericLookup</function>を<function>intLookup</function>に、<emphasis>型が適合するときはいつでも</emphasis>置き換えるように指示するものである。さらに、<literal>SPECIALIZE</literal>プラグマの場合と違って、この規則は<function>genericLookup</function>と同じモジュールにある必要がない。(<literal>SPECIALIZE</literal>プラグマの場合は、特殊化するのに元の定義が必要である)
</para>

<para><function>intLookup</function>がちゃんと<function>genericLookup</function>の特別な場合として振る舞うようにするのは<emphasis>あなたの責任</emphasis>である！！！</para>

<para><literal>RULES</literal>を使った特殊化が高い効果をあげる例を一つ挙げる。

<programlisting>
toDouble :: Real a => a -> Double
toDouble = fromRational . toRational

{-# RULES "toDouble/Int" toDouble = i2d #-}
i2d (I# i) = D# (int2Double# i) -- Glasgowのprim-opを直接使う
</programlisting>

<function>i2d</function>関数は、事実上、機械語命令一個である。これに比べると、<literal>Rational</literal>を経由した通常の変換は、非常識なまでに効率が悪い。
</para>

</sect2>

<sect2>
<title>何が起こるか制御する</title>

<para>

<itemizedlist>
<listitem>

<para>
GHCがどの変換規則を使っているかを見るには<option>-ddump-rules</option>を使う。
</para>
</listitem>
<listitem>

<para>
どの規則が発動したかを知るには<option>-ddump-simpl-stats</option>を使う。<option>-dppr-debug</option>も加えればより詳細な出力が得られる。</para>
</listitem>
<listitem>

<para>
例えば、<filename>GHC/Base.lhs</filename>の<function>build</function>の定義は以下の様になっている。

<programlisting>
        build   :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
        {-# INLINE build #-}
        build g = g (:) []
</programlisting>

<literal>INLINE</literal>が使われていることに注意。これのおかげで、<literal>PrelBase</literal>をコンパイルするときに<literal>(:)</literal>がインライン化されることがなく、結果としてインポート元のモジュールが<literal>(:)</literal>を「見る」ことができ、これを規則の左辺に適合させることができる。<literal>INLINE</literal>があると、その<literal>INLINE</literal>なものの右辺にインライン化が発生することが抑制される。私はこの気遣いを後悔している。

</para>
</listitem>
<listitem>

<para>
融合変換を行い、融合が起こらなかった場合でも効率的なプログラムになるような規則の書き方については<filename>libraries/base/GHC/Base.lhs</filename>にある<function>map</function>の規則を見よ。<filename>GHC/List.lhs</filename>にも規則がある。
</para>
</listitem>

</itemizedlist>

</para>

</sect2>

<sect2 id="core-pragma">
  <title>COREプラグマ</title>

  <indexterm><primary>CORE pragma</primary></indexterm>
  <indexterm><primary>pragma, CORE</primary></indexterm>
  <indexterm><primary>core, annotation</primary></indexterm>

<para>
  外部コア形式は「Note」注釈をサポートしている。<literal>CORE</literal>プラグマを使うと、どういう注釈を入れるかをHaskellコード中で指定することができる。構文的には、core注釈は式に付属し、Haskellの文字列リテラルを引数として取る。以下の関数定義が例である。

<programlisting>
f x = ({-# CORE "foo" #-} show) ({-# CORE "bar" #-} x)
</programlisting>

意味上は、これは以下のものに等しい。

<programlisting>
g x = show x
</programlisting>
</para>

<para>
しかし、(<option>-fext-core</option>で)外部coreが生成されるとき、式<function>show</function>と<varname>x</varname>にNoteが付加される。<function>f</function>のcoreでの宣言は以下である。
</para>

<programlisting>
  f :: %forall a . GHCziShow.ZCTShow a ->
                   a -> GHCziBase.ZMZN GHCziBase.Char =
    \ @ a (zddShow::GHCziShow.ZCTShow a) (eta::a) ->
        (%note "foo"
         %case zddShow %of (tpl::GHCziShow.ZCTShow a)
           {GHCziShow.ZCDShow
            (tpl1::GHCziBase.Int ->
                   a ->
                   GHCziBase.ZMZN GHCziBase.Char -> GHCziBase.ZMZN GHCziBase.Char)
            (tpl2::a -> GHCziBase.ZMZN GHCziBase.Char)
            (tpl3::GHCziBase.ZMZN a ->
                   GHCziBase.ZMZN GHCziBase.Char -> GHCziBase.ZMZN GHCziBase.Char) ->
              tpl2})
        (%note "bar"
         eta);
</programlisting>

<para>
ここで、関数<function>show</function>(これは展開されてShow辞書についてのcase式になっている)に<literal>%note</literal>が付属していることが分かる。<varname>eta</varname>(<varname>x</varname>という名前だったもの)も同様である。
</para>

</sect2>

</sect1>

<sect1 id="special-ids">
<title>特殊な組込み関数</title>
<para>GHCには特殊な振る舞いをする組込み関数が少々ある。これらはライブラリ説明書の<ulink url="../libraries/ghc-prim/GHC-Prim.html"><literal>GHC.Prim</literal></ulink>(訳注: 未訳。<ulink url="http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim/GHC-Prim.html">web上の最新版</ulink>)モジュールに解説がある。</para>
</sect1>


<sect1 id="generic-classes">
<title>総称クラス</title>

<para>
この拡張の背後にある考えは"Derivable type classes", Ralf Hinze and Simon Peyton Jones, Haskell Workshop, Montreal Sept 2000, pp94-105で詳述されている。例を挙げればどういうものか分かるだろう。
</para>

<programlisting>
  import Generics

  class Bin a where
    toBin   :: a -> [Int]
    fromBin :: [Int] -> (a, [Int])
  
    toBin {| Unit |}    Unit	  = []
    toBin {| a :+: b |} (Inl x)   = 0 : toBin x
    toBin {| a :+: b |} (Inr y)   = 1 : toBin y
    toBin {| a :*: b |} (x :*: y) = toBin x ++ toBin y
  
    fromBin {| Unit |}    bs      = (Unit, bs)
    fromBin {| a :+: b |} (0:bs)  = (Inl x, bs')    where (x,bs') = fromBin bs
    fromBin {| a :+: b |} (1:bs)  = (Inr y, bs')    where (y,bs') = fromBin bs
    fromBin {| a :*: b |} bs	  = (x :*: y, bs'') where (x,bs' ) = fromBin bs
							  (y,bs'') = fromBin bs'
</programlisting>
<para>
このクラス宣言は、<literal>toBin</literal>と<literal>fromBin</literal>が任意のデータ型についてどのように動作するかを説明している。これを達成するために、単位、積、和のそれぞれの場合についての処理を与えている。これらは<literal>Generics</literal>というライブラリモジュールで定義されている。
</para>
<programlisting>
  data Unit    = Unit
  data a :+: b = Inl a | Inr b
  data a :*: b = a :*: b
</programlisting>
<para>
これで、次のようにしてデータ型をBinのインスタンスにすることができる。
<programlisting>
  instance (Bin a, Bin b) => Bin (a,b)
  instance Bin a => Bin [a]
</programlisting>
つまり、単に「where」節を省略すれば良い。もちろん、where節を書いて、望むメソッドを再定義することもできる。
</para>

    <sect2>
      <title>総称性を使う</title>
      <para>総称性を使うには以下のものが必要である。</para>
      <itemizedlist>
	<listitem>
	  <para>フラグとして、<option>-fglasgow-exts</option>(拡張文法を有効にする)と<option>-XGenerics</option>(データ型毎の追加コードを生成する)と<option>-package lang</option>(<literal>Generics</literal>ライブラリを利用可能にする)を使う。</para>
	</listitem>
	<listitem>
          <para><literal>lang</literal>パッケージの<literal>Generics</literal>モジュールをインポートする。これによって、<literal>Unit</literal>、<literal>:*:</literal>、<literal>:+:</literal>の各データ型がスコープに導入される。(これらの型に明示的に言及しないならインポートは必要ない。インスタンス宣言を行うだけの場合など)</para>
	</listitem>
      </itemizedlist>
    </sect2>

<sect2> <title>論文からの変更点</title>
<para>
型構築子<literal>:+:</literal>および<literal>:*:</literal>は中置記法で書かれることに注意。(実際、コロンで始まるあらゆる演算子列が型構築子として使えるようになった)。また、型構築子は論文そのままではない(1の代わりにUnit、など)。最後に、クラス宣言のパターンの構文で使われる括弧は「<literal>{|</literal>」と「<literal>|}</literal>」である。中括弧だけだと、右辺で使われる(こういう拡張が必要になるかもしれない)ときに曖昧になる。
</para>
</sect2>

<sect2> <title>用語と制約</title>
<para>
用語。クラス宣言中の「総称デフォルトメソッド」とは、上のような型パターンを使って定義されたもののことである。「多相デフォルトメソッド」とは、Haskell 98式のデフォルトメソッドのことである。「総称クラス宣言」とは、少なくとも一つの総称デフォルトメソッドを含むクラス宣言のことである。
</para>

<para>
制約は以下の通り。
<itemizedlist>
<listitem>
<para>
残念ながら、構築子名とフィールドラベルに関するものはまだ実装していない。
</para>
</listitem>

<listitem>
<para>
総称クラスのパラメタは一つでなければならない。総称的な複数引数型クラスを書くことはできない。
</para>
</listitem>

<listitem>
<para>
あるデフォルトメソッドは、全部型パターンを使って定義するか、全部型パターンなしで定義するかのいずれかでなければならない。従って以下は不正である。
<programlisting>
  class Foo a where
    op :: a -> (a, Bool)
    op {| Unit |} Unit = (Unit, True)
    op x               = (x,    False)
</programlisting>
一方、ある総称クラスについて、総称デフォルトメソッドと多相デフォルトメソッドの両方があるのは、全く問題ない。
</para>
</listitem>

<listitem>
<para>
総称メソッド宣言の型パターンに現れる型変数は右辺全体に渡るスコープを持つ。従って下記は合法である。(型変数「p」を右辺の型シグネチャで使っていることに注意)
<programlisting>
  class Foo a where
    op :: a -> Bool
    op {| p :*: q |} (x :*: y) = op (x :: p)
    ...
</programlisting>
</para>
</listitem>

<listitem>
<para>
総称デフォルトメソッドにおける型パターンは以下のいずれかの形を取らなければならない。
<programlisting>
       a :+: b
       a :*: b
       Unit
</programlisting>
ここで「a」と「b」は型変数である。さらに、一つの型構築子(例えば<literal>:*:</literal>)についての型パターンは全て同じでなければならない。これは、同じ型変数を使わなければならないということである。したがって以下の例は非合法である。
<programlisting>
  class Foo a where
    op :: a -> Bool
    op {| a :+: b |} (Inl x) = True
    op {| p :+: q |} (Inr y) = False
</programlisting>
あるクラスの異なるメソッドの間でも、やはり型パターンは相等しくなければならない。従って以下は非合法である。
<programlisting>
  class Foo a where
    op1 :: a -> Bool
    op1 {| a :*: b |} (x :*: y) = True

    op2 :: a -> Bool
    op2 {| p :*: q |} (x :*: y) = False
</programlisting>
(この制約があるのは、ひとつの総称インスタンス宣言を作る際、特定の型構築子についての等式を全て集めるからである)
</para>
</listitem>

<listitem>
<para>
総称メソッド宣言では、この三つの型構築子のそれぞれの場合について処理を与えなければならない。
</para>
</listitem>

<listitem>
<para>
総称メソッドの型は、以下の型のみから構成されていなければならない。
  <itemizedlist>
  <listitem> <para>関数の矢印</para> </listitem>
  <listitem> <para>型変数</para> </listitem>
  <listitem> <para>タプル</para> </listitem>
  <listitem> <para>型変数を含まない任意の型</para> </listitem>
  </itemizedlist>
総称メソッドの型シグネチャの例である。
<programlisting>
    op1 :: a -> Bool
    op2 :: Bool -> (a,Bool)
    op3 :: [Int] -> a -> a
    op4 :: [a] -> Bool
</programlisting>
ここで、op1、op2、op3は問題ないが、op4は拒否される。リストの中に型変数があるからである。
</para>
<para>
この制約は実装上の都合によるものである。我々には、任意の型構築子について必要な双方向写像を実装する時間の余裕がない。Maybeやリストといった特定の型構築子を許されるようにするのは比較的簡単だろう。</para>
</listitem>

<listitem>
<para>
総称クラスのインスタンス宣言では、基本的には、総称テンプレートを基にして、コンパイラがメソッドを挿入する。しかし、これには以下の条件が必要である。
  <itemizedlist>
  <listitem>
  <para>
  インスタンス型が単純(Haskell 98の通りに、型構築子を型変数に適用したもの)であること。
  </para>
  </listitem>
  <listitem>
  <para>
  インスタンス型の構築子に、非ボックス化フィールドを持つものがないこと。
  </para>
  </listitem>
  </itemizedlist>
(もちろん、これらは既にGHC拡張を使っている場合にのみ該当し得る)。また、明示的なコードで総称デフォルトメソッドを全て再定義することで、この規則に反する型にインスタンス宣言を与えることができる。
</para>
</listitem>

</itemizedlist>
</para>

<para>
<option>-ddump-deriv</option>オプションを使うと、総称宣言についてコンパイラが何をしているかの詳細を含んだ、理解困難な何かを表示することができる。
</para>

</sect2>

<sect2> <title>もう一つの例</title>
<para>
最後に、私が少し気に入っている例を挙げる。
<programlisting>
  class Tag a where
    nCons :: a -> Int
    nCons {| Unit |}    _ = 1
    nCons {| a :*: b |} _ = 1
    nCons {| a :+: b |} _ = nCons (bot::a) + nCons (bot::b)
  
    tag :: a -> Int
    tag {| Unit |}    _       = 1
    tag {| a :*: b |} _       = 1   
    tag {| a :+: b |} (Inl x) = tag x
    tag {| a :+: b |} (Inr y) = nCons (bot::a) + tag y
</programlisting>
</para>
</sect2>
</sect1>

<sect1 id="monomorphism">
<title>単相性の制御</title>

<para>
letおよびwhere束縛での一般化の扱いに関わるフラグが二つある。
</para>

<sect2>
<title>恐怖の単相性限定を無効にする</title>
          <indexterm><primary><option>-XNoMonomorphismRestriction</option></primary></indexterm>

<para>Haskellの単相性限定(Haskellレポートの<ulink url="http://www.haskell.org/onlinereport/decls.html#sect4.5.5">4.5.5節</ulink>(<ulink url="http://www.sampou.org/haskell/report-revised-j/decls.html#sect4.5.5">和訳</ulink>)を見よ)は、<option>-XNoMonomorphismRestriction</option>で完全に無効にできる。
</para>
</sect2>

<sect2>
<title>単相的パターン束縛</title>
          <indexterm><primary><option>-XNoMonoPatBinds</option></primary></indexterm>
          <indexterm><primary><option>-XMonoPatBinds</option></primary></indexterm>

	  <para>実験的な変更として、我々はパターン束縛を単相的にする可能性を探っている。単相的というのは、全く一般化されないということである。パターン束縛とは、左辺に関数引数がなく、かつ、左辺が単純な変数でないものである。例を示す。
<programlisting>
  f x = x                    -- パターン束縛ではない
  f = \x -> x                -- パターン束縛ではない
  f :: Int -> Int = \x -> x  -- パターン束縛ではない

  (g,h) = e                  -- パターン束縛
  (f) = e                    -- パターン束縛
  [x] = e                    -- パターン束縛
</programlisting>
実験的に、GHCは<emphasis>デフォルトで</emphasis>パターン束縛を単相的にする。標準の振る舞いに戻すには<option>-XNoMonoPatBinds</option>を使うこと。
</para>
</sect2>
</sect1>



<!-- Emacs stuff:
     ;;; Local Variables: ***
     ;;; mode: xml ***
     ;;; sgml-parent-document: ("users_guide.xml" "book" "chapter" "sect1") ***
     ;;; ispell-local-dictionary: "british" ***
     ;;; End: ***
 -->

